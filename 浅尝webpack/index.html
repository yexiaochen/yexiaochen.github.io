<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="baidu-site-verification" content="dil57BBbBc"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="YH32omENY7b_BdEuIWv46jSBK-0Vyw_dWbJTGNBblT0"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="webpack,"><meta name="description" content="吐槽一下webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中"><meta name="keywords" content="webpack"><meta property="og:type" content="article"><meta property="og:title" content="浅尝webpack"><meta property="og:url" content="https://yexiaochen.github.io/浅尝webpack/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="吐槽一下webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2023-02-06T15:14:47.416Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="浅尝webpack"><meta name="twitter:description" content="吐槽一下webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://yexiaochen.github.io/浅尝webpack/"><title>浅尝webpack | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7503c6e413a2a7205320ec2396c811d0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yexiaochen.github.io/浅尝webpack/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">浅尝webpack</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-19T10:24:31+08:00">2019-05-19 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2023-02-06T23:14:47+08:00">2023-02-06 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/写着玩/" itemprop="url" rel="index"><span itemprop="name">写着玩</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2,712 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">11 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。</p><p>纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中文版的官方文档，通俗易懂，很感谢翻译组的辛勤奉献。看完之后，虽然达不到炉火纯青的地步，但也不会捉襟见肘，疲于应付。</p><p>对于这种工具类的博文，依然沿袭 <a href="http://yexiaochen.github.io/%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript/">用Type驯化JavaScript</a> 的风格，串联各个概念。至于细节，就是官方文档的事了。</p><p>本文基于 <strong><em>webpack v4.31.0 </em></strong>版本。</p><h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><blockquote><p>Tapable 是一个小型的库，允许你对一个 javascript 模块添加和应用插件。它可以被继承或混入到其他模块中。类似于 NodeJS 的 EventEmitter 类，专注于自定义事件的触发和处理。除此之外，Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)”。</p></blockquote><p>tapable 是 webpack 的核心，webpack 中的很多对象（compile， compilation等）都扩展自tapable，包括 webpack 也是 tapable 的实例。扩展自 tapable 的对象内部会有很多钩子，它们贯穿了 webpack 构建的整个过程。我们可以利用这些钩子，在其被触发时，做一些我们想做的事情。</p><p>抛开 webpack 不谈，先看看 tapable 的简单使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  SyncHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      init: <span class="keyword">new</span> SyncHook([<span class="string">'init'</span>])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.plugins = options.plugins;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.beforeInit();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">        plugin.apply(<span class="keyword">this</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hooks.init.call(<span class="string">'初始化中。。。'</span>);</span><br><span class="line">    <span class="keyword">this</span>.afterInit();</span><br><span class="line">  &#125;</span><br><span class="line">  beforeInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'初始化前。。。'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  afterInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'初始化后。。。'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Main;</span><br><span class="line"><span class="comment">// MyPlugin.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  apply(main) &#123;</span><br><span class="line">    main.hooks.init.tap(<span class="string">'MyPlugin'</span>, param =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'init 钩子，做些啥；'</span>, param);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> Main = <span class="built_in">require</span>(<span class="string">'./Main'</span>);</span><br><span class="line"><span class="keyword">const</span> MyPlugin = <span class="built_in">require</span>(<span class="string">'./MyPlugin'</span>);</span><br><span class="line"><span class="keyword">let</span> myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line"><span class="keyword">new</span> Main(&#123; <span class="attr">plugins</span>: [myPlugin] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化前。。。</span></span><br><span class="line"><span class="comment">// init 钩子，做些啥; 初始化中。。。</span></span><br><span class="line"><span class="comment">// 初始化后。。。</span></span><br></pre></td></tr></table></figure><p>理解起来很简单，就是在 <code>init</code> 处触发钩子，<code>this.hooks.init.call(params)</code> 类似于我们熟悉的 <code>EventEmitter.emit(&#39;init&#39;, params)</code>。<code>main.hooks.init.tap</code> 类似于 <code>EventEmitter.on(&#39;init&#39;, callback)</code>，在 <code>init</code>钩子上绑定一些我们想做的事情。在后面将要说的 webpack 自定义插件，就是在 webpack 中的某个钩子处，插入自定义的事。</p><h2 id="理清概念"><a href="#理清概念" class="headerlink" title="理清概念"></a>理清概念</h2><ul><li><strong>依赖图</strong><br>在单页面应用中，只要有一个入口文件，就可以把散落在项目下的各个文件整合到一起。何谓依赖，当前文件需要什么，什么就是当前文件的依赖。依赖引入的形式有如下：<ul><li>ES2015 <code>import</code> 语句</li><li>CommonJS <code>require()</code> 语句</li><li>AMD <code>define</code> 和 <code>require</code> 语句</li><li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接</li></ul></li></ul><ul><li><p><strong>入口(entry)</strong><br>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始。</p></li><li><p><strong>输出(output)</strong><br>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p></li><li><p><strong>模块(module)</strong><br>决定了如何处理项目中的不同类型的模块。比如设置 loader，处理各种模块。设置 noParse，忽略无需 webpack 解析的模块。</p></li><li><p><strong>解析(resolve)</strong><br>设置模块如何被解析。引用依赖时，需要知道依赖间的路径关系，应遵循何种解析规则。比如给路径设置别名（alias），解析模块的搜索目录（modules），解析 loader 包路径（resolveLoader）等。</p></li><li><p><strong>外部扩展(externals)</strong><br>防止将某些 import 的包（package）打包到 bundle 中，而是在运行时（runtime）再去从外部获取这些扩展依赖。比如说，项目中引用了 jQuery 的CDN资源，在使用 <code>import $ from &#39;jquery&#39;;</code>时，webpack 会把 jQuery 打包进 bundle，其实这是没有必要的，此时需要配置 <code>externals: {jquery: &#39;jQuery&#39;}</code>，将其剔除 bundle。</p></li><li><p><strong>插件(plugins)</strong><br>用于以各种方式自定义 webpack 构建过程。可以利用 webpack 中的钩子，做些优化或者搞些小动作。</p></li><li><p><strong>开发设置(devServer)</strong><br>顾名思义，就是开发时用到的选项。比如，开发服务根路径（contentBase），模块热替换（hot，需配合 <code>HotModuleReplacementPlugin</code> 使用），代理（proxy）等。</p></li><li><p><strong>模式(mode)</strong><br>提供 mode 配置选项，告知 webpack 使用相应环境的内置优化。具体可见 <a href="https://webpack.docschina.org/concepts/mode/" rel="external nofollow noopener noreferrer" target="_blank">模式(mode)</a></p></li><li><p><strong>优化(optimization)</strong><br>从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化，不过所有的优化还是可以手动配置和重写。比如，<code>CommonsChunkPlugin</code>被 <code>optimization.splitChunks</code> 取代。</p></li></ul><p>webpack 差不多就是这几个配置项，搞清楚这几个概念，上手还是比较容易的。</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>现在的前端项目越来越复杂，如果最终导出为一个 bundle，会极大地影响加载速度。切割 bundle，控制资源加载优先级，按需加载或并行加载，合理应用就会大大缩短加载时间。官方文档提供了三种常见的代码分离方法：</p><ul><li><p><strong>入口起点</strong><br>配置多个入口文件，然后将最终生成的过个 bundle 出入到 HTML 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span></span><br><span class="line">&#125;</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    chunks: [<span class="string">'vendor'</span>, <span class="string">'index'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>不过如果这两个文件中存在相同的模块，这就意味着相同的模块被加载了两次。此时，我们就需要提取出重复的模块。</p></li><li><p><strong>防止重复</strong><br>在 webpack 老的版本中，<code>CommonsChunkPlugin</code> 常用来提取公共的模块。新版本中 <code>SplitChunksPlugin</code> 取而代之，可以通过 <code>optimization.splitChunks</code> 设置，多见于多页面应用。</p></li><li><p><strong>动态导入</strong><br>就是在需要时再去加载模块，而不是一股脑的全部加载。webpack 还提供了预取和预加载的方式。非入口 chunk，我们可以通过 chunkFilename 为其命名。常见的如，vue 路由动态导入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">output: &#123;</span><br><span class="line">  chunkFilename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "someJs" */</span> <span class="string">'someJs'</span>);</span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">'someJs'</span>);</span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPreload: true */</span> <span class="string">'someJs'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>基于浏览器的缓存策略，我们知道如果本地缓存命中，则无需再次请求资源。对于改动不频繁或基本不会再做改动的模块，可以剥离出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们的想法，只要模块的内容没有变化，对应的名字也就不会发生变化，这样缓存就会起作用了。事实上并非如此，webpack 打包后的文件，并非只有用户自己的代码，还包括管理用户代码的代码，如 runtime 和 manifest。</p><p>模块依赖间的整合并不是简单的代码拼接，其中包括模块的加载和解析逻辑。注入的 runtime 和 manifest 在每次构建后都会发生变化。这就导致了即使用户代码没有变化，某些 hash 还是发生了改变。通过 <code>optimization.runtimeChunk</code> 提取 runtime 代码。通过 <code>optimization.splitChunks</code> 剥离第三方库。比如， react，react-dom。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">'single'</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom)[\\/]/</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后使用 <code>HashedModuleIdsPlugin</code> 来消除因模块 ID 变动带来的影响。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader API;</span></span><br><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">  err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">  content: string | Buffer,</span><br><span class="line">  sourceMap?: SourceMap,</span><br><span class="line">  meta?: any</span><br><span class="line">);</span><br><span class="line"><span class="comment">// sync loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, syncOperation(content, map, meta));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// async loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  asyncOperation(content, (error, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error) callback(error);</span><br><span class="line">    callback(<span class="literal">null</span>, result, map, meta);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 loader 串行时，在从右向左执行 loader 之前，会向从左到右调用 loader 上的 pitch 方法。如果在 pitch 中返回了结果，则会跳过后续 loader。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|- a-loader <span class="code">`pitch`</span></span><br><span class="line">  |- b-loader <span class="code">`pitch`</span></span><br><span class="line"><span class="code">    |- c-loader `pitch`</span></span><br><span class="line"><span class="code">      |- requested module is picked up as a dependency</span></span><br><span class="line"><span class="code">    |- c-loader normal execution</span></span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- pitch 中返回结果 --&gt;</span></span></span><br><span class="line"></span><br><span class="line">|- a-loader <span class="code">`pitch`</span></span><br><span class="line">  |- b-loader <span class="code">`pitch`</span> returns a module</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>webpack 的自定义插件和本文开头 Tapable 中的差不多。webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。钩子有同步的，也有异步的，这需要根据 webpack 提供的 API 文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步)</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'FileListPlugin'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 在生成文件中，创建一个头部字符串：</span></span><br><span class="line">      <span class="keyword">var</span> filelist = <span class="string">'In this build:\n\n'</span>;</span><br><span class="line">      <span class="comment">// 遍历所有编译过的资源文件，</span></span><br><span class="line">      <span class="comment">// 对于每个文件名称，都添加一行内容。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> filename <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        filelist += <span class="string">'- '</span> + filename + <span class="string">'\n'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将这个列表作为一个新的文件资源，插入到 webpack 构建中：</span></span><br><span class="line">      compilation.assets[<span class="string">'filelist.md'</span>] = &#123;</span><br><span class="line">        source: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> filelist;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> filelist.length;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin;</span><br></pre></td></tr></table></figure><ul><li><p>ProvidePlugin<br>自动加载模块，无需处处引用。有点类似 <code>expose-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// some.js</span></span><br><span class="line">$(<span class="string">'#item'</span>);</span><br></pre></td></tr></table></figure></li><li><p>DllPlugin<br>将基础模块打包进动态链接库，当依赖的模块存在于动态链接库中时，无需再次打包，而是直接从动态链接库中获取。DLLPlugin 负责打包出动态链接库，DllReferencePlugin 负责从主要配置文件中引入 DllPlugin 插件打包好的动态链接库文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack-dll-config.js</span></span><br><span class="line"><span class="comment">// 先执行该配置文件</span></span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">  filename: <span class="string">"MyDll.[name].js"</span>,</span><br><span class="line">  library: <span class="string">"[name]_[hash]"</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">"dist"</span>, <span class="string">"[name]-manifest.json"</span>),</span><br><span class="line">    name: <span class="string">"[name]_[hash]"</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// webpack-config.js</span></span><br><span class="line"><span class="comment">// 后执行该配置文件</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">"../dll/dist/alpha-manifest.json"</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>HappyPack<br>启动子进程处理任务，充分利用资源。不过进程间的通讯比较耗资源，要酌情处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="comment">// loader</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">  exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// plugins</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">'babel'</span>,</span><br><span class="line">  loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>webpack-bundle-analyzer<br>webpack 打包后的分析工具。</p></li></ul><p>webpack 告一段落，浅尝辄止。</p></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://yexiaochen.github.io/浅尝webpack/" title="浅尝webpack">https://yexiaochen.github.io/浅尝webpack/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/webpack/" rel="tag"><i class="fa fa-tag"></i> webpack</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/《你的孤独，虽败犹荣》摘抄/" rel="next" title="读《你的孤独，虽败犹荣》"><i class="fa fa-chevron-left"></i> 读《你的孤独，虽败犹荣》</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/数据结构/" rel="prev" title="数据结构">数据结构 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#吐槽一下"><span class="nav-number">1.</span> <span class="nav-text">吐槽一下</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tapable"><span class="nav-number">2.</span> <span class="nav-text">Tapable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理清概念"><span class="nav-number">3.</span> <span class="nav-text">理清概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码分离"><span class="nav-number">4.</span> <span class="nav-text">代码分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存"><span class="nav-number">5.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#loader"><span class="nav-number">6.</span> <span class="nav-text">loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#plugins"><span class="nav-number">7.</span> <span class="nav-text">plugins</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>