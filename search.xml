<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年阶段性总结</title>
    <url>/2020%E5%B9%B4%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote><p>如果达成某个目标，再把这个博客补上。</p></blockquote><p>如今正是兑现这个承诺的时刻，在这一年多的时间中，经历了好多，思考了很多，也收获了很多。与之前相比，变了很多，没变的也很多。</p><blockquote><p>剑未配妥，出门已是江湖；<br>过尽千帆，归来仍是少年。</p></blockquote><p>说是阶段性总结，其实就是关于某些看法的个人浅见，再辅之以道德经做旁注，简直就是十足的神棍。</p><blockquote><p>道可道，非常道；名可名，非常名。<br>无名天地之始，有名万物之母。<br>故常无欲，以观其妙；<br>常有欲，以观其徼。<br>此两者同出而异名，同谓之玄，玄之又玄，众妙之门。</p></blockquote><p>以「无」溯其根源，以「有」窥其轨迹。我所处的世界是建立在我的认知基础上，当我探寻一个问题时，由于我的出发点不同，注重点也会不同，得出的结论自然也会不同，而且这个结论还可能有着强烈的个人偏见。当我的结论被公布出去后，别人会在自己的认知上去审视这个问题，此时我的结论就是在我的认知与他人的认知共同作用下得出的结果。那么，这个结果还是我的结论么？</p><blockquote><p>上面的这个问题就引出了另外的一个问题，如何表述客观事物，如何表达自己的想法，如何理解别人的想法，如何理解别人表述的客观事实。</p></blockquote><p>我的认知是不断变化的，到最后我都可能去否定自己结论。我说的道理不稳定，甚至不具有普适性。而且，我用语言等媒介能够完整地表达自己的想法么？当想法通过各种媒介传递给别人，别人再去理解时，我的真实想法又还剩多少呢？所以，事情就变得很玄学了。</p><p>到底如何去解读呢？去除自己的主观想法，剥离他人的个人偏见，溯其本源。譬如，现在的议论文，都喜欢举例论证，因为这些都是接近真相的客观事实，在每个人的世界中都可以得到论证的。然而，你以为的真，甚至大家以为的真，真的是真的么？所以，真真假假，事情变得就更加玄乎了。</p><p>好了，以上的问题扯来扯去都有点晕乎了。然而，这也是本文要说的一点 —— 思维开放。认不认可无所谓，如果你抵触以上的观点，我们就可以认为你在思维上不开放。</p><p>当然，解释了那么多并不是为了论证思维的开放性，而是要求我们应该思维开放。我们的思维不应该被局限于自己的一亩三分地，要有底气去质疑一切，因为这个世界你从未真正审视过。</p><blockquote><p>知不知，上；不知知，病。<br>夫唯病病，是以不病。圣人不病，以其病病，是以不病。</p></blockquote><p>你以为我只用白话文说你思维不开放就算完事了？不，图样图森破。</p><p>知道我们知道的，这很不错；但是拒绝承认我们不知道的，这是一种病态，这个一种固执已见的体现。只有知道我们还有不知道的，才能去接纳我们不知道的，才能将不知道的转化为知道的。生活中总有一些「杠精」，总是喜欢拿自己知道的去反驳自己不知道的。这和「凡是我不认识的字都不识字」有何区别？如果要问如何与这些人沟通，不好意思，和有「病」的人沟通不来。</p><p>无为而无不为，而不是无所作为。否认自己，是为了更好地认识自己。</p><blockquote><p>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一，为天下式。<br>不自见故明，不自是故彰，不自伐故有功，不自矜故长。夫唯不争，故天下莫能与之争。<br>古之所谓曲则全者，岂虚言哉！诚全而归之。</p></blockquote><p>自见，自是，自伐，自矜，正因为脑袋里装的都是自己，所以再也容纳不了其他的。曲、洼、少可保全、盈、得，枉、敝、多反而会招致直、新、惑。由于总是处在不断成长的状态中，等你反应过来时，你已经甩开了很多人。</p><blockquote><p>其安易持，其未兆易谋，其脆易泮，其微易散。<br>为之于未有，治之于未乱。<br>合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。<br>为者败之，执者失之。是以圣人无为，故无败；无执，故无失。<br>民之从事，常几成而败之。<br>慎终如始，则无败事。是以圣人欲不欲，不贵难得之货。<br>学不学，复众人之所过。<br>以辅万物之自然，而不敢为。</p></blockquote><p>真以为只要努力就一定会成功？这又不是心灵鸡汤。万物皆有规律，「天下难事必做于易，天下大事必做于细」，有因必有果，借势而行，顺势而为，不可为，不可执。</p><p>有点扯远了，懒癌犯了，不想写了，最后说下沟通和聊天的看法。沟通是一门艺术，它的目的是为了交流彼此的观点，并在此基础上达成一致。它需要根据沟通的对象，沟通的话题等因素不断去调整表述的方式，以达到高效的交流。而聊天，则不是。</p>]]></content>
      <categories>
        <category>不语</category>
      </categories>
      <tags>
        <tag>道德经</tag>
        <tag>学习之道</tag>
      </tags>
  </entry>
  <entry>
    <title>Array原型之变异方法</title>
    <url>/Array%E5%8E%9F%E5%9E%8B%E4%B9%8B%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p><strong>Array</strong>对象是用于构造数组的全局对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组对象是一个<strong>有序</strong>的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.<br>数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过<code>[]</code>或<code>.</code>来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="string">'zero'</span>] = <span class="string">'zero'</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><h4 id="Array-prototype-push"><a href="#Array-prototype-push" class="headerlink" title="Array.prototype.push()"></a>Array.prototype.push()</h4><p><strong>描述</strong> :<br>在数组末尾添加一个或多个元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.push(element0 ..., elementN)</code></em></p></blockquote><p><strong><code>elementN</code></strong> : 将要添加到数组末尾的元素.<br><strong><code>返回值</code></strong> : 被改动后的原数组的<code>length</code>值, 且原数组被改变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr0Len = arr0.push(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr0Len:'</span>, arr0Len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [3, 2, 1, 'Array'] arr0Len: 4;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-unshift"><a href="#Array-prototype-unshift" class="headerlink" title="Array.prototype.unshift()"></a>Array.prototype.unshift()</h4><p><strong>描述</strong> :<br>在数组开头添加一个或多个元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.unshift(element1, ..., elementN)</code></em></p></blockquote><p><strong><code>elementN</code></strong> : 将要添加到数组开头的元素.<br><strong><code>返回值</code></strong> : 被改动后的原数组的<code>length</code>值, 且原数组被改变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr0Len = arr0.unshift(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr0Len:'</span>, arr0Len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: ['Array', 3, 2, 1] arr0Len: 4;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-pop"><a href="#Array-prototype-pop" class="headerlink" title="Array.prototype.pop()"></a>Array.prototype.pop()</h4><p><strong>描述</strong> :<br>从数组中删除最后一个元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.pop()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> ele = arr0.pop();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'ele:'</span>, ele);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [3, 2] ele: 1;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-shift"><a href="#Array-prototype-shift" class="headerlink" title="Array.prototype.shift()"></a>Array.prototype.shift()</h4><p><strong>描述</strong> :<br>从数组中删除第一个元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.shift()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> ele = arr0.shift();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'ele:'</span>, ele);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [2, 1] ele: 3;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-splice"><a href="#Array-prototype-splice" class="headerlink" title="Array.prototype.splice()"></a>Array.prototype.splice()</h4><p><strong>描述</strong> :<br>从数组中删除指定数量的元素并添加向数组添加元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>array.splice(start[, deleteCount[, element1[, ...[, elementN]]]])</code></em></p></blockquote><p><strong><code>start</code></strong> : 指定修改位置(从0计数).<br><strong><code>deleteCount</code></strong> 要移除的数组元素个数. 默认值为 this.length - start.<br><strong><code>elementN</code></strong> : 要添加的数组元素.<br><strong><code>返回值</code></strong> : 由被删除的元素组成的数组, 且原数组被改变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [3, 2, 4, 5, 6, 1] arr00: [];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr11 = arr1.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr1:'</span>, arr1, <span class="string">'arr11:'</span>, arr11);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1: [3, 2, 4, 5, 6] arr11: [1];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr33 = arr3.splice(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr3:'</span>, arr3, <span class="string">'arr33:'</span>, arr33);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr3: [3] arr33: [2, 1];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr44 = arr4.splice(<span class="number">3</span>, <span class="number">0</span> , <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr4:'</span>, arr4, <span class="string">'arr44:'</span>, arr44);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr4: [3, 2, 1, 4, 5, 6] arr44: [];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h4><p><strong>描述</strong> :<br>用原地算法对数组的元素进行排序.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.sort([compareFunction])</code></em></p></blockquote><p><strong><code>compareFunction</code></strong> : 用来指定按某种顺序进行排列的函数. 如果省略, 元素按照转换为的字符串的各个字符的Unicode位点进行排序. 指明了 compareFunction, 那么数组会按照调用该函数的返回值排序. a 和 b 是两个将要被比较的元素:</p><blockquote><ul><li><code>compareFunction(a, b)</code> 小于 0, 那么 a 会被排列到 b 之前;</li><li><code>compareFunction(a, b)</code> 等于 0, a 和 b 的相对位置不变;</li><li><code>compareFunction(a, b)</code> 大于 0, b 会被排列到 a 之前;</li></ul></blockquote><p><strong><code>返回值</code></strong> : 排序后的数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a-b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0:, [1, 2, 3, 4, 5] arr00: [1, 2, 3, 4, 5];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse()"></a>Array.prototype.reverse()</h4><p><strong>描述</strong> :<br>将数组中元素的位置颠倒.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.reverse()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 位置颠倒后的数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [1, 2, 3] arr00: [1, 2, 3];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-copyWithin"><a href="#Array-prototype-copyWithin" class="headerlink" title="Array.prototype.copyWithin()"></a>Array.prototype.copyWithin()</h4><p><strong>描述</strong> :<br>将数组的某一部分浅复制到指定位置.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.copyWithin(target[, start[, end]])</code></em></p></blockquote><p><strong><code>target</code></strong> : 索引起始为0. 被复制的内容将要替换的位置. 如果是负数, target将从 <code>this.length + target</code>开始计算.<br><strong><code>start</code></strong> : 起始索引, 默认值为0. 被复制内容的起始位置, 包括start位置的元素. 如果是负数, 则开始索引会被自动计算成为 <code>this.length + start</code>.<br><strong><code>end</code></strong> : 终止索引, 默认值为this .length, 索引起始为0. 被复制内容的结束位置, 但不包括end位置的元素. 如果是负数. 则终止索引会被自动计算成为 <code>this.length + end</code>.<br><strong><code>返回值</code></strong> : 被改动后的原数组. 数组内容变化, 长度不变.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.copyWithin(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr0: [3, 2, 3] arr00: [3, 2, 3];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr11 = arr1.copyWithin(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr1:'</span>, arr1, <span class="string">'arr11:'</span>, arr11);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1: [3, 2, 2] arr11: [3, 2, 2];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr22 = arr2.copyWithin(<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr2'</span>, arr2, <span class="string">'arr22'</span>, arr22);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1: [3, 2, 2] arr11: [3, 2, 2];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-fill"><a href="#Array-prototype-fill" class="headerlink" title="Array.prototype.fill()"></a>Array.prototype.fill()</h4><p><strong>描述</strong> :<br>将数组的某一区域的全部元素用指定值替换.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.fill(value[, start[, end]])</code></em></p></blockquote><p><strong><code>value</code></strong> : 填充数组的参数值.<br><strong><code>start</code></strong> : 起始索引, 默认值为 0. 如果是负数时, 规则如上.<br><strong><code>end</code></strong> : 终止索引, 默认值为 this.length. 不包括end位置. 如果是负数时, 规则如上.<br><strong><code>返回值</code></strong> : 被改动后的原数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.fill(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [3, 3, 3] arr00: [3, 3, 3];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr11 = arr1.fill(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr1:'</span>, arr1, <span class="string">'arr11:'</span>, arr11);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1: [3, 3, 3] arr11: [3, 3, 3]</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Array构造函数</title>
    <url>/Array%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p><strong>Array</strong>对象是用于构造数组的全局对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组对象是一个<strong>有序</strong>的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.<br>数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过<code>[]</code>或<code>.</code>来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="string">'zero'</span>] = <span class="string">'zero'</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="构造函数属性"><a href="#构造函数属性" class="headerlink" title="构造函数属性"></a>构造函数属性</h2><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>构造函数的length属性,该属性为静态属性(详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length" rel="external nofollow noopener noreferrer" target="_blank">Function.length</a>),不是数组实例的length属性,其值为1.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Array-prototype"><a href="#Array-prototype" class="headerlink" title="Array.prototype"></a>Array.prototype</h3><p>构造函数的原型对象,所有的数组实例都会从Array.prototype继承属性和方法.通过扩展Array原型上的属性和方法进而为所有的数组实例增加属性和方法.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.type = <span class="string">"Array"</span>;</span><br><span class="line"><span class="built_in">Array</span>.prototype.first = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">arr.type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array;</span></span><br><span class="line"></span><br><span class="line">arr.first();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3;</span></span><br></pre></td></tr></table></figure><hr><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p><strong>描述</strong> :<br>从一个类似数组或可迭代对象中创建一个新的数组实例.<br><strong>语法</strong> :</p><blockquote><p><em><code>Array.from(arrayLike[, mapFn[, thisArg]])</code></em></p></blockquote><p><strong><code>ArrrayLike</code></strong> : 伪数组对象(拥有length属性和若干索引属性) 和 可迭代对象.<br><strong><code>mapFn</code></strong> : 返回的新数组都会执行的回调函数.<br><strong><code>thisArg</code></strong> : 执行回调函数时this对应的对象.<br><strong><code>返回值</code></strong> : 新的数组实例.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">'Array'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["A", "r", "r", "a", "y"];</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;)(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 2, 1];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'array'</span>, <span class="built_in">Array</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["array", function];</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], x =&gt; x.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["3", "2", "1"];</span></span><br></pre></td></tr></table></figure><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><strong>描述</strong> :<br>判断待验证的参数是否为<code>Array</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Array.isArray(obj)</code></em></p></blockquote><p><strong><code>obj</code></strong> : 待验证参数.<br><strong>返回值</strong> : 若待验证参数为数组时,则为true; 否则false.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// false;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Array]'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><strong>描述</strong> :<br>创建一个由传入参数组成的新数组实例, 而不考虑参数的数量或类型.<br><strong>语法</strong> :</p><blockquote><p><em><code>Array.of(element0[, element1[, ...[, elementN]]])</code></em></p></blockquote><p><strong><code>elementN</code></strong> : 任意个参数,将顺序得成为数组的元素.<br><strong><code>返回值</code></strong> : 新的数组实例.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3];</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3, 2, 1];</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="string">'Array'</span>, <span class="built_in">Array</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["Array", function];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Polyfill</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.of) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.of = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Array原型之迭代方法</title>
    <url>/Array%E5%8E%9F%E5%9E%8B%E4%B9%8B%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p><strong>Array</strong>对象是用于构造数组的全局对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组对象是一个<strong>有序</strong>的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.<br>数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过<code>[]</code>或<code>.</code>来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="string">'zero'</span>] = <span class="string">'zero'</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>array.forEach(callback(currentValue[, index[, array]]){ // do something }[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>thisArg</code></strong> : 执行回调函数时this对应的对象. 如果省略了 <code>thisArg</code> 参数, 或者赋值为 <code>null</code> 或 <code>undefined</code>, 则 this 指向全局对象.<br><strong><code>返回值</code></strong> :</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'obj'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0,<span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: undefined;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>array.map(callback(currentValue[, index[, array]]){ // do something }[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>thisArg</code></strong> : 执行回调函数时this对应的对象. 如果省略了 <code>thisArg</code> 参数, 或者赋值为 <code>null</code> 或 <code>undefined</code>, 则 this 指向全局对象.<br><strong><code>返回值</code></strong> : 由每个数组元素调用callback后的返回值组成的新数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'obj'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newVal = currentValue * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'newVal:'</span>, newVal, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newVal;</span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 4 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 2 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: [ 6, 4, 2 ]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-every"><a href="#Array-prototype-every" class="headerlink" title="Array.prototype.every()"></a>Array.prototype.every()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>array.every(callback(currentValue[, index[, array]]){ // do something }[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>thisArg</code></strong> : 执行回调函数时this对应的对象. 如果省略了 <code>thisArg</code> 参数, 或者赋值为 <code>null</code> 或 <code>undefined</code>, 则 this 指向全局对象.<br><strong><code>返回值</code></strong> : 布尔值. 由数组中每个元素调用callback后, 当所有的元素都符合条件(真值)才返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 true.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newVal = currentValue * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'newVal:'</span>, newVal, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newVal &gt; <span class="number">2</span>;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newVal = currentValue * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'newVal:'</span>, newVal, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newVal &gt; <span class="number">6</span>;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: false;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a>Array.prototype.some()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>array.some(callback(currentValue[, index[, array]]){ // do something }[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>返回值</code></strong> : 布尔值. 由数组中每个元素调用callback后, 当有元素符合条件(真值)就返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 false.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newVal = currentValue * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'newVal:'</span>, newVal, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newVal &gt; <span class="number">6</span>;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newVal = currentValue * <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'newVal:'</span>, newVal, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> newVal &gt; <span class="number">9</span>;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: false;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.filter(callback(currentValue[, index[, array]])[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>返回值</code></strong> : 数组中每个元素调用callback后, 由符合条件的数组元素组成的新数组.如果没有符合条件的元素, 则返回空数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boolean = currentValue &gt; <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> boolean;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"><span class="comment">//arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: [ 3, 2 ];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.find(callback(currentValue[, index[, array]])[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>返回值</code></strong> : 数组中每个元素调用callback后, 返回第一个符合条件的元素. 否则返回 undefined.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.find(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boolean = currentValue &gt; <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> boolean;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: 3;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-findIndex"><a href="#Array-prototype-findIndex" class="headerlink" title="Array.prototype.findIndex()"></a>Array.prototype.findIndex()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.findIndex(callback(currentValue[, index[, array]])[, thisArg])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>currentValue</code> : 数组中正在被处理的当前元素.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>返回值</code></strong> : 数组中每个元素调用callback后, 返回第一个符合条件的元素索引. 否则返回 -1.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boolean = currentValue &gt; <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array, <span class="string">'thisArg:'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> boolean;</span><br><span class="line">&#125;, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: 0;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.reduce(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])</code></em></p></blockquote><p><strong><code>callback</code></strong> : 数组中每个元素都会执行的回调函数.</p><blockquote><p><code>accumulator</code> : 上一个元素调用回调函数后的返回值. 回调函数第一次执行时, 若提供了initialValue,则accumulator取值为initialValue. 若没有提供initialValue, 则accumulator取值为数组中第一个元素.<br><code>currentValue</code> : 数组中正在被处理的当前元素. 回调函数第一次执行时, 若提供了initialValue, 则currentValue取值为数组中第一个元素. 若没有提供initialValue, 则currentValue取值为数组中第二值.<br><code>index</code> : 数组中正在被处理的当前元素的索引.<br><code>array</code> : 调用该方法的数组.</p></blockquote><p><strong><code>返回值</code></strong> : 数组中每个元素调用callback后, 将上一次回调函数执行结果作为下一次回调函数参数, 并最终返回单个结果值.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0'</span>, arr0, <span class="string">'accumulator:'</span>, accumulator, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array);</span><br><span class="line">    <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] accumulator: 0 currentValue: 3 index: 0 array: [ 3, 2, 1 ];</span></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];</span></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: 6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0'</span>, arr0, <span class="string">'accumulator:'</span>, accumulator, <span class="string">'currentValue:'</span>, currentValue, <span class="string">'index:'</span>, index, <span class="string">'array:'</span>, array);</span><br><span class="line">    <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];</span></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: 6;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">44</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">53</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">44</span>, <span class="number">53</span>, <span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'arr0'</span>, arr0, <span class="string">'accumulator'</span>, accumulator, <span class="string">'currentValue'</span>, currentValue);</span><br><span class="line">    <span class="keyword">if</span> (accumulator.length === <span class="number">0</span> || accumulator[accumulator.length - <span class="number">1</span>] !== currentValue) &#123;</span><br><span class="line">        accumulator.push(currentValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;<span class="keyword">return</span> a - b&#125;).reduce(reducer, []);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [] currentValue 1;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 1;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 2;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 3;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 5;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 5;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 44;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 44;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 53;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 53;</span></span><br><span class="line"><span class="comment">// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 55;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: [ 1, 2, 3, 5, 44, 53, 55 ];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-reduceRight"><a href="#Array-prototype-reduceRight" class="headerlink" title="Array.prototype.reduceRight()"></a>Array.prototype.reduceRight()</h4><p><strong>语法</strong>(<em>从右向左遍历,见<code>reduce</code></em>) :</p><blockquote><p><em><code>arr.reduceRight(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])</code></em></p></blockquote><h4 id="Array-prototype-entries"><a href="#Array-prototype-entries" class="headerlink" title="Array.prototype.entries()"></a>Array.prototype.entries()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.entries()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 一个新的包含数组中每个索引的键/值对的<code>Array Iterator</code>对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.entries();</span><br><span class="line"><span class="keyword">let</span> arr000 = arr00.next();</span><br><span class="line"><span class="keyword">let</span> arr0000 = arr000.value;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr000:'</span>, arr000);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0000:'</span>, arr0000);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00;</span></span><br><span class="line"><span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">// __proto__: Array Iterator</span></span><br><span class="line"><span class="comment">// next: ƒ next()</span></span><br><span class="line"><span class="comment">// Symbol(Symbol.toStringTag): "Array Iterator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr000;</span></span><br><span class="line"><span class="comment">// &#123;value: Array(2), done: false&#125;j;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0000;</span></span><br><span class="line"><span class="comment">// [0, 3];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.entries();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr00) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 0, 3 ];</span></span><br><span class="line"><span class="comment">// [ 1, 2 ];</span></span><br><span class="line"><span class="comment">// [ 2, 1 ];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = [...arr0.entries()];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: [ [ 0, 3 ], [ 1, 2 ], [ 2, 1 ] ]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-keys"><a href="#Array-prototype-keys" class="headerlink" title="Array.prototype.keys()"></a>Array.prototype.keys()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.keys()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 一个新的包含数组中每个索引键的<code>Array Iterator</code>对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.keys();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr00) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = [...arr0.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr00: [ 0, 1, 2 ];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-values"><a href="#Array-prototype-values" class="headerlink" title="Array.prototype.values()"></a>Array.prototype.values()</h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr.values()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 一个新的包含数组每个索引对应值的 <code>Array Iterator</code> 对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.keys();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr00) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = [...arr0.keys()];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr00:'</span>, arr00);</span><br><span class="line"><span class="comment">// arr00: [ 0, 1, 2 ];</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-iterator"><a href="#Array-prototype-iterator" class="headerlink" title="Array.prototype[@@iterator]()"></a>Array.<code>prototype[@@iterator]()</code></h4><p><strong>语法</strong> :</p><blockquote><p><em><code>arr[Symbol.iterator]()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 数组的 iterator 方法，默认情况下与 values() 返回值相同.</p><hr>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>迭代方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Array原型之非变异方法</title>
    <url>/Array%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%9D%9E%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p><strong>Array</strong>对象是用于构造数组的全局对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组对象是一个<strong>有序</strong>的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.<br>数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过<code>[]</code>或<code>.</code>来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="string">'zero'</span>] = <span class="string">'zero'</span>;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">console</span>.log(item))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><hr><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h3><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><p><strong>描述</strong> :<br>浅拷贝数组指定区域的元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.slice(begin[, end])</code></em></p></blockquote><p><strong><code>begin(可选)</code></strong> : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 <code>this.length + start</code>.<br><strong><code>end</code></strong> : 终止索引, 默认值 this.length. 不包括end位置. 如果是负数时, 规则如上.<br><strong><code>返回值</code></strong> : 返回截取的新数组(浅复制).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.slice();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] arr00: [ 3, 2, 1 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr11 = arr1.slice(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr1:'</span>, arr1, <span class="string">'arr11:'</span>, arr11);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr1: [ 5, 4, 3, 2, 1 ] arr11: [ 3 ].</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><p><strong>描述</strong> :<br>合并多个值或数组.<br><strong>语法</strong> :</p><blockquote><p><em><code>array.concat(element0[, element1[, ...[, elementN]]])</code></em></p></blockquote><p><strong><code>elementN</code></strong> : 将要连接的值或数组.<br><strong><code>返回值</code></strong> : 多个值或数组合并后的新数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr = arr0.concat(arr1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr1:'</span>, arr1, <span class="string">'arr:'</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 6, 5, 4 ] arr1: [ 3, 2, 1 ] arr: [ 6, 5, 4, 3, 2, 1 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr = arr2.concat(<span class="number">3</span>, arr3);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr2: '</span>, arr2, <span class="string">'arr3: '</span>, arr3, <span class="string">'arr'</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr2:  [ 6, 5, 4 ] arr3:  [ 2, 1 ] arr [ 6, 5, 4, 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-join"><a href="#Array-prototype-join" class="headerlink" title="Array.prototype.join()"></a>Array.prototype.join()</h4><p><strong>描述</strong> :<br>将数组众元素用指定字符连接成字符串.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.join(connector)</code></em></p></blockquote><p><strong><code>connector</code></strong> : 指定一个字符链接数组中的每个元素, 默认逗号连接.<br><strong><code>返回值</code></strong> : 用指定连接符将数组中元素连接起来的字符串.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = arr0.join();</span><br><span class="line"><span class="keyword">let</span> str2 = arr0.join(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">let</span> str3 = arr0.join(<span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'str1:'</span>, str1, <span class="string">'str2:'</span>, str2, <span class="string">'str3:'</span>, str3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] str1: 3,2,1 str2: 321 str3: 3-2-1;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-toString"><a href="#Array-prototype-toString" class="headerlink" title="Array.prototype.toString()"></a>Array.prototype.toString()</h4><p><strong>描述</strong> :<br>用字符串形式表示数组元素.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.toString()</code></em></p></blockquote><p><strong><code>返回值</code></strong> : 逗号连接数组元素组成的字符串. 当数组元素为数组时, 自动调用其toString()方法.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> arr00 = arr0.toString();</span><br><span class="line"><span class="keyword">let</span> arr1 = [[<span class="number">6</span>, [<span class="number">5</span>, <span class="number">4</span>]], <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'arr00:'</span>, arr00, <span class="string">'arr1:'</span>, arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] arr00: 3,2,1 arr1: 6,5,4,3,2,1;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h4><p><strong>描述</strong> :<br>判断数组中是否指定值.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.includes(searchElement[, fromIndex])</code></em></p></blockquote><p><strong><code>searchElement</code></strong> : 需要查询的值.<br><strong><code>fromIndex</code></strong> : 起始索引, 默认值为0. 如果是负数时, 规则如上.<br><strong><code>返回值</code></strong> : 布尔值.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> a = arr0.includes(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> b = arr0.includes(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0'</span>, arr0, <span class="string">'a:'</span>, a, <span class="string">'b:'</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0 [ 3, 2, 1 ] a: true b: false;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a>Array.prototype.indexOf()</h4><p><strong>描述</strong> :<br>查询指定元素在数组中首次出现的索引位置.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.indexOf(searchElement[, fromIndex])</code></em></p></blockquote><p><strong><code>searchElement</code></strong> : 需要查询的值.<br><strong><code>fromIndex</code></strong> : 起始索引, 默认值为0. 如果是负数时, 规则如上.<br><strong><code>返回值</code></strong> : 首次被找到的元素在数组中的索引位置; 若没有找到则返回 <code>-1</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> a = arr0.indexOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> b = arr0.indexOf(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'a:'</span>, a, <span class="string">'b:'</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] a: 2 b: -1;</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-lastIndexOf"><a href="#Array-prototype-lastIndexOf" class="headerlink" title="Array.prototype.lastIndexOf()"></a>Array.prototype.lastIndexOf()</h4><p><strong>描述</strong> :<br>从数组的后面向前查找, 查询指定元素在数组中首次出现的索引位置.<br><strong>语法</strong> :</p><blockquote><p><em><code>arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])</code></em></p></blockquote><p><strong><code>searchElement</code></strong> : 需要查询的值.<br><strong><code>fromIndex</code></strong> : 逆向查找起始索引, 默认值 <code>this.length - 1</code>.<br><strong><code>返回值</code></strong> : 逆向首次被找到的元素在数组中的索引位置.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr0 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> a = arr0.lastIndexOf(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> b = arr0.lastIndexOf(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr0:'</span>, arr0, <span class="string">'a:'</span>, a, <span class="string">'b:'</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr0: [ 3, 2, 1 ] a: 2 b: 0;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>非变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Function原型方法</title>
    <url>/Function%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p><strong><em>Function</em></strong> 作为构造函数用来创建一个新的 <strong><em>Function</em></strong> 对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>详见<a href="http://www.yexiaochen.com/%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"><strong><em>从Function入手原型链</em></strong></a>. <strong><em>Function</em></strong> 用来创建函数对象, 而 <strong><em>Function</em></strong> 本身也是函数, 所以有一个让很多人困扰的地方.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>) === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p><strong>描述</strong> :<br>返回一个表示当前函数源代码的字符串.<br><strong>语法</strong> :</p><blockquote><p><em><code>function.toString()</code></em></p></blockquote><p>在内置函数或由 <strong><em>Function.prototype.bind</em></strong> 返回的函数上调用该方法, 则有:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.toString()</span><br><span class="line"><span class="comment">// "function String() &#123; [native code] &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.toString()</span><br><span class="line"><span class="comment">// "function Number() &#123; [native code] &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.bind(<span class="literal">null</span>).toString()</span><br><span class="line"><span class="comment">// "function () &#123; [native code] &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.bind(<span class="literal">null</span>).toString()</span><br><span class="line"><span class="comment">// "function () &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure><p>普通函数调用该方法, 则有:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).toString()</span><br><span class="line"><span class="comment">// "function() &#123;&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man</span>(<span class="params">params</span>) </span>&#123;<span class="built_in">console</span>.log(params)&#125;</span><br><span class="line">man.toString()</span><br><span class="line"><span class="comment">// "function man(params) &#123;console.log(params)&#125;"</span></span><br></pre></td></tr></table></figure><p>非 <strong><em>Function</em></strong> 对象调用该方法, 会抛出 <strong><em>TypeError</em></strong>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.toString.call(&#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Function.prototype.toString requires that 'this' be a Function</span></span><br></pre></td></tr></table></figure><hr><h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p><strong>描述</strong> :<br>为调用的函数指定 <strong><em>this</em></strong> 值, 即 <strong><em>this</em></strong> 的执行上下文, 并以数组的形式传入参数.<br><strong>语法</strong> :</p><blockquote><p><em><code>function.apply(thisArg, argArray)</code></em></p></blockquote><p><strong><code>thisArg</code></strong> : 用于改变函数体内部 <strong><em>this</em></strong> 指向的 <strong><em>context</em></strong>. 当 <strong><em>argArray</em></strong> 为 <strong><em>undefined</em></strong> 或 <strong><em>null</em></strong> 时, <strong><em>thisArg</em></strong> 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.<br><strong><code>argArray</code></strong> : 数组或类数组对象. <strong><em>argArray</em></strong> 里的元素将逐个放入参数列表中. 若检测 <strong><em>argArray</em></strong> 不是对象, 将会抛出 <strong><em>TypeError</em></strong> 错误.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> man = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span>,</span><br><span class="line">    saySex() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> women = &#123;</span><br><span class="line">    age: <span class="number">16</span>,</span><br><span class="line">    sex: <span class="string">'women'</span></span><br><span class="line">&#125;</span><br><span class="line">man.saySex.apply(women)</span><br><span class="line"><span class="comment">// I am a women</span></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log_1</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line">log_1(<span class="number">1</span>);</span><br><span class="line">log_1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log_2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line">    log.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">log_2(<span class="number">1</span>);</span><br><span class="line">log_2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="string">'w'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">let</span> push = <span class="built_in">Array</span>.prototype.push;</span><br><span class="line">push.apply(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure><hr><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p><strong>描述</strong> :<br>为调用的函数指定 <strong><em>this</em></strong> 值, 即 <strong><em>this</em></strong> 的执行上下文, 并以列表的形式传入参数.<br><strong>语法</strong> :</p><blockquote><p><em><code>function.call(thisArg[ , arg1 [ , arg2, …, argN]])</code></em></p></blockquote><p><strong><code>thisArg</code></strong> : 用于改变函数体内部 <strong><em>this</em></strong> 指向的 <strong><em>context</em></strong>. 当 <strong><em>argArray</em></strong> 为 <strong><em>undefined</em></strong> 或 <strong><em>null</em></strong> 时, <strong><em>thisArg</em></strong> 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.<br><strong><code>argN</code></strong> : 入参将从左到右的顺序加入到参数列表中.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age);</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Adam = <span class="keyword">new</span> Man(<span class="string">'Adam'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Adam)</span><br><span class="line"><span class="comment">// Man &#123; name: 'Adam', age: 18, sex: 'man' &#125;</span></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>];</span><br><span class="line"><span class="keyword">let</span> push = <span class="built_in">Array</span>.prototype.push;</span><br><span class="line">push.call(a, <span class="string">'w'</span>,<span class="string">'o'</span>,<span class="string">'r'</span>,<span class="string">'l'</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure><hr><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p><strong>描述</strong> :<br>创建一个新的绑定函数, 为函数指定 <strong><em>this</em></strong> 值, 即 <strong><em>this</em></strong> 的执行上下文, 并以列表的形式传入参数.<br><strong>语法</strong> :</p><blockquote><p><em><code>function.bind(thisArg[ , arg1 [ , arg2, …, argN]])</code></em></p></blockquote><p><strong><code>thisArg</code></strong> : 调用绑定函数时作为this参数传递给目标函数的值.<br><strong><code>argN</code></strong> : 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    setTimeout((<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'i'</span>, i)</span><br><span class="line">    &#125;).bind(<span class="literal">null</span>, i), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类数组转数组</span></span><br><span class="line"><span class="keyword">let</span> argArray = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">let</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">let</span> boundSlice = <span class="built_in">Function</span>.prototype.call.bind(slice);</span><br><span class="line">boundSlice(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Function</tag>
        <tag>Function原型</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>DIP、IoC、DI、JS</title>
    <url>/DIP%E3%80%81IoC%E3%80%81DI%E3%80%81JS/</url>
    <content><![CDATA[<p>在这个标题中，除了 <strong>JS</strong> 是乱入之外，其它的几个词汇都是存在一个共同点的，那就是依赖。</p><blockquote><p>那么，依赖是什么呢？</p></blockquote><p>比如，现在我正在写这篇博客文，但是我得在电脑上编辑，电脑便是我完成这件事的依赖。而在代码中，最直观的体现是模块之间的依赖。如某个模块依赖另外一个模块，那么另外的那个模块就是该模块的依赖。其实在上篇博客文章《<a href="http://www.yexiaochen.com/JaVaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/">JaVaScript中的模块</a>》中，我们也手写了一个模块依赖管理器。</p><p>依赖这个理解起来很简单，但这不代表可以随意的依赖。在写模块的时候，讲究个高内聚低耦合，以提高模块的可拓展性和可维护性。模块依赖了谁，怎么去依赖，都关乎了最终模块的好与坏。</p><p>还好在编程界有着提高代码质量的金科玉律，我们可以用理论来指导实践，写出更好的代码。</p><h2 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h2><blockquote><p>依赖反转原则（Dependency inversion principle，DIP），是一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。———— 维基百科</p></blockquote><p>该原则规定：</p><ol><li>高层次的模块不应该依赖与低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol><p>现在用一个例子来解释一波。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ajax.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ajax</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Ajax;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Ajax <span class="keyword">from</span> <span class="string">'./Ajax'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.render()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = (<span class="keyword">new</span> Ajax()).get();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Main();</span><br></pre></td></tr></table></figure><p>刚开始的时候，我们基于 <strong>XMLHttpRequest</strong> 对象，封装了 Ajax 用于请求数据。后来 <strong>fetch</strong> 出来了，我们打算跟上时代的脚步，封装 <strong>fetch</strong> 以取代 <strong>Ajax</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fetch.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fetch</span> </span>&#123;</span><br><span class="line">  fetch() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Fetch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Fetch <span class="keyword">from</span> <span class="string">'./Fetch'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = (<span class="keyword">new</span> Fetch()).fetch();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Main();</span><br></pre></td></tr></table></figure><p>从以上可以看出来，整个替代过程很麻烦，我们需要找出封装请求模块（<strong>Ajax</strong>、<strong>Fetch</strong>）的所有引用，然后替换掉。又由于 <strong>Ajax</strong>、<strong>Fetch</strong> 的方法命名也是不同，所以也需要对应地做更改。</p><p>这就是传统的处理依赖关系的方式。在这里 <strong>Main</strong> 是高层次模块，<strong>Ajax</strong>、<strong>Fetch</strong> 是低层次模块。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块，这种依赖关系限制了高层次模块的复用性。</p><p>依赖反转原则则颠倒这种依赖关系，并以上面提到的两个规定作为指导思想。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  request()&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.constructor.name&#125;</span> 没有实现 request 方法！`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ajax</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  request()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Ajax;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="keyword">import</span> Service <span class="keyword">from</span> <span class="string">'./Service.js'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = (<span class="keyword">new</span> Service).request();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Main();</span><br></pre></td></tr></table></figure><p>在这里我们把共同依赖的 <strong>Service</strong> 作为抽象接口，它就是高层次模块与低层次模块需要共同遵守的契约。在高层次模块中，它会默认 <strong>Service</strong> 会有 <strong>request</strong> 方法用来请求数据。在低层次模块中，它会遵从 <strong>Service</strong> 复写应该存在的方法。这在《<a href="http://www.yexiaochen.com/%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">在JavaScript中尝试组合模式</a>》中，无论分支对象还是叶对象都实现 <code>expense()</code> 方法的道理差不多。</p><p>即使后来需要封装 <strong>axios</strong> 取代 <strong>fetch</strong>，我们也只需要在 <strong>Service.js</strong> 中修改即可。</p><p>再次回顾下传统的依赖关系。</p><blockquote><p>依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块。</p></blockquote><p>经过以上的折腾，我们充其量只是解决了高层次模块直接依赖低层次模块的问题。那么依赖关系创建于高层次模块的问题呢？</p><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>如果说依赖反转原则告诉我们该依赖谁，那么控制反转则告诉们谁应该来控制依赖。</p><p>像上面的 <strong>Main</strong> 模块，它依赖 <strong>Service</strong> 模块。为了获得 <strong>Service</strong> 实例的引用，<strong>Main</strong> 在内部靠自身 <code>new</code> 出了一个 <strong>Service</strong> 实例。这样明显地引用其它模块，无异加大了模块间的耦合。</p><blockquote><p>控制反转（Inversion of Control，IoC），通过控制反转，对象在被创建的时候，有一个控制系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。可以说，依赖被注入到对象中。———— 维基百科</p></blockquote><p>这些话的意思就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现。实现控制反转最常见的方式是依赖注入，还有一种方式依赖查找。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><blockquote><p>依赖注入（Dependency Injection，DI），在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端）。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务将会变成客户端的状态的一部分。传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。</p></blockquote><p>没看懂？没关系。这句话讲的是，把过程放在外面，将结果带入内部。在《<a href="http://www.yexiaochen.com/JaVaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/">JaVaScript中的模块</a>》中，我们已经用到过依赖注入，就是<code>对于依赖模块的模块，则把依赖作为参数使用</code>。</p><p>所以我们再次改造下，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Service.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  request() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.constructor.name&#125;</span> 没有实现 request 方法！`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ajax</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  request() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Ajax;</span><br><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.Service = options.Service;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">this</span>.Service.request();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Service <span class="keyword">from</span> <span class="string">'./Service.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">'./Main.js'</span>;</span><br><span class="line"><span class="keyword">new</span> Main(&#123;</span><br><span class="line">  Service: <span class="keyword">new</span> Service()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <strong>Main</strong> 模块中, <strong>Service</strong> 的实例化是在外部完成，并在 <code>index.js</code> 中注入。相比上一次，改动后的代码并没有看出带来多大的好处。如果我们再增加一个模块呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Router::init'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Router;</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"># Main.js</span><br><span class="line"><span class="addition">+   this.Service = options.Router;</span></span><br><span class="line"></span><br><span class="line"># index.js</span><br><span class="line"><span class="addition">+   import Router from './Router.js'</span></span><br><span class="line">    new Main(&#123;</span><br><span class="line"><span class="addition">+        Router: new Service()</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>若是内部实例化就不好处理了。可换成依赖注入后，这个问题就很好解决了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toOptions = <span class="function"><span class="params">params</span> =&gt;</span></span><br><span class="line">  <span class="built_in">Object</span>.entries(params).reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">    accumulator[currentValue[<span class="number">0</span>]] = <span class="keyword">new</span> currentValue[<span class="number">1</span>]()</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, options);</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">this</span>.Service.request();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Service <span class="keyword">from</span> <span class="string">'./Service.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./Router.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">'./Main.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; toOptions &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toOptions 转换成参数形式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params <span class="type">&#123;Object&#125;</span> </span>类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span> <span class="type">&#123;Service: Service实例, Router: Router实例&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> options = toOptions(&#123;Service, Router&#125;);</span><br><span class="line"><span class="keyword">new</span> Main(options);</span><br></pre></td></tr></table></figure><p>因为依赖注入把依赖的引用从外部引入，所以这里使用 <code>Object.assign(this, options)</code> 方式，把依赖全部加到了 <strong>this</strong> 上。即使再增加模块，也只需要在 <code>index.js</code> 中引入即可。</p><p>到了这里，<strong>DIP</strong>、<strong>IoC</strong>、<strong>DI</strong> 的概念应该有个清晰的认识了。然后我们再结合实际，加个功能再次巩固一下。作为一功能个独立的模块，一般都有个初始化的过程。</p><p>现在我们要做的是遵守一个初始化的约定，定义一个抽象接口，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Interface.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  request() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.constructor.name&#125;</span> 没有实现 request 方法！`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.constructor.name&#125;</span> 没有实现 init 方法！`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Service.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Init, Service &#125; <span class="keyword">from</span> <span class="string">'./Interface.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mix &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ajax</span> <span class="keyword">extends</span> <span class="title">mix</span>(<span class="title">Init</span>, <span class="title">Service</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Service::init'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  request() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Ajax;</span><br></pre></td></tr></table></figure><p><strong>Main</strong>、<strong>Service</strong>、<strong>Router</strong> 都依赖 <strong>Init</strong> 接口（在这里就是一种协定），<strong>Service</strong> 模块比较特殊，所以做了 <strong>Mixin</strong> 处理。要做到统一初始化，<strong>Main</strong> 还需要做些事。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Init &#125; <span class="keyword">from</span> <span class="string">'./Interface.js'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Init</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, options);</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">    <span class="keyword">this</span>.render();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    (<span class="built_in">Object</span>.values(<span class="keyword">this</span>.options)).map(<span class="function"><span class="params">item</span> =&gt;</span> item.init());</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Main::init'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">this</span>.Service.request();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'content from'</span>, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Main;</span><br></pre></td></tr></table></figure><p>至此，结束</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> Service <span class="keyword">from</span> <span class="string">'./Service.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'./Router.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">'./Main.js'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; toOptions &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toOptions</span></span><br><span class="line"><span class="comment"> * 转换成参数形式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params <span class="type">&#123;Object&#125;</span> </span>类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Object&#125;</span></span></span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *    Service: Service实例,</span></span><br><span class="line"><span class="comment"> *    Router: Router实例</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> options = toOptions(&#123; Service, Router &#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Main(options)).init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  content from Ajax</span></span><br><span class="line"><span class="comment">//  Service::init</span></span><br><span class="line"><span class="comment">//  Router::init</span></span><br><span class="line"><span class="comment">//  Main::init</span></span><br></pre></td></tr></table></figure><p>（以上所有示例可见<a href="https://github.com/yexiaochen/DIP" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>）</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>DIP</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo+Next博客搭建之Hexo,Next及部署</title>
    <url>/Github-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BHexo-Next%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote><p>博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的</p></blockquote><p><em>现在回头看博客的搭建过程,可以总结归纳以下几点. <strong>markdown</strong>,<strong>git和GitHub</strong>,<strong>github和coding部署</strong>, <strong>Hexo和Next了解</strong>, <strong>SEO</strong>等</em></p><p><strong>Hexo,Next,部署,SEO</strong><br>该博客的搭建用的是<a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>博客框架,详细的说明官方文档都有提到.在主题的选择上用的是<a href="http://theme-next.iissnan.com" rel="external nofollow noopener noreferrer" target="_blank">Next</a>,对应的也有相关的官方文档.接下来就搭建过程中遇到的简单介绍一下</p><h2 id="Hexo中基本指令"><a href="#Hexo中基本指令" class="headerlink" title="Hexo中基本指令"></a>Hexo中基本指令</h2><pre><code>npm install -g hexo-cli     // npm安装Hexo, 非Hexo中命令

hexo init &lt;folder&gt;      // 指定文件夹下初始化Hexo,若没有设置folder, Hexo默认在目前的文件夹建立网站

cd &lt;folder&gt;     // 进入指定文件夹, 非Hexo中命令

npm install     // 安装配置文件packge.json中的依赖, 非Hexo中命令

hexo new [layout] &lt;title&gt;       // 新建一篇文章.layout默认default_layout参数,标题有空格,需使用引号括起来

hexo generate       // 生成静态文件. -d, --deploy 文件生成后立即部署网站.可简写为 hexo g

hexo server     // 启动服务器.默认情况下网址为:http://loalhost:4000/. -p, --port 重设端口

hexo deploy     // 部署网站. -g, --generate 部署之前预先生成静态文件.可简写为 hexo d

hexo clean      // 清除缓存文件和已生成的静态文件
</code></pre><h2 id="Hexo部署地址配置"><a href="#Hexo部署地址配置" class="headerlink" title="Hexo部署地址配置"></a>Hexo部署地址配置</h2><p>打开站点配置文件_config.yml,找到<code>deploy</code>字段,配置如下</p><pre><code>deploy:
- type: git // 以下是我的git地址
   repo: git@github.com:yexiaochen/yexiaochen.github.io.git
   branch: master
- type: git // 以下是我的coding地址
   repo: git@git.coding.net:yexiaochen/yexiaochen.coding.me.git
   branch: master
</code></pre><h2 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h2><p>定位到Hexo站点目录下,执行一下命令即可</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>克隆完成后,打开站点配置文件_config.yml,找到<code>theme</code>字段,并将其值更改为next</p><h2 id="设置菜单页面"><a href="#设置菜单页面" class="headerlink" title="设置菜单页面"></a>设置菜单页面</h2><p>Next主题有默认的菜单项,部分菜单项需要自己添加.<a href="http://theme-next.iissnan.com/theme-settings.html" rel="external nofollow noopener noreferrer" target="_blank">添加菜单项页面</a></p><p>新建标签页面</p><ol><li><p>在根目录下新建标签页面</p><pre><code>hexo new page tags
</code></pre></li><li><p>在新建的页面编辑一下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title:  All tags</span><br><span class="line">date: 2018-03-24 18:02:30</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件_config.yml内, 找到<code>menu</code>字段,添加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: / || home</span><br><span class="line"># about: /about/ || user</span><br><span class="line">tags: /tags/ || tags</span><br><span class="line">categories: /categories/ || th</span><br><span class="line">archives: /archives/ || archive</span><br><span class="line"># schedule: /schedule/ || calendar</span><br><span class="line"># sitemap: /sitemap.xml || sitemap</span><br><span class="line"># commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></li></ol><p>在菜单项里添加分类项操作同上</p><h2 id="添加gitment评论-添加gitalk评论"><a href="#添加gitment评论-添加gitalk评论" class="headerlink" title="添加gitment评论 添加gitalk评论"></a><del>添加gitment评论</del> 添加<a href="https://github.com/gitalk/gitalk" rel="external nofollow noopener noreferrer" target="_blank">gitalk</a>评论</h2><ol><li><p>远程仓库新建一个repository,名字随意,待会儿会用到<br><img src="../images/newRepository.png" alt="新建repository"></p></li><li><p>添加OAuth Apps.登陆GitHub,通过Settings =&gt; Developer settings =&gt; OAuth Apps,点击New OAuth App.添加后会生成Client ID和Client Secret<br><img src="../images/OAuth.png" alt="OAuth"></p></li><li><p>gitalk和gitment是差不多的产品, 在我们更换评论系统时, 可以在其基础上修改. 在主题配置文件_config.yml内, 找到<code>gitment</code>字段,添加如下内容.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitment:</span><br><span class="line">    enable: true</span><br><span class="line">    mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">    count: true # Show comments count in post meta area</span><br><span class="line">    lazy: true # Comments lazy loading with a button</span><br><span class="line">    cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more</span><br><span class="line">    language: # Force language, or auto switch by theme</span><br><span class="line">    github_user: yexiaochen # MUST HAVE, Your Github ID 18507780</span><br><span class="line">    github_repo: blog-gitment # MUST HAVE, The repo you use to store Gitment comments</span><br><span class="line">    client_id: your_client_id # MUST HAVE, Github client id for the Gitment</span><br><span class="line">    client_secret: your_client_secret # EITHER this or proxy_gateway, Github access secret token for the Gitment</span><br><span class="line">    proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">    redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure></li><li><p>在<code>themes/next/layout/_third-party/comments/gitment.swig</code>文件中, 按照gitalk文档里的配置进行修改.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line">clientID: <span class="string">'GitHub Application Client ID'</span>,</span><br><span class="line">clientSecret: <span class="string">'GitHub Application Client Secret'</span>,</span><br><span class="line">repo: <span class="string">'GitHub repo'</span>,</span><br><span class="line">owner: <span class="string">'GitHub repo owner'</span>,</span><br><span class="line">admin: [<span class="string">'GitHub repo owner and collaborators, only these guys can initialize github issues'</span>],</span><br><span class="line">id: location.pathname,      <span class="comment">// Ensure uniqueness and length less than 50</span></span><br><span class="line">distractionFreeMode: <span class="literal">false</span>  <span class="comment">// Facebook-like distraction free mode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>注意:</code> <strong>gitalk 需要GitHub账号登陆才可以创建初始化.</strong></p></li></ol><h2 id="部署coding"><a href="#部署coding" class="headerlink" title="部署coding"></a>部署coding</h2><p>部署到coding和部署到GitHub类似,也是要添加SSH的.新建的项目名称也是要求按照一定的规范来,细节可参考<a href="https://coding.net/help/doc/pages/creating-pages.html" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a>.在Pages服务的设置可参考下图<br><img src="../images/coding.png" alt="coding"></p><h2 id="DNS解析设置"><a href="#DNS解析设置" class="headerlink" title="DNS解析设置"></a>DNS解析设置</h2><p>购买域名后,要对其进行解析设置.因为国外墙的原因,故博客在部署时也选在了不同的平台上.不同的解析路线对应不同的项目URL<br><img src="../images/DNS.png" alt="DNS"></p><p>博客的搭建到此就结束了,其中还是有许多细节没有提到,时间久了已经忘了大部分了</p>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>coding</tag>
        <tag>部署</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo+Next博客搭建之Markdown</title>
    <url>/Github-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BMarkdown/</url>
    <content><![CDATA[<blockquote><p>博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.</p></blockquote><p><em>现在回头看博客的搭建过程,可以总结归纳以下几点. <strong>markdown</strong>,<strong>git和GitHub</strong>, <strong>github和coding部署</strong>, <strong>Hexo和Next了解</strong>, <strong>SEO</strong>等</em></p><p><strong>Markdown</strong><br><em>工欲善其事,必先利其器.作为程序员,平时的编辑语言首选是markdown,markdown的使用其实很简单.之前除了整理一下文档外,平时倒是用的不多,在此整理一下</em></p><h2 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h2><p>一个Markdown段落前后要有一个以上空行,普通段落不该用空行或制表符来缩进.段落内强迫换行可在插入处键入两个以上空格然后回车.</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>markdown支持两种标题,类Setext和Atx形式.<br>类Atx形式是在行首插入1到6个#,分别对应1到6级标题,示例:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure><p></p><h2 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h2><p>Markdown中建立区块引用,需在行首最前面加上<code>&gt;</code>:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 这是一个区块引用</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><blockquote><p>这是一个区块引用</p></blockquote><p>区块引用可以嵌套,只要根据层次加上不同数量的<code>&gt;</code>:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 这是顶层的</span><br><span class="line">&gt;&gt; 这是二级引用</span><br><span class="line">&gt;&gt;&gt; 这是三级引用</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><blockquote><p>这是顶层的</p><blockquote><p>这是二级引用</p><blockquote><p>这是三级引用</p></blockquote></blockquote></blockquote><p>引用区块内可以使用其他Markdown语法,包括标题、列表、代码区块等:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 列表</span><br><span class="line">&gt; 1. item1</span><br><span class="line">&gt; 2. item2</span><br><span class="line">&gt;</span><br><span class="line">&gt; 代码区块</span><br><span class="line">&gt;</span><br><span class="line">&gt;    这是一个代码区块</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><blockquote><p>列表</p><ol><li>item1</li><li>item2</li></ol><p>代码区块</p><p>这是一个代码区块</p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown支持有序列表和无序列表.列表项目标记通常放在最左边,也可以缩进,最多<code>3</code>个空格,<strong><code>项目标记后面一定要接着至少一个空格或制表符</code></strong>.</p><p><strong>列表项目可以包含多个段落</strong>,每个项目下的段落都必须缩进四个空格或是一个制表符:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 这是第一段落</span><br><span class="line">(空行)</span><br><span class="line">(四个空格一个制表符)这是第二段落</span><br><span class="line">或</span><br><span class="line">* 这是第一段落(两个空格)</span><br><span class="line">(四个空格一个制表符)这是第二段落</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><ul><li><p>这是第一段落.</p><p>这是第二段落</p></li><li><p>这是第一段落<br>这是第二段落</p></li></ul><p><strong>列表项目内放进引用</strong>,引用需缩进四个空格或一个制表符:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 列表项目内放进引用</span><br><span class="line">(四个空格或一个制表符)&gt; 这是引用一</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><ul><li>列表项目内放进引用<blockquote><p>这是引用一</p></blockquote></li></ul><p><strong>列表项目内放进代码区块</strong>,该区块需缩进两次,八个空格或两个制表符:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 列表项目内放进代码区块</span><br><span class="line">(空行)</span><br><span class="line">(八个空格或两个制表符)这是一个代码区块</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><ul><li><p>列表项目内放进代码区块</p><pre><code>这是一个代码区块
</code></pre></li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用星号(<code>*</code>)、加号(<code>+</code>)、减号(<code>-</code>)作为列表标记:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* item    + item    - item</span><br><span class="line">* item    + item    - item</span><br><span class="line">* item    + item    - item</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><ul><li>item</li><li>item</li><li>item</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则是数字接着英文句点( 数字 + . ):<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. item</span><br><span class="line">2. item</span><br><span class="line">3. item</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><ol><li>item1</li><li>item2</li><li>item3</li></ol><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>Markdown中建立代码区块,需缩进四个空格或一个制表符:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个普通段落:</span><br><span class="line">(空行)</span><br><span class="line">(八个空格或两个制表符)这是一个代码区块</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:<br>这是一个普通段落:</p><pre><code>这是一个代码区块
</code></pre><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>Markdown中的分隔线需三个以上的星号(<code>*</code>)、减号(<code>-</code>)、底线(<code>_</code>).也可以在星号或减号或底线中间插入空格,不影响效果.<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****</span><br><span class="line">-----</span><br><span class="line">_______</span><br><span class="line">**** *****    **********</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><hr><hr><hr><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>Markdown支持两种形式的链接语法: 行内式和参考式.链接文字都是用<code>[]</code>标记.</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>行内式链接:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个行内式链接[链接文字](链接URL &quot;链接标题&quot;)</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:<br>这是一个行内式链接<a href="链接URL" title="链接标题">链接文字</a></p><h3 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考式链接:</span><br><span class="line">这是一个参考式链接[链接文字][链接辨别标签]</span><br><span class="line">(空行)</span><br><span class="line">[链接辨别标签]: 链接URL &quot;链接标题&quot;</span><br></pre></td></tr></table></figure><p><span style="color:#38aeab">效果展示</span>:<br>这是一个参考式链接<a href="链接URL" title="链接标题">链接文字</a></p><p>链接内容定义形式:</p><ul><li>方括号(前面可以选择性加上至多三个空格缩进),里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址, 可以用尖括号包起来</li><li>选择性接着title内容,可以是单引号、双引号或括号,可以放到下一行,也可以加一些缩进</li></ul><p>链接辨别标签不区分大小写.</p><h3 id="隐式链接标记"><a href="#隐式链接标记" class="headerlink" title="隐式链接标记"></a>隐式链接标记</h3><p>隐式链接标记可以省略制定链接标记,此时链接标记等同于链接文字:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个隐式链接标记功能[隐式链接][]</span><br><span class="line"></span><br><span class="line">[隐式链接]: 链接URL &quot;隐式链接标题&quot;</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:<br>这是一个隐式链接标记功能<a href="链接URL" title="隐式链接标题">隐式链接</a></p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>Markdown中标记强调字词需使用星号(<code>*</code>)或底线(<code>_</code>),被单个<code>*</code>或<code>_</code>包围的字词会被<code>&lt;em&gt;</code>标签包围,用两个<code>*</code>或<code>_</code>包起来,则会被转成<code>&lt;strong&gt;</code>,示例:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*强调*</span><br><span class="line">**强调**</span><br><span class="line">__强调__</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><p><em>强调</em><br><strong>强调</strong><br><strong>强调</strong></p><p>如果<code>*</code>或<code>_</code>两边都有空白,它们就只会被当成普通的符号.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Markdown标记一小段行内代码,需用反引号包起来(<code>`</code>),<span style="text-decoration:line-through">支持<a href="https://highlightjs.org/static/demo/" rel="external nofollow noopener noreferrer" target="_blank">语法高亮</a>,包括:Apache, Bash, CoffeeScript, C++, C#, CSS, HTTP, Java, JavaScript, JSON, Markdown, Nginx, Objective-C, Perl, PHP, Properties, Python, Ruby, Shell Session, SQL, HTML, XML等</span>.示例:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个`行内代码标记`</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><p>这是一个<code>行内代码标记</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown中插入图片,有两种样式: 行内式和参考式.</p><h3 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片替代文字](图片链接URL &quot;图片描述&quot;)</span><br></pre></td></tr></table></figure><ul><li>一个感叹号!</li><li>接着方括号[],里面是图片的替代文字</li><li>接着括号,里面是图片的URL,最后还可以选择性加上文字描述.</li></ul><h3 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片替代文字][图片参考标记]</span><br><span class="line">[图片参考标记]: 图片链接URL &quot;图片描述&quot;</span><br></pre></td></tr></table></figure><p>如果需对图片进行宽高,位置调整,可以使用普通的<code>&lt;img&gt;</code>标签</p><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>Markdown支持比较短的自动链接形式来处理网址和电子信箱,需用尖括号<code>&lt;&gt;</code><br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;网址的URL&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown中支持表格,<code>:</code>代表对其方式,<code>:</code>和<code>|</code>之间不能有空格,否则对其会有不兼容.示例:<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(空格)</span><br><span class="line">|左侧|中间|右侧|</span><br><span class="line">|:---:|:---:|:---:|</span><br><span class="line">|描述一|描述二|描述三|</span><br><span class="line">或</span><br><span class="line">(空格)</span><br><span class="line">左侧|中间|右侧</span><br><span class="line">:---:|:---:|:---:</span><br><span class="line">描述一|描述二|描述三</span><br></pre></td></tr></table></figure><p></p><p><span style="color:#38aeab">效果展示</span>:</p><table><thead><tr><th style="text-align:center">左侧</th><th style="text-align:center">中间</th><th style="text-align:center">右侧</th></tr></thead><tbody><tr><td style="text-align:center">描述一</td><td style="text-align:center">描述二</td><td style="text-align:center">描述三</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Markdown的简单应用到这也差不多写完了,当然还有好多的高级技巧可以自行百度或Google.语法本来就很简单,虽不说十分钟包教包会,但是只要尝试着在键盘上敲两下,看看效果,学会它还是挺容易的.</p>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客升级为PWA</title>
    <url>/Hexo%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7%E4%B8%BAPWA/</url>
    <content><![CDATA[<blockquote><p>渐进式网络应用程序（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程序，但它可以以传统应用程序或原生移动应用程序形式展示给用户。这种应用程序形态视图将目前最为现代化的浏览器提供的功能与移动设备的体验优势相结合。———— 维基百科</p></blockquote><p>PWA 诞生已久，被赋予了 Web 应用和原生应用的特性，具备渐进式、可搜索、可离线、可安装、可链接、安全等优势。PWA 不是一种技术，而是一系列关键技术构成了 PWA。如，Web APP Manifest，Service Worker，Push Notification等。（本文不讨论 Push Notification）</p><p>让一个传统的网页升级为 PWA ，是一件很容易的事。现以本博客为例，将其打造为 PWA。（本博客没过 <code>https</code> 这关， 😅😅😅）</p><h2 id="步骤一：Web-APP-Manifest"><a href="#步骤一：Web-APP-Manifest" class="headerlink" title="步骤一：Web APP Manifest"></a>步骤一：Web APP Manifest</h2><p>Web APP Manifest ，在 JSON 文本中提供应用程序相关的信息。包括自定义名称，自定义图标设置启动网址等。manifest 的目的是将 Web 应用程序安装到设备的主屏幕。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"夜曉宸"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"夜曉宸"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [&#123;</span><br><span class="line">    <span class="attr">"src"</span>: <span class="string">"/images/favicon-96.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"96x96"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">    <span class="attr">"src"</span>: <span class="string">"/images/favicon-128.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"128x128"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/images/favicon-144.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"144x144"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/images/favicon-152.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"152x152"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/images/favicon-192.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"192x192"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/images/favicon-256.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"256x256"</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"/images/favicon-512.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"512x512"</span></span><br><span class="line">    &#125;],</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"fullscreen"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#f5f5f5"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#f5f5f5"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好 manifest.json 文件后，需要在 HTML 头部引入。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="步骤二：Service-Worker"><a href="#步骤二：Service-Worker" class="headerlink" title="步骤二：Service Worker"></a>步骤二：Service Worker</h2><p>Service Worker 是 PWA 的核心技术，充当着浏览器和网络之间的代理，或应用程序与浏览器之间的代理服务器。旨在统筹资源缓存和对自定义网络请求进行控制。Service Worker 运行在一个与JavaScript 主线程独立的线程上，并且没有对 DOM 结构的任何反问权限。并且可以在不同的上下文之间发送和接收信息，可分配给 Service Worker 任务，并在使用基于 Promise 的方法当任务完成时接收结果。</p><p>service worker 有自己的生命周期，我们要做的是在不同的状态下对资源采用不同的策略（缓存，不缓存，优先缓存，优先网络等）。</p><center><br><br><img src="../images/sw-lifecycle.png" alt="sw生命周期"><br><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 安装之后完成触发；</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(<span class="comment">//  安装完成之前需要执行的代码；</span></span><br><span class="line">    caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;<span class="comment">// caches API;</span></span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">          <span class="comment">// 需要缓存的资源列表;</span></span><br><span class="line">          <span class="string">'/lib/jQuery.min.js'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>service worker 安装完成后，如果已存在旧版本正在使用，则不会激活，直到旧版本停用。如果旧版本的某些资源无需存在，可以在 activate 阶段将其删除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">'v2'</span>];</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;&#125;));</span><br><span class="line">    &#125;);</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然是充当代理，拦截请求就很重要了。对请求的资源如何控制将会在这里处理。</p><center><br><br><img src="../images/sw-fetch.png" alt="fetch"><br><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 匹配到资源，则返回；</span></span><br><span class="line"><span class="comment">// 没有匹配到资源，则从服务器请求资源，并缓存资源；</span></span><br><span class="line"><span class="comment">// 没有网络时，则返回默认的资源；</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(event.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> caches.open(<span class="string">'v1'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, response.clone());</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;);&#125;);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> caches.match(<span class="string">'/default.jpg'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>service worker 要做的事情基本就这些（都写在 sw.js 里了），接下来就是注册 service worker。</p><center><br><br><img src="../images/important-notes-register.png" alt="work注册"><br><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">        navigator.serviceWorker.register(<span class="string">'/sw-test/sw.js'</span>, &#123; <span class="attr">scope</span>: <span class="string">'/sw-test/'</span> &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// registration worked</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Registration succeeded. Scope is '</span> + reg.scope);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// registration failed</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Registration failed with '</span> + error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此基本完成了一个可安装、可离线的 Web APP。还记得步骤一的可安装么？安装提示一般会按照一定的规则弹出的，如果我们希望主动引导用户安装呢？</p><p>首先把 <code>beforeinstallprompt</code> 里的事件保存起来，在一个恰当的时机触发。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//app.js</span></span><br><span class="line"><span class="comment">// 把 event 存起來</span></span><br><span class="line"><span class="keyword">var</span> installPromptEvent;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeinstallprompt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  installPromptEvent = e</span><br><span class="line">  <span class="keyword">if</span> (installPromptEvent.prompt) &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#install'</span>).addEventListener(<span class="string">'click'</span>, addToHomeScreen);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToHomeScreen</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (installPromptEvent) &#123;</span><br><span class="line">        installPromptEvent.prompt()</span><br><span class="line">        installPromptEvent = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤三：检测你的-PWA"><a href="#步骤三：检测你的-PWA" class="headerlink" title="步骤三：检测你的 PWA"></a>步骤三：检测你的 PWA</h2><p>完成 PWA 的构建后，我们可以利用 Chrome 的开发者工具 <code>Audits</code> 工具检测，针对 PWA，会有相关的提示建议。</p><center><br><br><img src="../images/pwa-Audits.png" alt="PWA检测"><br><br></center><h2 id="workbox"><a href="#workbox" class="headerlink" title="workbox"></a>workbox</h2><p>在 PWA 中， service worker 是关键，而缓存策略又是重中之重。对于请求的资源是否缓存，又以怎样的形式返回。如果关照到广度和粒度，估计会很麻烦。Google 为开发者量身打造了 workbox。常见的缓存策略：CacheFirst，CacheOnly，NetworkFirst，NetworkOnly，StaleWhileRevalidate。</p><p>StaleWhileRevalidate</p><p><img src="../images/stale-while-revalidate.png" alt="StaleWhileRevalidate"></p><p>Cache First (Cache Falling Back to Network)<br><img src="../images/cache-first.png" alt="Cache First"></p><p>Network Only<br><img src="../images/network-only.png" alt="Network Only"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方示例（部分）</span></span><br><span class="line"><span class="comment">// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.</span></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  /^https:\/\/fonts\.googleapis\.com/,</span><br><span class="line">  <span class="keyword">new</span> workbox.strategies.StaleWhileRevalidate(&#123;</span><br><span class="line">    cacheName: <span class="string">'google-fonts-stylesheets'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  /\.(?:png|gif|jpg|jpeg|webp|svg)$/,</span><br><span class="line">  <span class="keyword">new</span> workbox.strategies.CacheFirst(&#123;</span><br><span class="line">    cacheName: <span class="string">'images'</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> workbox.expiration.Plugin(&#123;</span><br><span class="line">        maxEntries: <span class="number">60</span>,</span><br><span class="line">        maxAgeSeconds: <span class="number">30</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>, <span class="comment">// 30 Days</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>PWA</tag>
        <tag>渐进式网络应用程序</tag>
        <tag>workbox</tag>
      </tags>
  </entry>
  <entry>
    <title>JaVaScript中的模块</title>
    <url>/JaVaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在 <strong>JavaScript</strong> 中，模块只不过是基于函数某些特性的代码组织方式。</p><p>在《你不知道的 JavaScript》中，给出了模块模式因具备的两个必要条件：</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>从中我们可以看到一个比较重要的一点，从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块。</p><p>你看👀，理解闭包的重要性再次体现出来了。</p><p>从以上要求的两点来看，只要满足相应的条件，我们很容易写出一个模块。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userModule = <span class="function">(<span class="params">(name = <span class="string">'module'</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> id = <span class="number">1</span>,moduleName = name;</span><br><span class="line">  <span class="keyword">const</span> sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'moduleName: %s'</span>, moduleName);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> sayId = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id: %s'</span>, id);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      moduleName = value;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> changePublicAPI = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    publicAPI.sayIdentification = sayId</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> publicAPI = &#123;</span><br><span class="line">    sayIdentification: sayName,</span><br><span class="line">    changeName,</span><br><span class="line">    changePublicAPI,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> publicAPI;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上在满足两个必要的基础上转换成了 <strong>IIFE</strong>（立即执行函数表达式）。同时可以看出，基于函数的模块可以在运行时通过内部保留着公共 <strong>API</strong> 对象的引用，从而对模块实例进行修改。</p><h2 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a>模块机制</h2><p>模块的出现也是为了能够提高代码的复用率，方便代码管理。复用模块，自然会出现模块依赖的问题，所以说我们需要一个管理模块依赖的模块。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleManage = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> modules = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> define = <span class="function">(<span class="params">name, deps, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    deps = deps.map(<span class="function"><span class="params">item</span> =&gt;</span> modules[item])</span><br><span class="line">    modules[name] = <span class="built_in">module</span>(...deps);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> exports = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> modules[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    define,</span><br><span class="line">    exports,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">moduleManage.define(<span class="string">'a'</span>, [], () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sayName = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name: %s'</span>, name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">moduleManage.define(<span class="string">'b'</span>, [<span class="string">'a'</span>], (a) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">const</span> sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    a.sayName(name)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sayName,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = moduleManage.exports(<span class="string">'b'</span>);</span><br><span class="line">b.sayName();</span><br></pre></td></tr></table></figure><p>模块依赖管理器也依然是个模块，这里的实现其实很简单。<code>modules[name] = module(...deps)</code>，使用 <strong>modules</strong> 缓存各个模块，对于依赖模块的模块，则把依赖作为参数使用。</p><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p><strong>CommonJS</strong> 规范服务于服务端，同步阻塞，在写法风格上是依赖就近。但是在浏览器上，<strong>CommonJS</strong> 就不好使了，浏览器需要从服务器请求数据，下载完成后才会有下一步的执行。如果采用 <strong>CommonJS</strong> 的同步方式，指不定什么时候文件才会下载完成。</p><p>为了推广到浏览器上，<strong>AMD</strong> 规范采用异步方式加载模块。先异步加载模块，加载完成后就可以在回调中使用依赖模块了。这样就保证了在使用依赖时，依赖已经加载完成。<strong>AMD</strong> 规范是早早地下载，早早地执行，在回调里 <code>require</code> 的是依赖的引用。在写法风格上是依赖前置，这种风格已经不同于 <strong>CommonJS</strong> 了。还有，这里早早地执行会带来一个问题，如果存在某个依赖某些条件不成立，导致没有用上。那么，这里的早早地执行岂不是多此一举了？</p><p><strong>CMD</strong> 规范是 <strong>sea.js</strong> 推崇的规范，它采用的也是异步加载模块的方式，只是在依赖模块的执行时机上有所不同。在写法风格上，又回归到 <strong>CommonJS</strong>，依赖就近。<strong>sea.js</strong> 是早早地下载，延迟执行。</p><p>到了 <strong>ES6</strong>，终于从语法上支持模块化了，<strong>ES6</strong> 模块是编译时加载，使得在编译时就能确定模块的依赖关系，而且在将来服务器和浏览器都会支持 <strong>ES6</strong> 的模块化方案。</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo+Next博客搭建之git和GitHub</title>
    <url>/Github-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8Bgit%E5%92%8C%08GitHub/</url>
    <content><![CDATA[<blockquote><p>博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.</p></blockquote><p><em>现在回头看博客的搭建过程,可以总结归纳以下几点. <strong>markdown</strong>,<strong>git和GitHub</strong>,<strong>github和coding部署</strong>, <strong>Hexo和Next了解</strong>, <strong>SEO</strong>等</em></p><p><strong>git和GitHub</strong></p><p><em>接下来会按一下流程展开,本地git配置 =&gt; 关联远程仓库 =&gt; 初始化仓库.由于博主使用的Mac,执行命令时会和window下cmd有所区别.</em></p><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><ol><li><p>完成git 的安装后,在使用之前需要配置一些全局参数, 如username和email.因为GitHub每次commit都会记录它们.</p><pre><code>git config --global user.name &quot;username&quot;

git config --global user.email &quot;email&quot;
</code></pre></li><li><p>除了username和email外,还有许多自定义配置,示例:</p><pre><code>git config --global color.ui true    // git输出显示不同颜色

git config --global ignorecase true    // git对仓库中的文件大小写敏感

git config --global alias.st status    // git提供alias的功能,git status缩写为git st

git config --global apply.whitespace nowarn // git忽略空白的变化
</code></pre></li><li><p>查看所有已经做出的配置:</p><pre><code>git config -l
或
git config --list
</code></pre></li></ol><h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>首先在<a href="https://github.com" rel="external nofollow noopener noreferrer" target="_blank">github官网</a>有自己的账号,之后就可以创建仓库了.</p><h3 id="添加SSH-Key"><a href="#添加SSH-Key" class="headerlink" title="添加SSH Key"></a>添加SSH Key</h3><p>由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的,所以需执行以下步骤:</p><ol><li><p>本地创建ssh key.</p><pre><code>$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;
</code></pre><p>后面的<a href="mailto:your_email@youremail.com" rel="external nofollow noopener noreferrer" target="_blank">your_email@youremail.com</a>改为你在github上注册的邮箱,之后会要求确认路径和输入密码,我们默认一路回车就行.成功的话会在~/下生成.ssh文件夹,进去打开id_rsa.pub,复制里面的key.</p><pre><code>ls -al ~/.ssh    // 查看是否存在id_rsa.pub,若存在,执行下一步;

cd ~/.ssh    // 进入.ssh目录

cat id_rsa.pub    // 查看复制id_rsa.pub
</code></pre></li><li><p>在GitHub里添加复制的id_rsa.pub. Settings =&gt; SSH and GPG keys =&gt;New SSH key.操作之后,如图示:<br><img src="../images/SSH.png" alt="SSH"><br>Title任意填写,Key填入之前复制的id_rsa.pub.点击Add SSH key,添加已经完成.</p></li><li><p>验证是否成功,输入下列命令:</p><pre><code>ssh -T git@github.com
</code></pre><p>如果是第一次的会提示是否continue,输入yes就会看到:You’ve successfully authenticated,but GitHub does not provide shell access.这就表示已成功连上github.</p></li></ol><h3 id="创建GitHub项目并添加远程仓库"><a href="#创建GitHub项目并添加远程仓库" class="headerlink" title="创建GitHub项目并添加远程仓库"></a>创建GitHub项目并添加远程仓库</h3><p>登陆github账户后,点击<code>New repository</code>, 会有Create a new repository页面,填写相关信息,点击<code>Create repository</code>,可以根据官网提供的方式添加远程仓库.如下:</p><p><strong>…or create a new repository on the command line</strong></p><pre><code>echo &quot;# something&quot; &gt;&gt; README.md    // 生成readme.md

git init    // 初始化本地仓库

git add README.md    // 将文件添加到暂存区

git commit -m &quot;first commit&quot;    // 将暂存区文件提交到仓库中

git remote add origin git@github.com:your-repository    // 添加你的远程仓库

git push -u origin master    // 将本地仓库推送到远程仓库
</code></pre><p><strong>…or push an existing repository from the command line</strong></p><pre><code>git remote add origin git@github.com:your-repository

git push -u origin master
</code></pre><p style="color:#4aa9aa;font-size:18px;font-weight:700">以上步骤完成了本地仓库到远程仓库的连接,接下来总结git的一些常用的命令</p><p><strong>深入了解可参考 <a href="https://git-scm.com/book/zh/v2" rel="external nofollow noopener noreferrer" target="_blank">git中文</a></strong></p><h2 id="git的常用命令"><a href="#git的常用命令" class="headerlink" title="git的常用命令"></a>git的常用命令</h2><p><img src="../images/git.png" alt="git示意图"></p><h3 id="状态和工作区域"><a href="#状态和工作区域" class="headerlink" title="状态和工作区域"></a>状态和工作区域</h3><ul><li><p>三种状态</p><p>已提交: 表示数据已经安全得保存在本地数据库中.</p><p>已修改: 表示修改了文件,但还没保存到数据库中.</p><p>已暂存: 表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.</p></li><li><p>三种工作区域</p><p>Git仓库目录: 是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,从其他计算机克隆仓库时,拷贝的就是这里的数据.</p><p>工作目录: 对项目的某个版本独立提取出来的内容.这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.</p><p>暂存区: 是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中.有时也被称作’索引’.</p></li><li><p>工作目录下的两种状态</p><p>已跟踪: 指被纳入了版本控制的文件,在上一次<a href="https://git-scm.com/book/zh/v2/起步-Git-基础" rel="external nofollow noopener noreferrer" target="_blank">快照</a>中有它们的记录,在工作一段时间后,它们的状态可能处于为修改,已修改或已暂存.</p><p>未跟踪: 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在与上次快照中,也没有放入暂存区.</p><p><em>初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.</em></p></li></ul><h3 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h3><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件.</li><li>暂存文件,将文件的快照放入暂存区域.</li><li>提交更新,找到暂存区域的文件,将快照永久性存储到 Git 仓库目录.</li></ol><p>如果 Git 目录中保存着的特定版本文件,就属于已提交状态. 如果作了修改并已放入暂存区域，就属于已暂存状态.如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态.</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h4><pre><code>git init
</code></pre><p>该命令将创建一个名为.git的子目录,这个子目录含有初始化的Git仓库中所有的必须文件</p><h4 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h4><pre><code>git add &lt;file&gt;    // 添加单个文件到暂存区

git add .   // &apos;.&apos; 表示所有文件、文件夹和子文件夹
</code></pre><h4 id="添加文件到仓库"><a href="#添加文件到仓库" class="headerlink" title="添加文件到仓库"></a>添加文件到仓库</h4><pre><code>git commit      // 将暂存区的文件提交到仓库中

git commit -m &apos;提交信息&apos;      // -m 带提交信息,说明本次提交内容或修改等

git commit -am     // -a Git会自动把所有已经跟踪过的文件暂存一并提交,从而跳过git add步骤
</code></pre><h4 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h4><pre><code>git status      // 查看哪些文件处于什么状态

git status -s       // git status -short 输出简介显示

??  filename-1      // 新添加未跟踪文件前面有??标记

A   filename-2      // 新添加到暂存区文件前有A标记

M   filename-3      // 出现在左边的M表示,该文件被修改了并放入了暂存区

 M  filename-4      // 出现在右边的M表示该文件被修改了但没放入暂存取

MM  filename-5      // 同时出现表示在工作区被修改并提交到暂存区由于在工作区中被修改了,所以说暂存区和工作区都有该文件的修改记录
</code></pre><h4 id="查看文件具体修改"><a href="#查看文件具体修改" class="headerlink" title="查看文件具体修改"></a>查看文件具体修改</h4><pre><code>git diff        // 该命令查看未暂存的文件更新了哪些部分,用于比较工作目录中当前文件和暂存区域快照之间的差异

git diff  --cached      // 该命令用于查看已暂存的将要添加到下次提交里的内容 (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的)
</code></pre><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><pre><code>git log     // 按提交时间列出所有的更新,最新的更新排在最上面

git log -p -(n)       // -p 用来显示每次提交的内容差异. -(n) 仅显示最近n次提交

git log --stat      // 每次的简略的统计信息

git log --pretty=oneline        // 该选项指定使用不同于默认格式的方式展示提交历史. 可用选项包括oneline,short,full,fuller和format(后跟指定格式)

git log --shortstat     // 只显示--stat中最后的行数修改添加移除统计

git log --name-only     // 仅在提交信息后显示已修改的文件清单

git log --name-status       // 显示新增、修改、删除的文件清单

git log --graph     // 显示ASCLL图形表示的分支合并历史

git relog       // 引用日志,记录了HEAD和分支引用所指向的历史,只存在在于本地仓库
</code></pre><h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><pre><code>git reset HEAD &lt;file&gt;       // 丢弃已经进入暂存取的修改

git checkout -- &lt;file&gt;      // 丢弃工作区中文件的修改

git checkout -- .       // 丢弃当前目录下所有工作区中的修改
</code></pre><h4 id="退回到某个提交版本"><a href="#退回到某个提交版本" class="headerlink" title="退回到某个提交版本"></a>退回到某个提交版本</h4><pre><code>git reset --hard HEAD^      // 回退到上一个提交

git reset --hard HEAD^^     // 回退到上上一个提交

git reset --hard &lt;commit_id&gt;        // 回退到指定id的提交版本
</code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>在文件未添加到暂存取之前,可以直接物理删除想要删除的文件.或通过<code>git checkout -- &lt;file&gt;</code> 来丢弃修改.如果文件已经被提交,则需要<code>git rm</code>删除</p><pre><code>git rm &lt;file&gt;      //  删除被提交的文件
</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><pre><code>git remote      // 查看已配置的远程仓库服务器

git remote -v       // 显示需要读写远程仓库使用的Git保存的简写与对应的URL

git remote show &lt;remote-name&gt;       // 查看某一个远程仓库的更多信息
</code></pre><h4 id="添加远程仓库-1"><a href="#添加远程仓库-1" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><pre><code>git remote add &lt;remote-name&gt; &lt;url&gt;        // 添加地址为URL,名为remote-name的引用
</code></pre><h4 id="从远程仓库中拉取与推送"><a href="#从远程仓库中拉取与推送" class="headerlink" title="从远程仓库中拉取与推送"></a>从远程仓库中拉取与推送</h4><pre><code>git fetch &lt;remote-name&gt;     // 该命令将数据拉取到本地仓库,并不会自动合并或修改当前的工作

git pull &lt;remote-name&gt;      // 改命令自动抓取然后合并远程分支到当前分支

git push &lt;remote-name&gt; &lt;branch-name&gt;        // 将branch-name分支推送到remote-name服务器上

git push -u &lt;remote-name&gt; &lt;branch-name&gt;     // 第一次使用带上-u参数,在将本地的 master 分支推送到远程新的 master 分支的同时,还会把本地的 master 分支和远程的 master 分支关联起来
</code></pre><h4 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h4><pre><code>git remote rm &lt;remote-name&gt;      // 移除远程仓库

git remote rename &lt;old-name&gt; &lt;new-name&gt;        // 重命名远程仓库
</code></pre><h4 id="修改本地仓库对应的远程仓库"><a href="#修改本地仓库对应的远程仓库" class="headerlink" title="修改本地仓库对应的远程仓库"></a>修改本地仓库对应的远程仓库</h4><pre><code>git remote set-url &lt;remote-name&gt; &lt;url&gt;        // 当远程的仓库地址发生变化时,需要修改本地仓库对应的远程仓库地址
</code></pre><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><pre><code>git branch      // 查看本地分支信息, 输出内容中,标记*,表示当前所在分支

git branch -v       // 查看详细的本地分支信息

git branch &lt;branch-name&gt;     // 新建一个branch-name分支

git checkout &lt;branch-name&gt;        // 新建完branch-name分支后,并通过该命令切到branch-name分支

git checkout master
git merge &lt;branch-name&gt;      // 切换回master分支,并将branch-name分支的修改合并到master分支

git branch -d &lt;branch-name&gt;       // 删除branch-name分支
</code></pre>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac终端改造</title>
    <url>/Mac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<p>平时Mac使用的shell使bash, 它虽然能满足我们的需要, 但是使用起来不是很方便. zsh可配置性强, 用户可以自定义配置, 个性化强.</p><h1 id="更换shell"><a href="#更换shell" class="headerlink" title="更换shell"></a>更换shell</h1><h2 id="查看当前使用的shell"><a href="#查看当前使用的shell" class="headerlink" title="查看当前使用的shell"></a>查看当前使用的shell</h2><blockquote><p><strong><code>echo $SHELL</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h2 id="查看系统当前内置的shell"><a href="#查看系统当前内置的shell" class="headerlink" title="查看系统当前内置的shell"></a>查看系统当前内置的shell</h2><blockquote><p><strong><code>cat /etc/shells</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>如果没有发现/bin/zsh, 就需要手动安装<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" rel="external nofollow noopener noreferrer" target="_blank">Zsh</a>.</p><h2 id="替换shell"><a href="#替换shell" class="headerlink" title="替换shell"></a>替换shell</h2><blockquote><p><strong><code>chsh -s /bin/zsh</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Changing shell <span class="keyword">for</span> **.</span><br><span class="line">Password <span class="keyword">for</span> **: your password</span><br></pre></td></tr></table></figure><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><blockquote><p><strong><code>echo $SHELL</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>替换成功!</p><h1 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h1><p><a href="https://ohmyz.sh" rel="external nofollow noopener noreferrer" target="_blank">oh-my-zsh</a>用来管理Zsh配置的.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p><strong><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;.</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Looking <span class="keyword">for</span> an existing zsh config...</span><br><span class="line">Using the Oh My Zsh template file and adding it to ~/.zshrc</span><br><span class="line">        __                                     __</span><br><span class="line">____  / /_     ____ ___  __  __   ____  _____/ /_</span><br><span class="line">/ __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \</span><br><span class="line">/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /</span><br><span class="line">\____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/</span><br><span class="line">                        /____/                       ....is now installed!</span><br><span class="line"></span><br><span class="line">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br><span class="line"></span><br><span class="line">p.s. Follow us at https://twitter.com/ohmyzsh.</span><br><span class="line"></span><br><span class="line">p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.</span><br></pre></td></tr></table></figure><h2 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h2><blockquote><p><strong><code>vim ~/.zshrc</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set name of the theme to load --- if set to "random", it will</span></span><br><span class="line"><span class="comment"># load a random theme each time oh-my-zsh is loaded, in which case,</span></span><br><span class="line"><span class="comment"># to know which specific one was loaded, run: echo $RANDOM_THEME</span></span><br><span class="line"><span class="comment"># See https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</span></span><br><span class="line">ZSH_THEME=<span class="string">"robbyrussell"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to disable bi-weekly auto-update checks.</span></span><br><span class="line"><span class="comment"># DISABLE_AUTO_UPDATE="true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to enable command auto-correction.</span></span><br><span class="line">ENABLE_CORRECTION=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the following line to display red dots whilst waiting for completion.</span></span><br><span class="line">COMPLETION_WAITING_DOTS=<span class="string">"true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Which plugins would you like to load?</span></span><br><span class="line"><span class="comment"># Standard plugins can be found in ~/.oh-my-zsh/plugins/*</span></span><br><span class="line"><span class="comment"># Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"><span class="comment"># Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">git</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> <span class="variable">$ZSH</span>/oh-my-zsh.sh</span><br></pre></td></tr></table></figure><p>以上是部分配置, 需将<code>#</code>删除才能生效. 键入<code>i</code>进入编辑模式, 修改后<code>esc</code>退出编辑模式, 键入<code>:wq</code>保存退出. oh-my-zsh有支持的<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes" rel="external nofollow noopener noreferrer" target="_blank">主题</a>和<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins" rel="external nofollow noopener noreferrer" target="_blank">插件</a>, 可以自由配置.</p><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h3 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h3><h4 id="安装zsh-syntax-highlighting"><a href="#安装zsh-syntax-highlighting" class="headerlink" title="安装zsh-syntax-highlighting"></a>安装zsh-syntax-highlighting</h4><blockquote><p><strong><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></strong></p></blockquote><h4 id="修改配置-zsh-syntax-highlighting"><a href="#修改配置-zsh-syntax-highlighting" class="headerlink" title="修改配置(zsh-syntax-highlighting)"></a>修改配置<del>(zsh-syntax-highlighting)</del></h4><blockquote><p><strong><code>vim ~/.zshrc</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="让修改生效-zsh-syntax-highlighting"><a href="#让修改生效-zsh-syntax-highlighting" class="headerlink" title="让修改生效(zsh-syntax-highlighting)"></a>让修改生效<del>(zsh-syntax-highlighting)</del></h4><blockquote><p><strong><code>source ~/.zshrc</code></strong></p></blockquote><h3 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h3><h4 id="安装zsh-autosuggestions"><a href="#安装zsh-autosuggestions" class="headerlink" title="安装zsh-autosuggestions"></a>安装zsh-autosuggestions</h4><blockquote><p><strong><code>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></strong></p></blockquote><h4 id="修改配置-zsh-autosuggestions"><a href="#修改配置-zsh-autosuggestions" class="headerlink" title="修改配置(zsh-autosuggestions)"></a>修改配置<del>(zsh-autosuggestions)</del></h4><blockquote><p><strong><code>vim ~/.zshrc</code></strong></p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git zsh-autosuggestions zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="让修改生效-zsh-autosuggestions"><a href="#让修改生效-zsh-autosuggestions" class="headerlink" title="让修改生效(zsh-autosuggestions)"></a>让修改生效<del>(zsh-autosuggestions)</del></h4><blockquote><p><strong><code>source ~/.zshrc</code></strong></p></blockquote><p>好了, 打完收工!</p>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Mac终端</tag>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Object原型方法</title>
    <url>/Object%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p><strong><em>Object</em></strong> 构造函数用来包装成对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong><em>Object</em></strong> 构造函数为给定值创建一个对象包装器. 如果给定值是 <strong><em>null</em></strong> 或 <strong><em>undefined</em></strong>, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.</p><p>当以非构造函数形式被调用时, <strong><em>Object</em></strong> 等同于 <code>new Object()</code>.</p><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p><strong>描述</strong> : 判断自身属性中是否有指定的属性.<br><strong>语法</strong> :</p><blockquote><p><em><code>target.prototype.hasOwnProperty(prop)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>prop</code></strong> : 要检测的属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'yexiaochen'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_1 = person.hasOwnProperty(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = person.hasOwnProperty(<span class="string">'age'</span>)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p><strong>描述</strong> : 判断一个对象是否在另一个对象的原型链上.<br><strong>语法</strong> :</p><blockquote><p><em><code>prototypeObject.isPrototypeOf(obj)</code></em></p></blockquote><p><strong><code>obj</code></strong> : 提供原型链的对象.<br><strong><code>prototypeObject</code></strong> : 待检测的对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Man.prototype = <span class="built_in">Object</span>.create(Person.prototype)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man = <span class="keyword">new</span> Man()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boolean_1 = Person.prototype.isPrototypeOf(man)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = Man.prototype.isPrototypeOf(man)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h3><p><strong>描述</strong> : 判断对象的指定属性是否可枚举. 原型链上继承来的属性除外. 如果对象没有指定的属性，则此方法返回false<br><strong>语法</strong> :</p><blockquote><p><em><code>target.propertyIsEnumerable(prop)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>sources</code></strong> : 待检测的属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'yexiaochen'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_1 = person.propertyIsEnumerable(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = person.propertyIsEnumerable(<span class="string">'age'</span>)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p><strong>描述</strong> : 一个表示该对象的字符串<br><strong>语法</strong> :</p><blockquote><p><em><code>target.toString()</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> str_1 = person.toString();</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="built_in">Object</span>.prototype.toString.call(person)</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="built_in">Object</span>.prototype.toString.call(Person)</span><br><span class="line"><span class="comment">// &gt; str_1</span></span><br><span class="line"><span class="comment">// '[object Object]'</span></span><br><span class="line"><span class="comment">// &gt; str_2</span></span><br><span class="line"><span class="comment">// '[object Object]'</span></span><br><span class="line"><span class="comment">// &gt; str_3</span></span><br><span class="line"><span class="comment">// '[object Function]'</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h3><p><strong>描述</strong> : 对象转换为原始值. 如果对象没有原始值, 返回对象本身.<br><strong>语法</strong> :</p><blockquote><p><em><code>target.valueOf()</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line"><span class="keyword">let</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> boolean = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="string">'hello'</span>&#125;</span><br><span class="line">str.valueOf()</span><br><span class="line">num.valueOf()</span><br><span class="line">boolean.valueOf()</span><br><span class="line">arr.valueOf()</span><br><span class="line">func.valueOf()</span><br><span class="line">obj.valueOf()</span><br><span class="line"><span class="comment">// &gt;     str.valueOf()</span></span><br><span class="line"><span class="comment">// 'hello world'</span></span><br><span class="line"><span class="comment">// &gt;     num.valueOf()</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// &gt;     boolean.valueOf()</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt;     arr.valueOf()</span></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="comment">// &gt;     func.valueOf()</span></span><br><span class="line"><span class="comment">// [Function: a]</span></span><br><span class="line"><span class="comment">// &gt;     obj.valueOf()</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello' &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Object</tag>
        <tag>对象原型</tag>
      </tags>
  </entry>
  <entry>
    <title>React+Koa+MongoDB+Docker开发环境</title>
    <url>/React-Koa-MongoDB-Docker/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次博文依然是对 <code>multi-spa-webpack-cli</code> 的扩充和完善。</p><ol><li>集成 <strong>mongoose</strong>。</li><li>集成 <strong>Docker</strong> 开发环境。</li></ol><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install multi-spa-webpack-cli -g</span><br></pre></td></tr></table></figure><p>使用步骤如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 初始化项目</span></span><br><span class="line"></span><br><span class="line">multi-spa-webpack-cli init spa-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 进入文件目录</span></span><br><span class="line"></span><br><span class="line">cd spa-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 未使用 Docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 打包不变的部分</span></span><br><span class="line"></span><br><span class="line">npm run build:dll</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 启动项目（手动打开浏览器：localhost:8090）</span></span><br><span class="line"></span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 启动 MongoDB</span></span><br><span class="line"></span><br><span class="line">mongod</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 启动服务</span></span><br><span class="line"></span><br><span class="line">cd server</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 Docker（需安装docker）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 启动项目（手动打开浏览器：localhost:8090）</span></span><br><span class="line"></span><br><span class="line">npm run docker:dev</span><br></pre></td></tr></table></figure><p>从上面的步骤可以看出，Docker 只需要 3 步就可以启动项目了。</p><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><blockquote><p>mongoose 是在 node.js 环境下对 MongoDB 进行便捷操作的对象模型工具。</p></blockquote><p>在没开始之前，要先安装 MongoDB。安装 MongoDB 的过程中，可能有些小麻烦，尤其是公司的电脑（谁也不知道电脑里配置了什么东西）。安装过程可参照 【<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/#install" rel="external nofollow noopener noreferrer" target="_blank">官网：安装MongoDB</a>】</p><p>还要知道 MongoDB 的一些概念。</p><table><thead><tr><th style="text-align:center">SQL术语/概念</th><th style="text-align:center">MongoDB术语/概念</th><th style="text-align:center">解释/说明</th></tr></thead><tbody><tr><td style="text-align:center">database</td><td style="text-align:center">database</td><td style="text-align:center">数据库</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">collection</td><td style="text-align:center">数据库表/集合</td></tr><tr><td style="text-align:center">row</td><td style="text-align:center">document</td><td style="text-align:center">数据记录行/文档</td></tr><tr><td style="text-align:center">column</td><td style="text-align:center">field</td><td style="text-align:center">数据字段/域</td></tr><tr><td style="text-align:center">index</td><td style="text-align:center">index</td><td style="text-align:center">索引</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">joins</td><td style="text-align:center">表连接,MongoDB不支持</td></tr><tr><td style="text-align:center">primary key</td><td style="text-align:center">primary key</td><td style="text-align:center">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p>数据库服务和客户端：</p><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">MongoDB</th></tr></thead><tbody><tr><td style="text-align:center">Mysqld/Oracle</td><td style="text-align:center">mongod</td></tr><tr><td style="text-align:center">mysql/sqlplus</td><td style="text-align:center">mongo</td></tr></tbody></table><p>mongoose 相关概念看看官网就好了【<a href="https://mongoosedoc.top/docs/index.html" rel="external nofollow noopener noreferrer" target="_blank">mongoose 中文文档</a>】</p><p>用法很简单，定义 Schema，转换成 Model，操作 Model，生成实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* model.js */</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="comment">// 定义 Schema</span></span><br><span class="line"><span class="keyword">const</span> UserSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  username: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    unique: <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  password: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    <span class="built_in">require</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成 Model</span></span><br><span class="line"><span class="keyword">const</span> UserModel = mongoose.model(<span class="string">'User'</span>, UserSchema);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UserModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* user.js */</span></span><br><span class="line"><span class="comment">// 操作 Model</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">await</span> UserModel.findOne(&#123; username &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成实例</span></span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">new</span> UserModel(&#123;</span><br><span class="line">            username,</span><br><span class="line">            password</span><br><span class="line">            &#125;).save();</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">            <span class="string">"success"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"注册成功"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">            <span class="string">"success"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"注册失败"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        <span class="string">"success"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"message"</span>: <span class="string">"用户名已存在"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>由上面的步骤，我们可以看出来，项目启动步骤麻烦，而且在安装 MongoDB 环境时，容易受干扰。</p><p>下面通过 Docker 来构建开发环境，提高开发体验。</p><p>在使用 Docker 之前，先了解下几个概念。</p><ul><li>镜像： 镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</li></ul><blockquote><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p></blockquote><p>所以，在生产部署时，确保每一层的纯净，剔除不必要文件。比如开发编译时的文件等（ node_module ）。这样也避免了镜像不必要的臃肿。</p><ul><li>容器：容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。</li></ul><blockquote><p>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p></blockquote><blockquote><p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p></blockquote><blockquote><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p></blockquote><blockquote><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p></blockquote><p>开发环境经常对文件修改，就可以利用这里的数据卷绑定宿主目录。</p><ul><li>上下文：传给 Docker 引擎的文件目录。</li></ul><p>Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。在构建镜像时，会将上下文复制到 Docker 引擎。然后通过 Docker 客户端发出指令，而指令的执行是在 Docker 引擎中。所以，上下文的范围要合理，范围过大，就会导致文件复制到 Docker 引擎的时间长；范围过小，则会导致无法操作范围外的文件。</p><h2 id="Docker-部署开发环境"><a href="#Docker-部署开发环境" class="headerlink" title="Docker 部署开发环境"></a>Docker 部署开发环境</h2><p>部署开发环境其实很简单，只需要配置 Dockerfile 和 docker-compose 即可。相关文档可见：【<a href="https://www.hacking8.com/docker-practice/image/dockerfile/README.html" rel="external nofollow noopener noreferrer" target="_blank">Dockerfile 指令详解</a>】和【<a href="https://www.hacking8.com/docker-practice/compose/compose_file.html" rel="external nofollow noopener noreferrer" target="_blank">Compose 模板文件</a>】</p><p>docker-compose 使用的是 YAML 语言，【<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" rel="external nofollow noopener noreferrer" target="_blank">YAML 语言教程</a>】</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.6'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">"client"</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">../</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile.client.dev</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../src:/app/client/src</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8090:8090"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">"server"</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">../server</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile.server.dev</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../server:/app/server</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080:8080"</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">database</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../data:/data/db</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"27017:27017"</span></span><br></pre></td></tr></table></figure><p>开发环境需要的就是实时展现效果，前端页面是这样，后端服务亦是如此。<br>如上文提到，上下文已经提交到镜像，前端项目如何才能够在容器中实现热替换？其实很简单，就是 volumes 这个配置。同理，后端也是，不过还需要 modemon 工具协助。</p><p>在部署时，也要到了一些问题，就是在镜像中，localhost 无法使用，需要用 IP 代替。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前端项目</span></span><br><span class="line"><span class="comment">/* webpack.dev.js */</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dist'</span>),</span><br><span class="line">    port: APP_CONFIG.port,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>, <span class="comment">// 需指明</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    historyApiFallback: &#123;</span><br><span class="line">      index: <span class="string">'/'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端项目</span></span><br><span class="line"><span class="comment">/* config.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">'database'</span>: <span class="string">'mongodb://database:27017/yexiaochen'</span>  <span class="comment">// 与 docker-compose 中 database 服务名匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Node写爬虫</title>
    <url>/Node%E5%86%99%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一段时间在学习小程序，文档很长，但是对于前端开发者来说，并不是很难。然而在准备实践的时候，却犯难了。虽然只是练手，但起码要做一个有意义的东西。所以，第一时间，就想到利用爬虫来爬取自己想要的内容。在打算实践时，却也发现，由于小程序的的一些限制，要想实现我的想法，太麻烦，对于我来说，有点浪费时间。不过，既然都想到过爬虫了，就趁这次机会练练手。</p><p>通过本次的粗浅的实践，可以将爬虫的过程总结为，获取静态页面或获取接口数据 =&gt; 分析页面结构或分析接口数据 =&gt; 提取数据保存。基于Node的爬虫方式，要么是加载页面，要么是请求API，所以相对来说都很容易实现。</p><h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h2><p><a href="https://github.com/GoogleChrome/puppeteer" rel="external nofollow noopener noreferrer" target="_blank">puppeteer</a> 应该算是最简单的方式了，通过模拟用户的行为与浏览器交互，然后我们就可以分析页面抓去需要的信息。puppeteer 文档很详实，而且手把手教学，你想要的功能基本上都能在它的 github 上找到相应的例子。</p><p>puppeteer 是基于 Chromium 的，在安装 puppeteer时，会同时安装 Chromium。而因为众所周知的缘故，整个安装的过程并不是很顺利，文档里提供了不安装 Chromium 的方法，不过，我们也可以使用淘宝的镜像来加快安装时间。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set puppeteer_download_host https://npm.taobao.org/mirrors</span><br></pre></td></tr></table></figure><p>下面通过一个打卡🌰来使用 puppeteer,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> login = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);  <span class="comment">// 默认true。置为 false，整个操作过程可视</span></span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(logURL);  <span class="comment">// 跳转目标网页logURL，默认 load 事件触发</span></span><br><span class="line">  <span class="keyword">await</span> page.type(<span class="string">'#member_number'</span>, <span class="string">'123456'</span>)  <span class="comment">// 输入卡号</span></span><br><span class="line">  <span class="keyword">await</span> page.click(<span class="string">'#btn_member_number'</span>)  <span class="comment">// 点击确定</span></span><br><span class="line">  <span class="keyword">await</span> page.waitForSelector(<span class="string">'#check_in'</span>)  <span class="comment">// 等待签到 Dom 渲染完成</span></span><br><span class="line">  <span class="keyword">await</span> page.click(<span class="string">'#check_in'</span>)  <span class="comment">// 点击签到按钮</span></span><br><span class="line">  <span class="keyword">await</span> browser.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码流程和用户操作浏览器的流程一致，这种方式相比接下来要说的方式，可以说是傻瓜式操作了。当然 puppeteer 还可以生成截图，性能分析等。</p><h2 id="接口请求"><a href="#接口请求" class="headerlink" title="接口请求"></a>接口请求</h2><p>不管是静态还是动态页面的获取，都是通过接口请求来实现的，即通过url向后端服务请求相应的数据。按照之前的爬取流程，要做的就是数据的请求和数据的分析。如果需要保存的话，就要使用存储工具储存数据。</p><p>一般情况下，在 Node 环境中请求数据，我们会使用封装好的 htttp 库，比如 request，axios等。那么分析数据呢？这就要看情况了，如果爬取的是静态页面，返回的是 HTML，这时我们就需要借助 Cheerio 或 JSDOM 来分析页面结构。如果返回的是常见的 JSON，那就很简单了。</p><p>不过本次实践没有通过以上的方式，而是在 github 搜索相关信息时，恰巧看到了 <a href="https://github.com/bda-research/node-crawler" rel="external nofollow noopener noreferrer" target="_blank">crawler</a>。原理上都是差不多的，而且它也集成了 Cheerio。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Crawler = <span class="built_in">require</span>(<span class="string">"crawler"</span>);</span><br><span class="line"><span class="keyword">const</span> crawlerWebPage = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;uri, selector&#125; = obj;  <span class="comment">// uri 请求的uri，selector 选择器；</span></span><br><span class="line">  crawler.direct(&#123;</span><br><span class="line">    uri: uri,</span><br><span class="line">    skipEventRequest: <span class="literal">false</span>,</span><br><span class="line">    callback: <span class="function"><span class="keyword">function</span>(<span class="params">error, response</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> $ = response.$;</span><br><span class="line">          <span class="keyword">var</span> content = $(selector).text();</span><br><span class="line">            <span class="built_in">console</span>.log(response.statusCode, content, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>上面这个也只是 crawler 的简单用法。</p><h2 id="node-schedule"><a href="#node-schedule" class="headerlink" title="node-schedule"></a>node-schedule</h2><p>虽然可以爬取了，但是数据并不是一成不变的，所以，更多的时候，我们需要定时重复爬取网页。 <a href="https://github.com/node-schedule/node-schedule" rel="external nofollow noopener noreferrer" target="_blank">node-schedule</a> 就是用来定义定时任务的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">'node-schedule'</span>);</span><br><span class="line"><span class="keyword">const</span> loginSchedule = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  schedule.scheduleJob(&#123;</span><br><span class="line">    start: startTime,</span><br><span class="line">    endTime: endTime,</span><br><span class="line">    rule: config.schedule.login[loginIndex]</span><br><span class="line">  &#125;, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">let</span> loginLog = <span class="string">`<span class="subst">$&#123;now&#125;</span> login successed! /r/n`</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      login();</span><br><span class="line">      fs.appendFileSync(<span class="string">'log.txt'</span>, loginLog)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">let</span> loginErrorLog = <span class="string">`<span class="subst">$&#123;now&#125;</span> - <span class="subst">$&#123;logURL&#125;</span> login failed: <span class="subst">$&#123;error.message&#125;</span>! /r/n`</span>;</span><br><span class="line">      fs.appendFileSync(<span class="string">'log.txt'</span>, loginErrorLog)</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好相关的规则后，任务就可以按制定的规则执行。</p><h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><p>以上的任务是可以执行了，可是关闭了命令窗口，进程中断，那么功夫白费。这时候就需要一个工具来管理 node 进程，<a href="http://pm2.keymetrics.io/" rel="external nofollow noopener noreferrer" target="_blank">pm2</a> 倒是一个好工具。pm2 不仅支持热加载，还可以监控等功能，很方便很强大。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">npm install pm2 -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动、监听 app.js</span></span><br><span class="line">pm2 start app.js  --watch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控</span></span><br><span class="line">pm2 monit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 终止</span></span><br><span class="line">pm2 stop</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在写 Node 应用时，难免磕磕绊绊，学会调试也是很有必要的。本次项目很简单，所以所使用的调试技巧也很粗浅。</p><ul><li><p>使用 VSCode 提供的调试工具。</p></li><li><p>在项目中加入 <code>debugger</code>，执行 <code>node debug --inspect app.js</code>,开启调试模式。</p></li><li><p>借助其他调试工具。</p></li></ul><p><strong>over</strong></p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Object构造函数</title>
    <url>/Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p><strong><em>Object</em></strong> 构造函数用来包装成对象.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong><em>Object</em></strong> 构造函数为给定值创建一个对象包装器. 如果给定值是 <strong><em>null</em></strong> 或 <strong>*undefined</strong>, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.</p><p>当以非构造函数形式被调用时, <strong><em>Object</em></strong> 等同于 <code>new Object()</code>.</p><h2 id="构造函数方法"><a href="#构造函数方法" class="headerlink" title="构造函数方法"></a>构造函数方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p><strong>描述</strong> :<br>获取给定对象自身可枚举属性(字符串)组成的数组.</p><blockquote><p><em><code>Object.keys(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'b'</span>, &#123;<span class="attr">value</span>: <span class="string">'world'</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">let</span> propertyArray = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; propertyArray</span></span><br><span class="line"><span class="comment">// [ 'a' ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><strong>描述</strong> :<br>获取给定对象自身可枚举属性值组成的数组.</p><blockquote><p><em><code>Object.values(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'c'</span>, &#123;<span class="attr">value</span>: <span class="string">'world'</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'c'</span>)</span><br><span class="line"><span class="keyword">let</span> valuesArray = <span class="built_in">Object</span>.values(obj);</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; valuesArray</span></span><br><span class="line"><span class="comment">// [ 'hello', [Function: b] ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><strong>描述</strong> :<br>由给定对象自身可枚举属性的键值对数组组成的数组. 属性的顺序与通过 <code>for...in</code> 循环对象的属性值所给出的顺序相同.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.entries(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="string">'word'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj_2 = <span class="built_in">Object</span>.entries(obj_1)</span><br><span class="line"><span class="comment">// &gt; obj_2</span></span><br><span class="line"><span class="comment">// [ [ 'a', 'hello' ], [ 'b', 'word' ] ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(obj_2)</span><br><span class="line"><span class="comment">// &gt; map</span></span><br><span class="line"><span class="comment">// Map &#123; 'a' =&gt; 'hello', 'b' =&gt; 'word' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><strong>描述</strong> :<br>创建一个新对象, 并将内部属性 <strong><em><code>[[Prototype]]</code></em></strong> 指向源对象.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.create(sources[, Properties])</code></em></p></blockquote><p><strong><code>sources</code></strong> : 提供原型的源对象.<br><strong><code>Properties</code></strong> : 为新对象添加属性, 规则如同 <strong><em><code>Object.defineProperties(obj, Prototype)</code></em></strong>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="string">'word'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj_2 = <span class="built_in">Object</span>.create(obj_1, &#123;<span class="attr">name</span>: &#123;<span class="attr">value</span>: <span class="string">'obj_2'</span>&#125;&#125;)</span><br><span class="line">&gt;obj_2</span><br><span class="line"><span class="comment">// &#123;name: 'obj_2', _proto_: &#123;a: 'hello', b: 'word'&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><strong>描述</strong> :<br>将源目标(一个或多个)对象中的所有可枚举属性值复制到目标对象中. 如果目标对象和源对象中存在相同的属性(键), 后者的属性将覆盖前者的属性. 最终返回目标对象.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.assign(target, ..sources)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>sources</code></strong> : 源对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="string">'word'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line"><span class="comment">// &gt; copy</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello', b: 'word' &#125;</span></span><br><span class="line"><span class="comment">// &gt; obj_1</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello', b: 'word' &#125;</span></span><br><span class="line"><span class="comment">// &gt; copy === obj_1</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj_2 = &#123;</span><br><span class="line">    a: <span class="string">'hi'</span>,</span><br><span class="line">    b: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj_3 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj_2, obj_3)</span><br><span class="line"><span class="comment">// &gt; obj_2</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello', b: 'world' &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p><strong>描述</strong> :<br>为对象定义一个新属性或修改现有属性.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.defineProperty(target, prop, descriptor)</code></em></p></blockquote><p><strong><code>target</code></strong> : 要在其上定义或修改属性的目标对象.<br><strong><code>prop</code></strong> : 要定义或修改的属性属性名称.<br><strong><code>descriptor</code></strong> : 将被定义或修改的属性描述符.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &gt; obj</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello world' &#125;</span></span><br><span class="line"><span class="comment">// &gt; property</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello world',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3><p><strong>描述</strong> :<br>为对象定义一个新属性或修改现有属性.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.defineProperties(target, propsDescriptor)</code></em></p></blockquote><p><strong><code>target</code></strong> : 要在其上定义或修改属性的目标对象.<br><strong><code>propsDescriptor</code></strong> : 将被定义或修改的属性描述符对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">    <span class="string">'a'</span>: &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'b'</span>: &#123;</span><br><span class="line">    value: <span class="string">'hi world'</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property_a = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> property_b = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'b'</span>)</span><br><span class="line"><span class="comment">// &gt; obj</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello world', b: 'hi world' &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_a</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello world',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_b</span></span><br><span class="line"><span class="comment">// &#123; value: 'hi world',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h3><p><strong>描述</strong> :<br>获取指定对象上某个自有属性对应的属性描述符.(自有属性即直接赋予该对象的属性, 非原型链继上查找到的属性)<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.getOwnPropertyDescriptor(target, prop)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>prop</code></strong> : 目标对象的属性名称.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="string">'world'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> c() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'c'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> obj_3 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'c'</span>)</span><br><span class="line"><span class="comment">// &gt; obj_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; obj_3</span></span><br><span class="line"><span class="comment">// &#123; get: [Function: get c],</span></span><br><span class="line"><span class="comment">// set: undefined,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><strong>描述</strong> :<br>获取指定对象的所有自有属性的属性名(包括不可枚举属性但不包括 <strong><em>Symbol</em></strong> 值作为名称的属性)组成的数组.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.getOwnPropertyNames(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>prop</code></strong> : 目标对象的属性名称.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="string">'world'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> c() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'c'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Object</span>.getOwnPropertyNames(obj_1)</span><br><span class="line"><span class="comment">// &gt; arr</span></span><br><span class="line"><span class="comment">// [ 'a', 'b', 'c' ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h3><p><strong>描述</strong> :<br>获取给定对象所有的 <strong><em>Symbol</em></strong> 属性的数组.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.getOwnPropertyNames(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line">obj[a] = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"><span class="comment">// &gt; arr</span></span><br><span class="line"><span class="comment">// [ Symbol(a) ]</span></span><br></pre></td></tr></table></figure><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h3><p><strong>描述</strong> :<br>使得对象变得不可扩展. 即设置对象内部 <code>[[Extensible]]</code> 值为 <strong><em>false</em></strong>.</p><blockquote><p><em><code>Object.preventExtensions(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="string">'world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isExtensible(obj_1)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj_1)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isExtensible(obj_1)</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h3><p><strong>描述</strong> :<br>使得对象变得不可扩展. 即设置对象内部 <code>[[Extensible]]</code> 值为 <strong><em>false</em></strong>. 对象属性的 <code>[[Configurable]]</code> 为 <strong><em>false</em></strong>.</p><blockquote><p><em><code>Object.seal(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="string">'world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isExtensible(obj_1)</span><br><span class="line"><span class="built_in">Object</span>.seal(obj_1)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isExtensible(obj_1)</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h3><p><strong>描述</strong> :<br>冻结一个对象, 将不能向该对象添加新的属性, 不能修改、删除已有属性, 以及不能修改已有属性的可枚举性、可配置性、可写性. 如果属性是对象, 除非被冻结, 否则也是可以修改的. 数组作为对象, 被冻结后, 元素不可被修改. <code>[[Extensible]]</code> 内部属性为 <strong><em>false</em></strong>. 对象属性的 <code>[[Configurable]]</code> 为 <strong><em>false</em></strong>. 若是对象属性描述符为数据描述符, 则对象属性的 <code>[[Writable]]</code> 为 <strong><em>false</em></strong>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.freeze(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;</span><br><span class="line">    a: <span class="string">'hello'</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="string">'world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isExtensible(obj_1)</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj_1)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj_1, <span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = Objct.isExtensible(obj_1)</span><br><span class="line">obj_1.a = <span class="string">'hi'</span></span><br><span class="line">obj_1.b.c = <span class="string">'世界'</span></span><br><span class="line"><span class="comment">// &gt; obj_1</span></span><br><span class="line"><span class="comment">// &#123; a: 'hello', b: &#123; c: '世界' &#125; &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h3><p><strong>描述</strong> :<br>判断一个对象是否可扩展的. 即是否可添加新的属性. 新对象 <code>[[Extensible]]</code> 默认为 <strong><em>true</em></strong> . <strong><em>Object.preventExtensions(target)</em></strong>, <strong><em>Object.seal(target)</em></strong> 或 <strong><em>Object.freeze(target)</em></strong> 可将目标对象内部属性 <code>[[Extensible]]</code> 置为 <strong><em>false</em></strong>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.isExtensible(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isExtensible(obj)</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isExtensible(obj)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="OObject-isSealed"><a href="#OObject-isSealed" class="headerlink" title="OObject.isSealed()"></a>OObject.isSealed()</h3><p><strong>描述</strong> :<br>判断一个对象是否被密封. 若对象的内部属性 <code>[[Extensible]]</code> 为 <strong><em>false</em></strong>, 返回 <strong><em>true</em></strong>. 若对象属性的 <code>[[Configurable]]</code> 为 <strong><em>true</em></strong>, 返回 <strong><em>false</em></strong>. 否则, 返回 <strong><em>false</em></strong>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.isSealed(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;<span class="attr">configurable</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj)</span><br><span class="line"><span class="keyword">let</span> boolean_3 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// &gt; boolean_3</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h3><p><strong>描述</strong> :<br>判断一个对象是否被冻结. 若对象的内部属性 <code>[[Extensible]]</code> 为 <strong><em>false</em></strong>, 返回 <strong><em>true</em></strong>. 若对象属性的 <code>[[Configurable]]</code> 为 <strong><em>true</em></strong>, 返回 <strong><em>false</em></strong>. 若是对象属性描述符为数据描述符, 对象属性的 <code>[[Writable]]</code> 为 <strong><em>true</em></strong>, 返回 <strong><em>false</em></strong>. 否则, 返回 <strong><em>false</em></strong>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.isFrozen(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> boolean_1 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;<span class="attr">writable</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;<span class="attr">configurable</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> boolean_3 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj)</span><br><span class="line"><span class="keyword">let</span> boolean_4 = <span class="built_in">Object</span>.isFrozen(obj)</span><br><span class="line"><span class="comment">// &gt; boolean_1</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// &gt; boolean_2</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// &gt; boolean_3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// &gt; boolean_4</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><strong>描述</strong> :<br>使得对象变得不可扩展. 即设置对象内部 <code>[[Extensible]]</code> 值为 <strong><em>false</em></strong>. 对象属性的 <code>[[Configurable]]</code> 为 <strong><em>false</em></strong>.</p><blockquote><p><em><code>Object.setPrototypeOf(target, prototype)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.<br><strong><code>prototype</code></strong> : 原型对象(对象或 <strong><em>null</em></strong>).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj_1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj_2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj_2, obj_1)</span><br><span class="line"><span class="keyword">let</span> proto_1 = <span class="built_in">Object</span>.getPrototypeOf(obj_2)</span><br><span class="line"><span class="comment">// &gt; proto_1</span></span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><strong>描述</strong> :<br>获取给定对象的原型(内部 <code>[[Prototype]]</code> 属性的值). 若没有即成属性, 则返回 <strong><em>null</em></strong>.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.getOwnPropertyNames(target)</code></em></p></blockquote><p><strong><code>target</code></strong> : 目标对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.getPrototypeOf(person)</span><br><span class="line"><span class="comment">// &gt; a</span></span><br><span class="line"><span class="comment">// Person &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> obj_1 = <span class="built_in">Object</span>.create(obj)</span><br><span class="line"><span class="keyword">let</span> obj_2 = <span class="built_in">Object</span>.getPrototypeOf(obj_1)</span><br><span class="line"><span class="comment">// &gt; obj_2</span></span><br><span class="line"><span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="comment">// &gt; obj_2 === obj</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p><strong>描述</strong> :<br>判断两个值是否相等. 规则和抽象相等、严格相等不一样.<br><strong>语法</strong> :</p><blockquote><p><em><code>Object.is(target1, target2)</code></em></p></blockquote><p><strong><code>target</code></strong> : 需要比较的两个值.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">undefined</span>, <span class="literal">undefined</span>)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="literal">true</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">false</span>, <span class="literal">false</span>)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, +<span class="number">0</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)    <span class="comment">// true *</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>SOLID设计原则JavaScript描述</title>
    <url>/SOLID%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99JavaScript%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<blockquote><p>一刷看热闹，二刷看门道。看不懂的东西，看着看着就懂了；看懂的东西，看着看着就通了。</p></blockquote><h2 id="编程范式概述"><a href="#编程范式概述" class="headerlink" title="编程范式概述"></a>编程范式概述</h2><p>在说 SOLID 原则前，还是有必要先了解下程序的编写模式，即，编程范式。如果说设计原则是为了更好得组织代码，那么，编程范式就是为了让我们有选择得使用不同的代码结构。</p><p>到目前为止，编程范式有：结构化编程，面向对象编程和函数式编程。编程范式的每次变革都对后世产生了深远的影响。</p><p>在「程序员」出现之前，编程是不受待见的。一个证明不了自身的玩意，如何让别人信服。Dijkstra 希望通过数学推导的方法来证明程序的正确性。</p><p>不过在此之前，Bohm 和 Jocopini 证明了顺序结构、分支结构和循环结构组合在一起可以构造出任何程序。</p><blockquote><p>这也证明了构建可推导模块所需要的控制结构集与构建所有程序所需要的控制结构集的最小集是等同的。</p></blockquote><p>在这里结构化编程算是诞生了，接下来 Dijkstra 只要证明这些结构的正确性及串联起这些结构所用代码的正确性，就可以推导出整个程序的正确性。最终，在结构化编程范式下，通过数学证明和科学证伪推导出了当下程序的正确性。</p><blockquote><p>结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。</p></blockquote><p>再说说面向对象编程，什么是面向对象编程，耳熟能详的就是面向对象编程的三大特性：封装、继承和多态。这些特性并非面向对象编程语言所独有，有的特性甚至不是面向编程语言的强项，唯一值得说的特性也就只有多态了。在面向编程语言里，多态的使用变得更加安全、更加方便了。</p><p>对于面向编程的解释，有说是「面向对象编程是一种对真实世界进行建模的方式」，我觉得更贴切的说法是，「面向对象是一种对人类生活的世界进行建模的方式」。在结构化编程范式中，验证大型系统的正确性，可以通过将大型系统拆分成模块和组件，进而拆分成更小、可证明的函数并对其进行测试。现在，我们再把这个过程反过来看，这些小函数或模块、组件，又是如何高效组合成一个大型的系统呢？在这一点上，人类很擅长。</p><p>我们都知道，国外有很多唐人街，而且有些唐人街存在很久了，即使住在唐人街的华人从未来过中国，但并不妨碍与土生土长的中国人进行交流。不管相隔的多远，繁衍了多少代，只要大家还有对中华文明的认同，就不会出现无法沟通的情况。这种认同感不仅可以跨越时间和空间，更是在需要的时候凝聚力量，由此次疫情（新冠肺炎）可见一斑。</p><p>面向对象中的多态，更像是不同组件对于某种契约的认同。而基于这种认同，我们可以实现依赖反转，摆脱控制流决定源代码依赖关系的现象。</p><blockquote><p>面向对象编程就是以多态为手段来对源代码的依赖关系进行控制的能力，这种能力让软件架构师可以构造出某种插件式架构，让高层策略性组件与底层实现性组件分离，底层组件可以被编译成插件，实现独立与高层组件的开发和部署。</p></blockquote><p>至于函数式编程，它所遵循的原理倒是很简单：函数式编程语言中的变量是不可变的。</p><p>仅从<a href="https://www.yexiaochen.com/%E8%AF%BB%E3%80%8AJavaScript-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B/">读《JavaScript 轻量级函数式编程》</a>中，我们就可以看到变量的可变性带来的一些危害。鉴于此，把应用程序可分为可变和不可变的部分，将逻辑重点放在不可变组件中，并用合适的机制保护可变量。</p><p>事件溯源就很好体现出了面向函数编程的思维。</p><p>最后再用文中的话总结下三大编程范式：</p><blockquote><p>多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各种模块的算法实现基础。</p><p>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</p></blockquote><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>通过上文，我们已经知道大型的系统可以拆分为更小的函数。现在我们需要做的是，将函数和数据结构组合成模块，模块聚合成组件，组件耦合成系统。不论是模块，还是组件，抑或是其它的数据与函数的结合体，它们在某一层面上都是最小的单元。</p><p>如何高效的组装它们，就需要一个设计原则来指导它们达成最佳实践。这种思想，没有具体的模式却有明确的目标：</p><blockquote><ul><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。</li></ul></blockquote><p>在上文中，我们把编程世界类比成了人类世界。人作为社会中的人，不仅要演好自己本职角色，同时也要扮演好社会赋予的角色。所以，我们经常会听到「人在江湖，身不由己」这样的感概。而在系统中，作为不同意义上的单元，也要处理好单元内部和单元之间的问题，在这里，更多的是指处理好单元间的依赖关系。用人话说，这种「依赖」多少有点「牵连」的意思。</p><p>设计原则是什么先不说，我们先谈谈依赖关系的重要性。（以下论述从组件的角度，依赖关系大同小异）</p><p>关于组件的依赖关系并不是从一开始就需要关注的，组件依赖关系更注重的是应用程序的构建性和维护性。如果一个软件系统自搭建以来从未发生过变化，以后也不会发生变化，我们也没必要理会所谓的设计原则，即使你用了这些最佳实践，意义又何在呢。</p><blockquote><ul><li>无依赖环原则：组件依赖关系图中不应该出现环。</li><li>稳定依赖原则：依赖关系必须要指向更稳定的方向。</li><li>稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。</li></ul></blockquote><p><strong>无依赖环原则</strong>：当组件耦合在一起时，是不应该出现循环依赖关系的，这个循环中的组件会构成一个更大的组件，对于构建发布是不利的。</p><p><strong>稳定依赖原则</strong>：一个可维护的系统应该包含可变的和稳定的两部分，而且可变的应该依赖于稳定的。这种依赖是一种约束也是一种信任，反过来想想，如果不稳定的组件被稳定的组件所依赖，就意味着不稳定元素必须趋于稳定才能保证稳定组件的稳定，这种可变也将会变得难以修改。换句话说，一个组件被越多的组件所依赖，就越需要保证该组件稳定性。</p><p><strong>稳定抽象原则</strong>：这就要求稳定的组件也应该是抽象的，可变的组件也应该是具体的。再结合上一条原则，就可以概括为，依赖关系应该指向更抽象的方向。</p><p>以上内容是从组件耦合的角度对组件提出的要求，接下来回到主题。</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>任何一个软件模块都应该只对一类行为者负责。</p></blockquote><p>对于我们来说，最熟悉的就是单一职责原则了，一个函数只完成一个功能，这是单一职责在实现细节上的体现，但是这并不代表单一职责的全部。</p><p>我们先把软件模块当成数据与函数的结合体，刚开始时，当一个软件模块对多类行为者负责时，说明该软件模块能够兼容多类行为者的功能。当多类行为者的差异愈加明显时，该软件模块也会愈加频繁的调整。从稳定依赖原则中，我们已经知道，「一个组件被越多的组件所依赖，就越需要保证该组件稳定性。」</p><p>同时，这个原则也指导我们要不要去复用一个软件模块。这个软件模块对哪类行为负责？将要依赖该模块的软件模块是否属于该类行为？现在流行的微服务架构，根据不同领域的划分，即使有共同的模块，也不见得会复用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  COOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CFO</span></span><br><span class="line">Employee.CFOHours();</span><br><span class="line"></span><br><span class="line"><span class="comment">// COO</span></span><br><span class="line">Employee.COOHours();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：6.6000000000000005</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这个模块中有 `CFOHours` 和 `COOHours`，而且这两个行为共享 `regularHours`,</span></span><br><span class="line"><span class="comment">如果 CFO 的人在 COO 不知情的情况下改了 `regularHours`，定会影响到 COO。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要想避免这种情况，就应该将不同类的行为分开。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CFO = <span class="built_in">Object</span>.create(Employee);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;;</span><br><span class="line">CFO.CFOHours = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;;</span><br><span class="line">CFO.CFOHours();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> COO = <span class="built_in">Object</span>.create(Employee);</span><br><span class="line">COO.COOHours = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">` 我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">COO.COOHours();</span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote><p>接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p></blockquote><p>从字面意思上看，单一职责是从软件模块开发者的角度出发，接口隔离则是从软件模块使用者的角度去考虑。如果说单一职责是对某一类行为的划分，而这行为的划分粒度就要取决于模块的使用者。</p><p>作为前端开发者，违背接口隔离原则的反例也不少见。在项目开发中，经常会使用第三方库，有时候即使只是使用了该库的极少数方法，也需要安装该库的全部依赖，而在安装第三方库时，经常会遇到该库依赖包版本不兼容的问题导致整个项目启动崩溃，这个不兼容的依赖包所提供的方法可能压根不会用到。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">`CFOHours` 和 `COOHours` 都是对各自行为者负责，但是对于公司来说，这些又都是公司自己内部的行为。</span></span><br><span class="line"><span class="comment">本来不同类的行为也会因为使用者的不同而耦合在一起，即使如此，上面的危害依然存在，此时就需要隔离了。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ICFO = &#123;</span><br><span class="line">  regularHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICFO接口：regularHours'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICFO接口：CFOHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ICOO = &#123;</span><br><span class="line">  COOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICOO接口：COOHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == ICFO) &#123;</span><br><span class="line">      obj.CFOHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  COOHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == ICOO) &#123;</span><br><span class="line">      obj.COOHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CFO = <span class="built_in">Object</span>.create(ICFO);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;</span><br><span class="line">CFO.CFOHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.CFOHours(CFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> COO = <span class="built_in">Object</span>.create(ICOO);</span><br><span class="line">COO.COOHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;self.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.COOHours(COO)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。<br>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p></blockquote><p>这表示一个良好的系统应该是稳定的、灵活的。所谓稳定，不会因为需求小小的变动而导致系统大幅度修改。与其说抗拒修改，倒不说系统对修改的容忍程度比较高，这从组件耦合原则中可看出一二。而灵活则要求一个良好的软件系统应该在不需要修改的前提下可以轻易扩展。</p><p>开闭原则在理念上可以划分为两个派别，梅耶开闭原则和多态开闭原则。（本次只谈谈对多态开闭原则的理解）</p><blockquote><p>梅耶开闭原则：梅耶的定义提倡实现继承。具体实现可以通过继承方式来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有的接口。<br>多态开闭原则：多态开闭原则的定义倡导对抽象基类的继承。接口规约可以通过继承来重用，但是实现不必重用。已存在的接口对于修改是封闭的，并且新的实现必须，至少，实现那个接口。</p></blockquote><p>系统中包含着变化的和不变的两部分，把不变的封装起来，把变化的隔离起来。而对于变化的部分也可以求同存异，把变化中的相同部分与封装起来的不变部分约定一下，就成了实现多态的必备因素 —— 契约。实际上，这个契约应该由高级组件来定义，低级组件去遵守的，在依赖反转中有更详细的要求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> IHours = &#123;</span><br><span class="line">  logHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'IHours接口：IHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  logHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == IHours) &#123;</span><br><span class="line">      obj.logHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CFO = <span class="built_in">Object</span>.create(IHours);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;</span><br><span class="line">CFO.logHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.logHours(CFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> COO = <span class="built_in">Object</span>.create(IHours);</span><br><span class="line">COO.logHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;self.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.logHours(COO)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p>“派生类（子类）对象可以在程序中代替其基类（超类）对象。”，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件你可以相互替换。</p></blockquote><p>如果这条原则重点是在强调可替换，那就和上一条原则差不多了，这个暂时放一放。如果是说关于继承的，个人的理解是，如果子类需要覆写父类，也就没有必要从该父类去继承。</p><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><blockquote><p>依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p></blockquote><p>关于这条原则，之前的博文有专门的写过，这里也不提了。见<a href="https://yexiaochen.com/DIP%E3%80%81IoC%E3%80%81DI%E3%80%81JS/" rel="external nofollow noopener noreferrer" target="_blank">DIP、IoC、DI、JS</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上即全部内容，关于代码实现没有使用类而是基于行为委托，就是因为简单省事。设计原则就是一种思想，思想应该是灵活的，而不应该拘泥于任何一种表现形式。</p><p>参考：</p><ul><li>《架构整洁之道》</li><li>《JavaScript 设计模式与开发实践》</li><li>《你不知道的 JavaScript》</li><li><a href="https://www.cnblogs.com/nankezhishi/archive/2012/05/26/dip.html" rel="external nofollow noopener noreferrer" target="_blank">小例子背后的大道理——从DIP中“倒置”的含义说接口的正确使用</a></li></ul>]]></content>
  </entry>
  <entry>
    <title>React脚手架搭建</title>
    <url>/React%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的 <code>multi-spa-webpack-cli</code> 只是为 React + antd 模板提供了开发时必要的环境，对于实际的开发并没有什么用处。<br>为了更贴近实际开发，本次 React + antd 模板完善了一些功能。</p><ol><li>封装 <strong>fetch</strong>，新增请求错误提示；</li><li>集成 <strong>react-router-dom</strong> 路由管理；</li><li>集成 <strong>react-redux</strong> 状态管理；</li><li>必不可少的 <strong>antd</strong> 集成；</li><li><strong>node</strong> 服务集成（可选）。</li></ol><p>node 服务和 React+antd 模板是没有多大的关系的。本文只是想通过一个简单的登陆逻辑来演示以上的功能，所以 node 服务不是必须的。</p><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install multi-spa-webpack-cli -g</span><br></pre></td></tr></table></figure><p>使用步骤如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 初始化项目</span></span><br><span class="line">multi-spa-webpack-cli init spa-project</span><br></pre></td></tr></table></figure><center><br><br><img src="../images/inquirer.png" alt="inquirer"><br><br></center><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 进入文件目录</span></span><br><span class="line">cd spa-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 打包不变的部分</span></span><br><span class="line">npm run build:dll</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 启动项目（手动打开浏览器：localhost:8090）</span></span><br><span class="line">npm start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 启动服务(可选)</span></span><br><span class="line">cd server</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>预览：</p><center><br><br><img src="../images/react_antd.gif" alt="react_antd"><br><br></center><h2 id="封装-fetch"><a href="#封装-fetch" class="headerlink" title="封装 fetch"></a>封装 fetch</h2><p>现在处理异步的方式，大多数基于 Promise 的。而 fetch 是天然支持 Promise 的，所以无需再手动封装。在 PWA 技术中，已作为一个重要的组成部分在使用。<br>fetch 为人诟病的缺点之一，就是不能 Abort 请求。有方案提出提出，通过 Promise.race 的方法来模拟 timeout。实际上该执行的已然执行，只是表象上达到了预期的效果。不过浏览器现以实验性开始支持 AbortController 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; notification &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> env = process.env.NODE_ENV;</span><br><span class="line"><span class="keyword">const</span> baseURL = APP_CONFIG[env].ip;</span><br><span class="line"><span class="comment">// timeout ;</span></span><br><span class="line"><span class="comment">// const controller = new AbortController();</span></span><br><span class="line"><span class="comment">// const signal = controller.signal;</span></span><br><span class="line"><span class="keyword">const</span> defaultConfig = &#123;</span><br><span class="line">  credentials: <span class="string">'include'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Accept: <span class="string">'application/json'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// signal</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> codeMessage = &#123;</span><br><span class="line">  <span class="number">301</span>: <span class="string">'永久移动'</span>,</span><br><span class="line">  <span class="number">302</span>: <span class="string">'临时移动'</span>,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="number">504</span>: <span class="string">'网关超时。'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> checkStatus = <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> errortext = codeMessage[response.status] || response.statusText;</span><br><span class="line">  notification.error(&#123;</span><br><span class="line">    message: <span class="string">`请求错误 <span class="subst">$&#123;response.status&#125;</span>: <span class="subst">$&#123;response.url&#125;</span>`</span>,</span><br><span class="line">    description: errortext</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">Fetch</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newUrl = baseURL + url;</span><br><span class="line">  <span class="keyword">let</span> newConfig = &#123;</span><br><span class="line">    ...defaultConfig,</span><br><span class="line">    ...config</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// const timeoutId = setTimeout(() =&gt; controller.abort(), 5000);</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    newConfig.method.toLocaleLowerCase() === <span class="string">'post'</span> ||</span><br><span class="line">    newConfig.method.toLocaleLowerCase() === <span class="string">'put'</span> ||</span><br><span class="line">    newConfig.method.toLocaleLowerCase() === <span class="string">'delete'</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(newConfig.body <span class="keyword">instanceof</span> FormData)) &#123;</span><br><span class="line">      newConfig.headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json; charset=utf-8'</span>;</span><br><span class="line">      newConfig.body = <span class="built_in">JSON</span>.stringify(newConfig.body);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(newUrl, newConfig);</span><br><span class="line">    <span class="comment">// clearTimeout(timeoutId);</span></span><br><span class="line">    <span class="keyword">return</span> checkStatus(response).json();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    notification.error(&#123;</span><br><span class="line">      message: <span class="string">`请求错误 : <span class="subst">$&#123;newUrl&#125;</span>`</span>,</span><br><span class="line">      description: error.message</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成-react-router-dom-路由管理"><a href="#集成-react-router-dom-路由管理" class="headerlink" title="集成 react-router-dom 路由管理"></a>集成 <strong>react-router-dom</strong> 路由管理</h2><p>自 raect-router v4 之后，便不再支持集中式管理路由，不过也可以自己手动去实现。React + antd 模板采用的是官网推荐的方式，layouts 目录下的文件用来管理路由。</p><center><br><br><img src="../images/react-router.png" alt="集成 **react-router-dom** 路由管理"><br><br></center><h2 id="集成-react-redux-状态管理"><a href="#集成-react-redux-状态管理" class="headerlink" title="集成 react-redux 状态管理"></a>集成 <strong>react-redux</strong> 状态管理</h2><p>Redux 作为状态管理工具，除了 React，也可以用在其他地方（意思是说，和 React 没半毛钱关系）。在React中使用时，我们需要借助 React-redux 工具，这样使用起来更加方便。</p><blockquote><p>严格的单向数据流是 Redux 架构的设计核心。</p></blockquote><p>redux 数据流向：</p><p>就是把 action（行为） dispatch（丢给）reducer（更新 state）。</p><center><br><br><img src="../images/react-redux.png" alt="集成 **react-redux** 状态管理"><br><br></center><h2 id="node-服务集成（可选）"><a href="#node-服务集成（可选）" class="headerlink" title="node 服务集成（可选）"></a><strong>node</strong> 服务集成（可选）</h2><p>node 服务登陆采用的是 session 来记录状态。</p><center><br><br><img src="../images/node-server.png" alt="**node** 服务集成"><br><br></center><p>就这样，一个简单的脚手架宣告完成。</p><p>不过，这才只是个开始。</p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>CLI</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>String原型方法</title>
    <url>/String%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p><strong>String</strong>全局对象是一个用于字符串或一个字符序列的构造函数.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>除 Object 以外的所有类型都是不可变的(值本身无法被改变). JavaScript 中字符串是不可变的「JavaScript 中对字符串的操作一定返回了一个新字符串, 原始字符串并没有被改变」.</p><p>字符串字面量(通过单引号或双引号定义)和直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串. JavaScript 会自动将基本字符串转换为字符串对象, 只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'Hello, World'</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">String</span>(<span class="string">'Hello, World'</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Hello, World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a'</span>, a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>, b);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// a Hello, World</span></span><br><span class="line"><span class="comment">// b Hello, World</span></span><br><span class="line"><span class="comment">/* c String =&#123; 0: "H", 1: "e",2: "l",</span></span><br><span class="line"><span class="comment">              3: "l", 4: "o", 5: ",",</span></span><br><span class="line"><span class="comment">              6: " ", 7: "W", 8: "o", 9:</span></span><br><span class="line"><span class="comment">              r", 10: "l", 11: "d", length: 12 &#125; */</span></span><br><span class="line"><span class="comment">// 可以看到String构造出来的是一个类数组, 这样就可以通过.或[]来取值.</span></span><br></pre></td></tr></table></figure><p>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的「原始值」)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询「JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象」.</p><h2 id="原型方法-部分"><a href="#原型方法-部分" class="headerlink" title="原型方法(部分)"></a>原型方法(部分)</h2><h3 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h3><p><strong>描述</strong> :<br>从一个字符串中返回指定索引位置的字符.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.charAt(index)</code></em></p></blockquote><p><strong><code>index(可选)</code></strong> : 介于 <code>0 ~ (str.length - 1)</code> 的整数. 若无, 默认值为 0. 超过指定范围数值, 则返回空字符串.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anyString = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The character at index 0   is '"</span> + anyString.charAt()   + <span class="string">"'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The character at index 1   is '"</span> + anyString.charAt(<span class="number">1</span>)   + <span class="string">"'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The character at index 2   is '"</span> + anyString.charAt(<span class="number">2</span>)   + <span class="string">"'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"The character at index 11 is '"</span> + anyString.charAt(<span class="number">11</span>) + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The character at index 0   is 'H'</span></span><br><span class="line"><span class="comment">// The character at index 1   is 'e'</span></span><br><span class="line"><span class="comment">// The character at index 2   is 'l'</span></span><br><span class="line"><span class="comment">// The character at index 11  is ''</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h3><p><strong>描述</strong> :<br>将原字符串与多个字符串拼接成新的字符串.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.concat(string[, string1, ..., stringN])</code></em></p></blockquote><p><strong><code>stringN</code></strong> : 要拼接的字符串.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 你好世界 = <span class="string">'Hello'</span>.concat(<span class="string">' World'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好世界 = '</span>, 你好世界);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你好世界 =  Hello World</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h3><p><strong>描述</strong> :<br>将字符串的两端空白字符删除.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.trim()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1_length = <span class="string">'       Hello World !    '</span>.length;</span><br><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'       Hello World !    '</span>.trim();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1_length'</span>, str_1_length, <span class="string">'str_1'</span>, str_1, str_1.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1_length 24 str_1 Hello World ! 13</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3><p><strong>描述</strong> :<br>在字符串中匹配并替换指定字符串.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.replace(regexp|string, newString|function)</code></em></p></blockquote><p><strong><code>regexp</code></strong> : 一个 <code>RegExp</code> 对象或者其字面量.<br><strong><code>string</code></strong> : 待匹配的字符串, 仅仅是第一个匹配会被替换.<br><strong><code>newString</code></strong> : 用于取代的字符串.<br><strong><code>function</code></strong> : 每次匹配都要调用的函数.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'521521521521'</span>.replace(<span class="string">'521'</span>, <span class="string">'我爱你'</span>);</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="string">'521521521521'</span>.replace(<span class="regexp">/521/g</span>, <span class="string">'我爱你'</span>);</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="string">'521521521521'</span>.replace(<span class="regexp">/(521)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c, d</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'arguments'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (c === <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'我爱你'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_2'</span>, str_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_3'</span>, str_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments &#123; '0': '521', '1': '521', '2': 0, '3': '521521521521' &#125;</span></span><br><span class="line"><span class="comment">// arguments &#123; '0': '521', '1': '521', '2': 3, '3': '521521521521' &#125;</span></span><br><span class="line"><span class="comment">// arguments &#123; '0': '521', '1': '521', '2': 6, '3': '521521521521' &#125;</span></span><br><span class="line"><span class="comment">// arguments &#123; '0': '521', '1': '521', '2': 9, '3': '521521521521' &#125;</span></span><br><span class="line"><span class="comment">// str_1 我爱你521521521</span></span><br><span class="line"><span class="comment">// str_2 我爱你我爱你我爱你我爱你</span></span><br><span class="line"><span class="comment">// str_3 521我爱你我爱你我爱你</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p><strong>描述</strong> :<br>在字符串中指定分隔符, 并在分隔符处分割字符串.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.split([separator[, limit]])</code></em></p></blockquote><p><strong><code>separator</code></strong> : 字符串或正则表达式. 若省略, 则返回的数组包含一个由整个字符串组成的元素.<br><strong><code>limit</code></strong> : 限定返回的分割片段数量.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'Hello World'</span>.split();</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="string">'Hello World'</span>.split(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="string">'Hello World'</span>.split(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">let</span> str_4 = <span class="string">'Hello World, Hello World, Hello World'</span>.split(<span class="string">','</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> str_5 = <span class="string">'He5llo 2Worl1d'</span>.split(<span class="regexp">/\d/</span>);</span><br><span class="line"><span class="keyword">let</span> str_6 = <span class="string">'He5llo 2Worl2d'</span>.split(<span class="regexp">/(\d)/</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>,str_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_2'</span>,str_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_3'</span>,str_3);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_4'</span>,str_4);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_5'</span>,str_5);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_5'</span>,str_6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 [ 'Hello World' ]</span></span><br><span class="line"><span class="comment">// str_2 [ 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' ]</span></span><br><span class="line"><span class="comment">// str_3 [ 'Hello', 'World' ]</span></span><br><span class="line"><span class="comment">// str_4 [ 'Hello World', ' Hello World' ]</span></span><br><span class="line"><span class="comment">// str_5 [ 'He', 'llo ', 'Worl', 'd' ]</span></span><br><span class="line"><span class="comment">// str_5 [ 'He', '5', 'llo ', '2', 'Worl', '2', 'd' ]</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h3><p><strong>描述</strong> :<br>提取字符串的一部分.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.slice(begin[, end])</code></em></p></blockquote><p><strong><code>begin(可选)</code></strong> : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 <code>str.length + start</code>.<br><strong><code>end</code></strong> : 终止索引, 默认值 str.length. 不包括end位置. 如果是负数时, 规则如上.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'0123456789'</span>.slice();</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="string">'0123456789'</span>.slice(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="string">'0123456789'</span>.slice(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_2'</span>, str_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_3'</span>, str_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 0123456789</span></span><br><span class="line"><span class="comment">// str_2 9</span></span><br><span class="line"><span class="comment">// str_3 12345678</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3><p><strong>描述</strong> :<br>提取字符串的一部分.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.substring(begin[, end])</code></em></p></blockquote><p><strong><code>begin</code></strong> : 起始索引.<br><strong><code>end</code></strong> : 终止索引.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'0123456789'</span>.substring();</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="string">'0123456789'</span>.substring(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="string">'0123456789'</span>.substring(<span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_2'</span>, str_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_3'</span>, str_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 0123456789</span></span><br><span class="line"><span class="comment">// str_2 0123456</span></span><br><span class="line"><span class="comment">// str_3 0123456</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h3><p><strong>描述</strong> :<br>提取字符串的一部分.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.substr(start[, length])</code></em></p></blockquote><p><strong><code>start(可选)</code></strong> : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 <code>str.length + start</code>.<br><strong><code>length</code></strong> : 提取的字符数.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'0123456789'</span>.substr();</span><br><span class="line"><span class="keyword">let</span> str_2 = <span class="string">'0123456789'</span>.substr(<span class="number">-3</span>);</span><br><span class="line"><span class="keyword">let</span> str_3 = <span class="string">'0123456789'</span>.substr(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_2'</span>, str_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_3'</span>, str_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 0123456789</span></span><br><span class="line"><span class="comment">// str_2 789</span></span><br><span class="line"><span class="comment">// str_3 012345</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-includes"><a href="#String-prototype-includes" class="headerlink" title="String.prototype.includes()"></a>String.prototype.includes()</h3><p><strong>描述</strong> :<br>判断字符串中是否有指定字符串. 依条件返回 <code>true</code> 或 <code>false</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.includes(string[, position])</code></em></p></blockquote><p><strong><code>string</code></strong> : 需要查询的字符串.<br><strong><code>position</code></strong> : 指定查询起始位置, 默认为 0.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boolean_1 = <span class="string">'Hello World'</span>.includes(<span class="string">'World'</span>);</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="string">'Hello World'</span>.includes(<span class="string">'你好世界'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_1 = '</span>, boolean_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_2 = '</span>, boolean_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean_1 =  true</span></span><br><span class="line"><span class="comment">// boolean_2 =  false</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-startsWith"><a href="#String-prototype-startsWith" class="headerlink" title="String.prototype.startsWith()"></a>String.prototype.startsWith()</h3><p><strong>描述</strong> :<br>判断字符串是否以指定字符串开头. 依条件返回 <code>true</code> 或 <code>false</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.startsWith(string[, position])</code></em></p></blockquote><p><strong><code>string</code></strong> : 需要查询的字符串.<br><strong><code>position</code></strong> : 指定字符串开头的位置, 默认值为 <code>0</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boolean_1 = <span class="string">'123456789'</span>.startsWith(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="string">'123456789'</span>.startsWith(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> boolean_3 = <span class="string">'123456789'</span>.startsWith(<span class="number">7</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_1'</span>, boolean_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_2'</span>, boolean_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_3'</span>, boolean_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean_1 true</span></span><br><span class="line"><span class="comment">// boolean_2 false</span></span><br><span class="line"><span class="comment">// boolean_3 true</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-endsWith"><a href="#String-prototype-endsWith" class="headerlink" title="String.prototype.endsWith()"></a>String.prototype.endsWith()</h3><p><strong>描述</strong> :<br>判断字符串是否以指定字符串结尾. 依条件返回 <code>true</code> 或 <code>false</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.endsWith(string[, position])</code></em></p></blockquote><p><strong><code>string</code></strong> : 需要查询的字符串.<br><strong><code>position</code></strong> : 指定字符串结尾的位置(字符串的长度), 默认值为 <code>str.length</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boolean_1 = <span class="string">'123456789'</span>.endsWith(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> boolean_2 = <span class="string">'123456789'</span>.endsWith(<span class="number">9</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> boolean_3 = <span class="string">'123456789'</span>.endsWith(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_1'</span>, boolean_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_2'</span>, boolean_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'boolean_3'</span>, boolean_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean_1 true</span></span><br><span class="line"><span class="comment">// boolean_2 false</span></span><br><span class="line"><span class="comment">// boolean_3 true</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-indexOf"><a href="#String-prototype-indexOf" class="headerlink" title="String.prototype.indexOf()"></a>String.prototype.indexOf()</h3><p><strong>描述</strong> :<br>查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 <code>-1</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.indexOf(string[, position])</code></em></p></blockquote><p><strong><code>string</code></strong> : 需要查询的字符串.<br><strong><code>position</code></strong> : 首次被找到的元素在数组中的索引位置, 默认值为 <code>0</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pos_1 = <span class="string">'0123456789'</span>.indexOf(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">let</span> pos_2 = <span class="string">'0123456789'</span>.indexOf(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> pos_3 = <span class="string">'0123456789'</span>.indexOf(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_1'</span>, pos_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_2'</span>, pos_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_3'</span>, pos_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos_1 8</span></span><br><span class="line"><span class="comment">// pos_2 -1</span></span><br><span class="line"><span class="comment">// pos_3 8</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-lastIndexOf"><a href="#String-prototype-lastIndexOf" class="headerlink" title="String.prototype.lastIndexOf()"></a>String.prototype.lastIndexOf()</h3><p><strong>描述</strong> :<br>从字符串的后面向前查找, 查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 <code>-1</code>.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.lastIndexOf(string[, position])</code></em></p></blockquote><p><strong><code>string</code></strong> : 需要查询的字符串.<br><strong><code>position</code></strong> : 逆向查找起始索引, 默认值 <code>str.length - 1</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pos_1 = <span class="string">'0123456789'</span>.lastIndexOf(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> pos_2 = <span class="string">'0123456789'</span>.lastIndexOf(<span class="number">9</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> pos_3 = <span class="string">'0123456789'</span>.lastIndexOf(<span class="number">9</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_1'</span>, pos_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_2'</span>, pos_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_3'</span>, pos_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos_1 9</span></span><br><span class="line"><span class="comment">// pos_2 9</span></span><br><span class="line"><span class="comment">// pos_3 -1</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p><strong>描述</strong> :<br>字符串检索匹配正则表达式.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.match(regexp)</code></em></p></blockquote><p><strong><code>regexp</code></strong> : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : <code>[&quot;&quot;]</code>.<br><strong><code>返回值</code></strong> : 如果字符串匹配到了表达式, 会返回一个数组, 数组的第一项是进行匹配完整的字符串, 之后的项是用圆括号捕获的结果. 如果没有匹配到, 返回null.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pos_1 = <span class="string">'0123456789'</span>.match(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> pos_2 = <span class="string">'0123456789'</span>.match(<span class="regexp">/8\d+/</span>);</span><br><span class="line"><span class="keyword">let</span> pos_3 = <span class="string">'0123456789'</span>.match(<span class="regexp">/7\d&#123;1&#125;/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_1'</span>, pos_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_2'</span>, pos_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_3'</span>, pos_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos_1 [ '9', index: 9, input: '0123456789' ]</span></span><br><span class="line"><span class="comment">// pos_2 [ '89', index: 8, input: '0123456789' ]</span></span><br><span class="line"><span class="comment">// pos_3 [ '78', index: 7, input: '0123456789' ]</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h3><p><strong>描述</strong> :<br>字符串检索匹配正则表达式.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.search(regexp)</code></em></p></blockquote><p><strong><code>regexp</code></strong> : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : <code>[&quot;&quot;]</code>.<br><strong><code>返回值</code></strong> : 如果匹配成功, 则 search() 返回正则表达式在字符串中首次匹配项的索引. 否则, 返回 -1.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pos_1 = <span class="string">'0123456789'</span>.search(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">let</span> pos_2 = <span class="string">'0123456789'</span>.search(<span class="regexp">/8\d+/</span>);</span><br><span class="line"><span class="keyword">let</span> pos_3 = <span class="string">'0123456789'</span>.search(<span class="regexp">/7\d&#123;1&#125;/</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_1'</span>, pos_1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_2'</span>, pos_2);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'pos_3'</span>, pos_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pos_1 9</span></span><br><span class="line"><span class="comment">// pos_2 8</span></span><br><span class="line"><span class="comment">// pos_3 7</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-toLowerCase"><a href="#String-prototype-toLowerCase" class="headerlink" title="String.prototype.toLowerCase()"></a>String.prototype.toLowerCase()</h3><p><strong>描述</strong> :<br>将字符串转换成小写形式.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.toLowerCase()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'Hello World !'</span>.toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 hello world !</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-toUpperCase"><a href="#String-prototype-toUpperCase" class="headerlink" title="String.prototype.toUpperCase()"></a>String.prototype.toUpperCase()</h3><p><strong>描述</strong> :<br>将字符串转换成大写形式.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.toUpperCase()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="string">'Hello World !'</span>.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 HELLO WORLD !</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-toString"><a href="#String-prototype-toString" class="headerlink" title="String.prototype.toString()"></a>String.prototype.toString()</h3><p><strong>描述</strong> :<br>将指定对象转换成字符串形式.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.toString()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str_1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Hello World !'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1, <span class="string">'str_1.toString()'</span>, str_1.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 [String: 'Hello World !'] str_1.toString() Hello World !(不同浏览器展现效果可能不同)</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-valueOf"><a href="#String-prototype-valueOf" class="headerlink" title="String.prototype.valueOf()"></a>String.prototype.valueOf()</h3><p><strong>描述</strong> :<br>返回一个String对象的原始值（primitive value）.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.valueOf()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Hello World!'</span>);</span><br><span class="line"><span class="keyword">let</span> str_1 = str.valueOf();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 Hello World!</span></span><br></pre></td></tr></table></figure><h3 id="String-prototype-iterator"><a href="#String-prototype-iterator" class="headerlink" title="String.prototype[@@iterator]()"></a>String.<code>prototype[@@iterator]()</code></h3><p><strong>描述</strong> :<br>返回一个String对象的原始值（primitive value）.<br><strong>语法</strong> :</p><blockquote><p><em><code>str.valueOf()</code></em></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="keyword">let</span> str_1 = str[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str_1'</span>, str_1.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">// str_1 &#123; value: 'H', done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'item'</span>, item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// item H</span></span><br><span class="line"><span class="comment">// item e</span></span><br><span class="line"><span class="comment">// item l</span></span><br><span class="line"><span class="comment">// item l</span></span><br><span class="line"><span class="comment">// item o</span></span><br><span class="line"><span class="comment">// item</span></span><br><span class="line"><span class="comment">// item W</span></span><br><span class="line"><span class="comment">// item o</span></span><br><span class="line"><span class="comment">// item r</span></span><br><span class="line"><span class="comment">// item l</span></span><br><span class="line"><span class="comment">// item d</span></span><br><span class="line"><span class="comment">// item !</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>字符串原型</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code使用基础</title>
    <url>/VS-Code%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>工欲善其事, 必先利其器. 作为一个前端程序猿打造一个好看好用的编辑器, 对于工作效率的提高有很大的帮助.<br><img src="../images/VSCode.png" alt="VS Code"></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>字体选用的<a href="https://github.com/tonsky/FiraCode" rel="external nofollow noopener noreferrer" target="_blank">FiraCode</a>, 下载安装然后参见<a href="https://github.com/tonsky/FiraCode/wiki/VS-Code-Instructions" rel="external nofollow noopener noreferrer" target="_blank">VS Code Instructions相关设置</a>. 其它好看的字体还有Source Code Pro等.</p><hr><h2 id="颜色主题和文件图标主题"><a href="#颜色主题和文件图标主题" class="headerlink" title="颜色主题和文件图标主题"></a>颜色主题和文件图标主题</h2><p>颜色主题选用的是<code>One Dark Pro</code>. 编辑器内置了几款颜色主题, 如果没有喜欢的就在扩展主题里找找.<br>文件图标主题配置同颜色主题配置.<br><img src="../images/colorThemes.gif" alt="color-theme"></p><hr><h1 id="用户设置"><a href="#用户设置" class="headerlink" title="用户设置"></a>用户设置</h1><h2 id="Commonly-Used"><a href="#Commonly-Used" class="headerlink" title="Commonly Used"></a>Commonly Used</h2><table><thead><tr><th style="text-align:center">控制字段</th><th style="text-align:center">控制内容</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>files.autoSave</code></strong></td><td style="text-align:center">自动保存</td></tr><tr><td style="text-align:center"><strong><code>editor.tabSize</code></strong></td><td style="text-align:center">制表符的空格数</td></tr><tr><td style="text-align:center"><strong><code>editor.renderWhitespace</code></strong></td><td style="text-align:center">空白字符显示方式</td></tr><tr><td style="text-align:center"><strong><code>editor.wordWrap</code></strong></td><td style="text-align:center">换行方式</td></tr><tr><td style="text-align:center"><strong><code>files.exclude</code></strong></td><td style="text-align:center">配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.</td></tr><tr><td style="text-align:center"><strong><code>files.associations</code></strong></td><td style="text-align:center">配置语言的文件关联. eg:<em><code>&quot;**.jsp&quot;: &quot;javascript&quot;</code></em></td></tr><tr><td style="text-align:center"><strong><code>files.trimTrailingWhitespace</code></strong></td><td style="text-align:center">启用后，将在保存文件时剪裁尾随空格</td></tr><tr><td style="text-align:center"><strong><code>workbench.editor.labelFormat</code></strong></td><td style="text-align:center">控制编辑器标签的格式</td></tr><tr><td style="text-align:center"><strong><code>window.openFilesInNewWindow</code></strong></td><td style="text-align:center">控制是否在新窗口中打开文件</td></tr><tr><td style="text-align:center"><strong><code>terminal.integrated.shell.osx</code></strong></td><td style="text-align:center">终端在 macOS 上使用的 Shell 的路径</td></tr><tr><td style="text-align:center"><strong><code>breadcrumbs.enabled</code></strong></td><td style="text-align:center">启用/禁用导航路径(面包屑)</td></tr><tr><td style="text-align:center"><strong><code>emmet.includeLanguages</code></strong></td><td style="text-align:center">在默认不支持 Emmet 的语言中启用 Emmet 缩写功能. eg:<em><code>&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;</code></em></td></tr></tbody></table><hr><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><table><thead><tr><th style="text-align:center">控制字段</th><th style="text-align:center">控制内容</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>editor.formatOnType</code></strong></td><td style="text-align:center">控制编辑器在键入一行后是否自动格式化该行</td></tr><tr><td style="text-align:center"><strong><code>editor.minimap.enabled</code></strong></td><td style="text-align:center">是否显示小地图</td></tr><tr><td style="text-align:center"><strong><code>editor.mouseWheelZoom</code></strong></td><td style="text-align:center">按住 <code>Ctrl</code> 键并滚动鼠标滚轮时对编辑器字体大小进行缩放</td></tr><tr><td style="text-align:center"><strong><code>editor.parameterHints.enabled</code></strong></td><td style="text-align:center">在输入时显示含有参数文档和类型信息的小面板</td></tr><tr><td style="text-align:center"><strong><code>files.exclude</code></strong></td><td style="text-align:center">配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.</td></tr><tr><td style="text-align:center"><strong><code>files.associations</code></strong></td><td style="text-align:center">配置语言的文件关联. eg:<em>`”</em>.jsp”: “javascript”`*</td></tr></tbody></table><hr><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">快捷键</th></tr></thead><tbody><tr><td style="text-align:center"><strong><code>删除行</code></strong></td><td style="text-align:center"><em><code>cmd + D</code></em></td></tr><tr><td style="text-align:center"><strong><code>合并行</code></strong></td><td style="text-align:center"><em><code>ctrl + J</code></em></td></tr><tr><td style="text-align:center"><strong><code>光标后退</code></strong></td><td style="text-align:center"><em><code>ctrl + _</code></em></td></tr><tr><td style="text-align:center"><strong><code>光标前进</code></strong></td><td style="text-align:center"><em><code>ctrl + shift + _</code></em></td></tr><tr><td style="text-align:center"><strong><code>向下面插入行</code></strong></td><td style="text-align:center"><em><code>cmd + enter</code></em></td></tr><tr><td style="text-align:center"><strong><code>向上面插入行</code></strong></td><td style="text-align:center"><em><code>cmd + shift + enter</code></em></td></tr><tr><td style="text-align:center"><strong><code>转到文件</code></strong></td><td style="text-align:center"><em><code>cmd + P</code></em></td></tr><tr><td style="text-align:center"><strong><code>显示所有命令</code></strong></td><td style="text-align:center"><em><code>cmd + shift + P</code></em></td></tr><tr><td style="text-align:center"><strong><code>文件查找</code></strong></td><td style="text-align:center"><em><code>cmd + F</code></em></td></tr><tr><td style="text-align:center"><strong><code>全局搜索</code></strong></td><td style="text-align:center"><em><code>cmd + shift + F</code></em></td></tr><tr><td style="text-align:center"><strong><code>切换行注释</code></strong></td><td style="text-align:center"><em><code>cmd + /</code></em></td></tr><tr><td style="text-align:center"><strong><code>切换块注释</code></strong></td><td style="text-align:center"><em><code>shift + alt + A</code></em></td></tr><tr><td style="text-align:center"><strong><code>撤销</code></strong></td><td style="text-align:center"><em><code>cmd + Z</code></em></td></tr><tr><td style="text-align:center"><strong><code>恢复撤销</code></strong></td><td style="text-align:center"><em><code>cmd + shift + Z</code></em></td></tr><tr><td style="text-align:center"><strong><code>缩进</code></strong></td><td style="text-align:center"><em><code>tab</code></em></td></tr><tr><td style="text-align:center"><strong><code>缩进</code></strong></td><td style="text-align:center"><em><code>shift + tab</code></em></td></tr><tr><td style="text-align:center"><strong><code>移动到行尾</code></strong></td><td style="text-align:center"><em><code>cmd + right</code></em></td></tr><tr><td style="text-align:center"><strong><code>移动到行首</code></strong></td><td style="text-align:center"><em><code>cmd + left</code></em></td></tr><tr><td style="text-align:center"><strong><code>向上移动行</code></strong></td><td style="text-align:center"><em><code>cmd + up</code></em></td></tr><tr><td style="text-align:center"><strong><code>向下移动行</code></strong></td><td style="text-align:center"><em><code>cmd + down</code></em></td></tr><tr><td style="text-align:center"><strong><code>保持打开状态(workbench.action.keepEditor)</code></strong></td><td style="text-align:center"><em><code>cmd + K enter</code></em></td></tr><tr><td style="text-align:center"><strong><code>打开集成终端</code></strong></td><td style="text-align:center"><em><code>ctrl + `</code></em></td></tr><tr><td style="text-align:center"><strong><code>集成终端清屏</code></strong></td><td style="text-align:center"><em><code>cmd + K</code></em></td></tr><tr><td style="text-align:center"><strong><code>格式化文件</code></strong></td><td style="text-align:center"><em><code>shift + alt + F</code></em></td></tr></tbody></table><hr><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p><img src="../images/windows.gif" alt="窗口操作"></p><hr><h2 id="code命令"><a href="#code命令" class="headerlink" title="code命令"></a>code命令</h2><p>VS Code快速打开文件夹或文件,可以将其直接拖至VS Code图标上. 或<code>cmd + shift + P</code>打开命令面板, 向Path添加<code>code</code>, 用<code>code</code>命令操作.<br><img src="../images/codeCommand.gif" alt="codeCommand"></p><hr><h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><p><img src="../images/fileComparison.gif" alt="文件对比"></p><hr><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>可以将其它项目与当前项目置于同一工作区, 在同一个窗口查看编辑.<br><img src="../images/workplace.gif" alt="工作区"></p><hr><h2 id="自定义终端"><a href="#自定义终端" class="headerlink" title="自定义终端"></a>自定义终端</h2><p>在<a href="https://www.yexiaochen.com/Mac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0/">Mac终端改造</a>里, 已经打造好了个性化的终端了. 在VS Code里只需要换个路径即可.<br>在用户设置里用以下配置覆盖.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"terminal.integrated.shell.osx"</span>: <span class="string">"/bin/zsh"</span>,</span><br></pre></td></tr></table></figure><p><img src="../images/terminal.gif" alt="自定义终端"></p><hr><h2 id="添加自定义snippet"><a href="#添加自定义snippet" class="headerlink" title="添加自定义snippet"></a>添加自定义snippet</h2><p>VS Code内置了自定义snippet功能, 用户可以根据自己的需求去添加自己想要的代码段, 灵活且方便, 这样就完全没有必要去安装类似的插件了. 细节可参考<a href="https://juejin.im/entry/5aebc727f265da0b9526f54e" rel="external nofollow noopener noreferrer" target="_blank">[VS Code]跟我一起在Visual Studio Code 添加自定义snippet（代码段），附详细配置</a>.<br><img src="../images/snippet.gif" alt="自定义代码段"></p><hr><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="Chinese-Simplified-Language-Pack-for-VS-Code"><a href="#Chinese-Simplified-Language-Pack-for-VS-Code" class="headerlink" title="Chinese (Simplified) Language Pack for VS Code"></a>Chinese (Simplified) Language Pack for VS Code</h2><p>此中文（简体）语言包为 VS Code 提供本地化界面.</p><hr><h2 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h2><p>在代码中做标记, 可以在不同的标记中快速便捷的切换.</p><hr><h2 id="Auto-Rename-Tag"><a href="#Auto-Rename-Tag" class="headerlink" title="Auto Rename Tag"></a>Auto Rename Tag</h2><p>修改HTML/XML标签时, 首尾标签会自动同步更改.</p><hr><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>一个开源的 JavaScript 代码检查插件, 可以在编写或保存文件时对文件进行检测. 根据规则配置文件对文件进行检测提示, 并可以自动修复部分不符合规则的部分.</p><ul><li><code>&quot;eslint.options&quot;: { &quot;configFile&quot;: &quot;**/**/**&quot; }</code> : 本地的配置文件地址路径.</li><li><code>eslint.validate</code>: 可被识别的文件类型.</li><li><code>eslint.autoFixOnSave</code>: 保存时自动修复.</li></ul><hr><h2 id="Debugger-for-Chrome"><a href="#Debugger-for-Chrome" class="headerlink" title="Debugger for Chrome"></a>Debugger for Chrome</h2><p>在代码里断点, 就是相对地知道文件在哪里吧, Chrome里打断点还是挺好用地. Debugger for Chrome 配置可参见<a href="https://github.com/Microsoft/vscode-recipes" rel="external nofollow noopener noreferrer" target="_blank">官网例子</a>.<br><img src="../images/debuggerForChrome.gif" alt="DebuggerForChrome"></p><hr><p>插件什么的真的不见得能提高多少效率, 讲真, 颜值才是正义, 颜值才是王道🤔.</p>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Visual Studio Code</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome使用姿势（extensions+flags）</title>
    <url>/chrome%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%EF%BC%88extensions-flags%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h1><h2 id="chrome-chrome-urls"><a href="#chrome-chrome-urls" class="headerlink" title="chrome://chrome-urls/"></a>chrome://chrome-urls/</h2><p><img src="../images/chrome-urls.png" alt="chrome-urls.png"></p><p>常用 urls：</p><ul><li><a href="chrome://apps/" rel="external nofollow noopener noreferrer" target="_blank">chrome://apps/</a>：网上应用商店</li><li><a href="chrome://inspect/#devices" rel="external nofollow noopener noreferrer" target="_blank">chrome://inspect/#devices</a>：调试用</li><li><a href="chrome://flags/" rel="external nofollow noopener noreferrer" target="_blank">chrome://flags/</a>：实验性功能</li><li><a href="chrome://net-internals" rel="external nofollow noopener noreferrer" target="_blank">chrome://net-internals</a>：安全协议配置，可用于开发环境 http =&gt; https 导致的问题</li><li><a href="chrome://management/" rel="external nofollow noopener noreferrer" target="_blank">chrome://management/</a>：查看是够处于托管状态</li><li><a href="chrome://restart/" rel="external nofollow noopener noreferrer" target="_blank">chrome://restart/</a>：重启</li></ul><h2 id="chrome-extensions"><a href="#chrome-extensions" class="headerlink" title="chrome://extensions/"></a>chrome://extensions/</h2><p><img src="../images/chrome-extensions.png" alt="chrome-extensions"></p><h3 id="switchyOmega"><a href="#switchyOmega" class="headerlink" title="switchyOmega"></a>switchyOmega</h3><p><img src="../images/switchyOmega-auto.png" alt="switchyOmega-auto"></p><p><img src="../images/switchyOmega-proxy.png" alt="switchyOmega-proxy"></p><h2 id="chrome-flags"><a href="#chrome-flags" class="headerlink" title="chrome://flags/"></a>chrome://flags/</h2><p><img src="../images/chrome-79-flags.png" alt="chrome-79-flags"></p><ul><li><p><a href="chrome://flags/#extensions-toolbar-menu" rel="external nofollow noopener noreferrer" target="_blank">Extensions Toolbar Menu</a>：类似于拓展插件管理</p></li><li><p><a href="chrome://flags/#tab-groups" rel="external nofollow noopener noreferrer" target="_blank">Tab Groups</a>：标签页群组管理</p></li><li><p><a href="chrome://flags/#tab-hover-cards" rel="external nofollow noopener noreferrer" target="_blank">Tab Hover Cards</a>：标签悬浮显示当前网页简介</p></li><li><p><a href="chrome://flags/#tab-hover-card-images" rel="external nofollow noopener noreferrer" target="_blank">Tab Hover Card Images</a>：配合上个特性，以显示当前网页缩略图</p><p>效果图：</p><p><img src="../images/chrome-flags-display.png" alt="chrome-flags-display"></p></li><li><p><a href="chrome://flags/#proactive-tab-freeze" rel="external nofollow noopener noreferrer" target="_blank">Tab Freeze</a>：中止资源的占用</p></li><li><p><a href="chrome://flags/#focus-mode" rel="external nofollow noopener noreferrer" target="_blank">Focus Mode</a>：聚焦当前标签</p></li></ul>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Chrome 拓展插件</tag>
        <tag>Chrome 实验性功能</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose安装gitlab</title>
    <url>/docker-gitlab/</url>
    <content><![CDATA[<h2 id="日常吐槽"><a href="#日常吐槽" class="headerlink" title="日常吐槽"></a>日常吐槽</h2><p>前端工程化，个人认为就是通过工具减少程序员们的手动操作，从而提高生产力。还有一个就是，减小人在产品开发到上线整个流程的参与度，从而减小 bug 率。毕竟在琐碎繁复的操作中，人难免会出现失误。</p><p>gitlab 倒是一个很好的工具，可以管理代码，也可以实现持续集成、持续交付、持续部署等。本次的实践也只是通过 docker-compose 安装了 gitlab，顶多只是作为代码托管平台。CI/CD 除了 gitlab 可以完成，还有一些有名的 Jekins，Travis等。</p><p>本来打算用 gitlab 来完成这些功能，但是相关的知识储备还是有些欠缺。而且，就目前规划来看，继续深入 gitlab 并不划算。所以，这算是在此挖坑，等哪天时机成熟，再来补上这个技术债。</p><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><p>在使用 gitlab 之前，不得不提 Git 工作流。Git 是版本控制系统，而 gitlab 是基于 Git 的代码托管服务。在团队协作时，为了更好的管理代码，就应该制定一个代码提交规范 —— Git 工作流程。<br>目前广泛使用的工作流程有：</p><ol><li>Git flow</li><li>github flow</li><li>gitlab flow</li></ol><p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/git-flow" rel="external nofollow noopener noreferrer" target="_blank">Git flow</a>：</p><center><br><br><img src="../images/git_flow.png" alt="git_flow"><br><br></center><p><a href="https://guides.github.com/introduction/flow/" rel="external nofollow noopener noreferrer" target="_blank">github fow</a>:</p><center><br><br><img src="../images/github_flow.png" alt="github_flow"><br><br></center><p><a href="https://docs.gitlab.com/ee/workflow/gitlab_flow.html" rel="external nofollow noopener noreferrer" target="_blank">gitlab fow</a>:</p><center><br><br><img src="../images/gitlab_flow.png" alt="gitlab_flow"><br><br></center><p>三种工作流各有特点,但也并非一成不变，要根据场景制定最佳工作流。</p><h2 id="docker-compose安装Gitlab"><a href="#docker-compose安装Gitlab" class="headerlink" title="docker-compose安装Gitlab"></a>docker-compose安装Gitlab</h2><p>安装 gitlab 的方法有很多，就仅仅是使用 gitlab 的 Docker 镜像安装，官方就提供了三种方法<a href="https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose" rel="external nofollow noopener noreferrer" target="_blank">GitLab Docker images</a>。不过，个人认为，最为方便的还是使用 docker-compose。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">web:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">'gitlab/gitlab-ce:latest'</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">'gitlab.example.com'</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">      <span class="string">external_url</span> <span class="string">'https://gitlab.example.com'</span></span><br><span class="line">      <span class="comment"># Add any other gitlab.rb configuration here, each on its own line</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'8090:8090'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'443:443'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'22:22'</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'./srv/gitlab/config:/etc/gitlab'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'./srv/gitlab/logs:/var/log/gitlab'</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'./srv/gitlab/data:/var/opt/gitlab'</span></span><br></pre></td></tr></table></figure><ul><li><p>hostname、external_url: 用来制定域名，不过需要在 host 文件中完成 ip 映射。</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">127.0.0.0  https://gitlab.example.com</span><br></pre></td></tr></table></figure></li><li><p>ports: 暴露了容器的三个端口, 分别是 https 对应的 443, http 对应8 090 以及 ssh 对应的 22 (如果不需要配置https, 可以不暴露)</p></li><li>volumes: 指定挂载目录, 这个便于我们在本地备份和修改容器的相关数据</li></ul><p>然后执行 <code>docker-compose up -d</code> 命令就可以后台运行 gitlab 了。（-d 后台运行）<br>第一次登陆时需要设置管理员密码。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li><code>gitlab Error executing action &#39;create&#39; on resource ...</code></li></ul><p>原因：没有相关权限。<br>解决方案： <code>sudo docker-compose up -d</code>。</p><ul><li><code>gitlab 500 Internal Privoxy Error</code></li></ul><p>原因：本机开了代理。</p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>git工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack开发环境配置</title>
    <url>/webpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="日常吐槽"><a href="#日常吐槽" class="headerlink" title="日常吐槽"></a>日常吐槽</h2><p>经过不断的调整和测试，关于 react 的 webpack 配置终于新鲜出炉。本次的重点主要集中在开发环境上，生产环境则是使用 webpack 的 production 默认模式。</p><p>本次配置主要有：</p><ol><li><p><strong>eslint+prettier</strong>;</p></li><li><p><strong>optimization.splitChunks</strong>;</p></li><li><p><strong>happypack</strong>;</p></li><li><p><strong>DllReferencePlugin &amp; DllPlugin</strong>;</p></li><li><p>…</p></li></ol><h2 id="文档的重要性"><a href="#文档的重要性" class="headerlink" title="文档的重要性"></a>文档的重要性</h2><p>讲真，对于初次接触 webpack 的同学，怕的可能不是 webpack 的配置，而是长长的 package.json。依赖那么多，你怎么就知道需要哪些依赖呢。不开玩笑，我还真知道。<br>webpack 的依赖主要是一些 loader 和 plugins。我们知道单页面应用被打包后，原有的结构基本上不复存在了。而之前引用的图片或字体资源还按照之前的路径查找，肯定是找不到的。那么我们就需要转换工具（顺便转换资源）—— <code>url-loader</code>|<code>file-loader</code>。<br>大多数人写样式时，喜欢使用 css、less、sass。这时也会有对应的工具 <code>style-loader</code>, <code>css-loader</code>, <code>less-loader</code>。<br>想要使用 JavaScript 新特性或处理兼容性，就用 <code>babel-loader</code>。以上这些基本上可以应付一些简单的项目。可实际上呢？</p><blockquote><p>我信你个鬼，你这个糟老头坏的很！</p></blockquote><p>看文档啊，看官方介绍啊。本次也是通过看 babel 文档，和一些依赖文档来配置 webpack 的，全程无压力，而且很正宗。所以，文档很重要。</p><h2 id="eslint-prettier"><a href="#eslint-prettier" class="headerlink" title="eslint+prettier"></a>eslint+prettier</h2><p>如果时团队合作，代码规范是很重要的。可以通过 eslint+prettier 规范。这两个工具各有侧重点，不过官网也提供了两者结合的方案。详细介绍见官网。我个人不习惯创建太多的配置文件，所以都放在了 package.json 文件中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  webpack.common.js</span></span><br><span class="line">&#123;</span><br><span class="line">    enforce: <span class="string">"pre"</span>,</span><br><span class="line">    test: <span class="regexp">/\.m?jsx?$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        fix: <span class="literal">true</span>,</span><br><span class="line">        cache: <span class="literal">true</span>,</span><br><span class="line">        formatter: <span class="built_in">require</span>(<span class="string">"eslint-friendly-formatter"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"eslintConfig": &#123;</span><br><span class="line">    "parser": "babel-eslint",</span><br><span class="line">    "env": &#123;</span><br><span class="line">        "browser": true,</span><br><span class="line">        "es6": true,</span><br><span class="line">        "node": true</span><br><span class="line">    &#125;,</span><br><span class="line">    "parserOptions": &#123;</span><br><span class="line">        "ecmaVersion": 6,</span><br><span class="line">        "sourceType": "module"</span><br><span class="line">    &#125;,</span><br><span class="line">    "extends": [</span><br><span class="line">        <span class="string">"plugin:prettier/recommended"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br><span class="line">"prettier": &#123;</span><br><span class="line">    "singleQuote": true,</span><br><span class="line">    "semi": true</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>开发环境没什么好说的了，简单易配置，官网很详细。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"></span><br><span class="line">plugins: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">&#125;,</span><br><span class="line">devtool: <span class="string">"eval-source-map"</span>,</span><br><span class="line">devServer: &#123;</span><br><span class="line">contentBase: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dist'</span>),</span><br><span class="line">port: APP_CONFIG.port,</span><br><span class="line">hot: <span class="literal">true</span>,</span><br><span class="line">open: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 入口处要配置这些，别忘了。</span></span><br><span class="line"><span class="comment">// 因为有冒泡的机制，所以在顶端加一个就好。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./views/login/index.js'</span>, () =&gt; &#123;</span><br><span class="line">    render(App) <span class="comment">// 渲染应用</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="optimization-splitChunks"><a href="#optimization-splitChunks" class="headerlink" title="optimization.splitChunks"></a>optimization.splitChunks</h2><p>这个配置是用来分割包的。在性能优化上，请求数和请求包的大小也是很重要的优化点。请求数量和请求数据大小要控制在合理的范围内。<br>不过通常情况下，我们会将包分割为内容不变的部分和内容变化的部分。这不仅仅是为了将大的包分割成更小的包，也是为了能够充分利用缓存机制。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line">runtimeChunk: <span class="string">'single'</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        cacheGroups: &#123;</span><br><span class="line">        verdor: &#123;</span><br><span class="line">            test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">            name: <span class="string">'verdors'</span>,</span><br><span class="line">            chunks: <span class="string">'all'</span>,</span><br><span class="line">            priority: <span class="number">-10</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        common: &#123;</span><br><span class="line">            name: <span class="string">'common'</span>,</span><br><span class="line">            chunks: <span class="string">'all'</span>,</span><br><span class="line">            minChunks: <span class="number">2</span>,</span><br><span class="line">            priority: <span class="number">-20</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h2><p>转换文件算是打包过程中比较耗时的事情，通过 happypack 可以将这件事分摊给多个 node 进程，这样就会大大缩短了打包时间（同理，可以考虑使用 <code>thread-loader</code>）。不过进程之间的通信是要开销的，这是一个优化方向，要不要采用，还需要酌情考虑。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.m?jsx?$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    use: <span class="string">'happypack/loader?id=js'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// plugins</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'js'</span>,</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    loaders: [&#123;</span><br><span class="line">    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">        cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">        presets: [[<span class="string">'@babel/preset-env'</span>, &#123;</span><br><span class="line">        <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span>,</span><br><span class="line">        <span class="string">"corejs"</span>: <span class="number">3</span></span><br><span class="line">        &#125;], <span class="string">"@babel/preset-react"</span>],</span><br><span class="line">        plugins: [<span class="string">'@babel/transform-runtime'</span>,</span><br><span class="line">        <span class="string">"@babel/plugin-proposal-class-properties"</span>, [</span><br><span class="line">            <span class="string">"import"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">"libraryName"</span>: <span class="string">"antd"</span>,</span><br><span class="line">            <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不喜欢单独的 babel 文件，所以 babel 的配置都在这里了。其实，关于 babel 要配置的内容还是挺多的。不过不要怕，babel 的官方文档有详细说明。</p><h2 id="DllReferencePlugin-amp-DllPlugin"><a href="#DllReferencePlugin-amp-DllPlugin" class="headerlink" title="DllReferencePlugin &amp; DllPlugin"></a>DllReferencePlugin &amp; DllPlugin</h2><p>之前也提到过，通常我们会使用 <code>optimization.splitChunks</code> 来处理第三方库，将其分割成不变的部分。可是，每次打包的时候都需要重复这一步骤。<br>这时候我们就想啊，不变的部分打包一次不就可以了么，之后就只打包那些经常变化的部分，这样不就能提高效率了么？是的， <code>DllReferencePlugin &amp; DllPlugin</code> 基本上要做的就是这么一回事。所以，我们会针对这两部分做不同的配置。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">    context: process.cwd(),</span><br><span class="line">    path: path.join(__dirname, <span class="string">'..'</span>, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">    name: <span class="string">'[name]_[hash]'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    context: process.cwd(), </span><br><span class="line">    manifest: <span class="built_in">require</span>(path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dist'</span>, <span class="string">'dll'</span>, <span class="string">"vendor-manifest.json"</span>))</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h2 id="multi-spa-webpack-cli使用说明"><a href="#multi-spa-webpack-cli使用说明" class="headerlink" title="multi-spa-webpack-cli使用说明"></a>multi-spa-webpack-cli使用说明</h2><p><code>multi-spa-webpack-cli</code> 已经发布到 npm，只要在 node 环境下安装即可。<strong>一路按 Enter，全部源码都在里面！！！</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install multi-spa-webpack-cli -g</span><br></pre></td></tr></table></figure><p>使用步骤如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 初始化项目</span></span><br><span class="line">multi-spa-webpack-cli init spa-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 进入文件目录</span></span><br><span class="line">cd spa-project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 打包不变的部分</span></span><br><span class="line">npm run build:dll</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 启动项目（手动打开浏览器：localhost:8090）</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>读《你的孤独，虽败犹荣》</title>
    <url>/%E3%80%8A%E4%BD%A0%E7%9A%84%E5%AD%A4%E7%8B%AC%EF%BC%8C%E8%99%BD%E8%B4%A5%E7%8A%B9%E8%8D%A3%E3%80%8B%E6%91%98%E6%8A%84/</url>
    <content><![CDATA[<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>《你的孤独，虽败犹荣》，这本书买回来已经很久了。花了一两个月读了前一半，却只用了几个小时读完了后一半，有时候不得不说，自己对自己太任性了。<br>昨晚出去散步时，我说，回去后，我要把那本书读完。我哥一脸诧异，表示不敢相信，毕竟一半的内容不算少。回来后，戴上耳机，随手把罗扎夫加入了播放列表。并不是我想营造一个读书的氛围，只是为了隔绝外面的世界。几个小时后，我说，我看完了。我哥是一脸震惊，不知道是因为我做到了，还是因为吃鸡过程中突然暴毙而没回过味来。<br>这本书算是作者的一个心路历程吧，看完成之后，唏嘘不已。有共情，才会有感概，故事的人和事，似曾相识，不过这一切都已成了回忆。回过头来再想一想，这样，真的好么？</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><blockquote><p>孤独是自己居然就能成一个世界。</p></blockquote><blockquote><p>有一种孤独是<br>明知道结局是曲终人散，可当下却不得不放声大笑，直至在这样的尽兴中流下眼泪。</p></blockquote><blockquote><p>我们嘲笑过少年的无知，也嘲笑过岁月的苍老。我们行走在路上，理想宏大，眼窝却浅显。</p></blockquote><blockquote><p>有时候我们说很多话，并不是想得到热切的回应，而是只要有人愿意听，愿意帮我们记住，就够了。</p></blockquote><blockquote><p>回忆就像女儿红一般被埋在土里，偶尔想起来挖两锹土，都会醉倒半死。一群人怀旧，就着往事下酒，睫毛上满是青翠的湿气，饱含垂延欲滴的温柔。</p></blockquote><blockquote><p>有人拼命挣脱，终为无谓。<br>有人放任飘洒，终成无畏。</p></blockquote><blockquote><p>有一种孤独是<br>与志同道合的人定下目标，没皮没脸地往前冲，等到离光明不远的时候，你扭头一看，却发现志同道合的人已经不见了。</p></blockquote><blockquote><p>人与人擦肩时，往往会投来短暂且善意的眼光，你以为对方只是在浅显地打量，但对方表达的确实友善的“你好”。你伸出手，便能并肩行走。你错过，便再无下文。</p></blockquote><blockquote><p>有一种孤独是<br>突然想到一个人，却发现已经没有了对方的联系方式。</p></blockquote><blockquote><p>那些你曾以为很要好的朋友，那些你曾以为会一直结伴走下去的人，不知道何时就在路途中走散了。<br>陪你走了一程的朋友，谢谢他们。<br>愿陪你走一生的朋友，谢谢老天。</p></blockquote><blockquote><p>有些人在你面前，你很难说一声谢谢。然而他们离开之后，你却有千言万语想说给自己听，或者也希望，有一天他能够看见。<br>就是这么一种人，进入你生命的时候并不让人欢天喜地，他们却能够在离开你之后，让你一直想念，万语千言。</p></blockquote><blockquote><p>有一种孤独是<br>原以为找一个与自己分享痛苦的人很难，后来发现找一个能分享自己喜悦的人更难。</p></blockquote><blockquote><p>和一些人的关系像平行线，一辈子相守相望，见于眼底藏于心间。<br>就怕耐不住寂寞，冲动而成了相交线，在一个点尽情拥抱，<br>从此便离得越来越远，再也不见。<br>遇见这样的人，因为不想做恋人只能一时，所以才选择做朋友能一世。</p></blockquote><blockquote><p>有些不疼，是早已愈合，提起来只有伤疤，没了感受。有些不疼，是几近麻木，感受爱的能力全都用来感受痛了。你要相信自己强大的愈合能力，即使心里有刺，不拔出来，也会随着时间而最终消失。</p></blockquote><blockquote><p>有一种孤独是<br>我知道你爱我，我也知道我爱你，但我无法用准确的语言让你明白我内心的感受，即使我说了，你也不能理解。我们是人类，但却不是一类人。</p></blockquote><blockquote><p>有一种孤独是<br>很多闭上眼能回忆起的温度、对话、举动、细节，睁开眼却感觉它们从未发生过一样。擦肩而过，再无交集的孤独。</p></blockquote><blockquote><p>借秋微的小说《莫失莫忘》中的一句话：世间最大的遗憾是我们能好好地开始，却没能好好地告别。</p></blockquote><blockquote><p>成年与未成年最大的区别或许是我们开始越来越爱深夜，而只把冷静留给白天。</p></blockquote><blockquote><p>人与人之间的关系，常常从熟悉、到误解，从分离到释怀。释怀似乎才是最终认识自己和理解别人的方式。当时想不明白的原因和愤怒转身而去的情节，都会随着成长而渐渐释怀。释怀不是不再生气，也不是没有感情，而是面对曾经最熟悉的那个人还能问上一句： 你还好吗？</p></blockquote><blockquote><p>你以为做的一切都是为了身边最亲近的人，<br>后来你才知道最亲近的人最需要你做的只是你在身边。</p></blockquote><blockquote><p>有一种孤独是<br>与最亲近的那个人面对的时间和空间里，一直在质疑，而当你转身离开，却瞬间意识到自己的过错。</p></blockquote><blockquote><p>有一种孤独是<br>即使你做了错事，爱你的人却一直说没关系，连弥补的机会都不会给你。</p></blockquote><blockquote><p>有些爱就是错了一次之后，便希望用一生的努力去弥补。</p></blockquote><blockquote><p>越是亲近的人，越是有些话说不出口，也许我们都知道，很多事情都已经过去了，再大的伤害都不能阻止我们现在的感情如何的亲密，只是，如果你真的爱一个人的话，你总是希望能用自己的方式去弥补过去时光里造成的伤害——无论对方现在是否还需要。</p></blockquote><blockquote><p>亲近的人永远把话藏在心底，却用行动告诉全世界自己很在意。</p></blockquote><blockquote><p>有一种孤独是<br>小时候觉得顺其自然的事情，稍微大了之后认为那是按部就班，直到有一天你才发现一切所剩无几、无能为力，只能且行且珍惜。</p></blockquote><blockquote><p>有一种孤独是<br>如果自己忍受了委屈，便能让一切都好转起来，于是选择了闭嘴。没有人注意到你的改变，没有人走进过你的内心，外界越是平和，越是人声鼎沸，你心里的委屈越大、孤独越深。一开始埋下的孤独的种子，在一个人反复的自我回答中，长大成人。</p></blockquote><blockquote><p>你不好了，他们会失落，他们会用尽全力保护你。<br>你好了，他们也会失落，他们觉得自己的能力已经保护不了你了。</p></blockquote><blockquote><p>有一片这样的海，一扇能如此推开的窗，一身被晒得爽朗的肤色，更重要的是，有一个能陪我一起分享一切的人。很多人，有了一切却没有那个人。很多人，有了那个人，却为了追求一片海，最后丢掉了那个人。</p></blockquote><blockquote><p>当对事情感到绝望时，你可以放弃对他人的信任，<br>可以放弃外界对自己的评价，可以放弃对结果的企盼，<br>唯独不能放弃的是内心的平静。<br>只有回归平静，甘于寂寞，<br>不怕枯燥，才能重新听回自己的心跳声。<br>无论你未来身处混沌还是迷途，保持自在安宁是破除任何困局的最大武器。</p></blockquote><blockquote><p>给自己一些时间，一切终会有答案。</p></blockquote><blockquote><p>既然看不清未来，何不把握好现在。拽在手中的，始终会跟着你跑不掉，放飞于空中的，一不留神，便不知飘向何方。曾经迷茫，如今释怀开阔。当下迷茫，却对未来笃定希望。<br>这其中，便是时间和物是人非的成长。</p></blockquote><blockquote><p>有些日子，只记得事，因事想人。有些日子，却记得人，因人而记事。</p></blockquote><blockquote><p>一些人对我们做了一些事，有人只当是日常生活中的无心之举，有人却能读出一个轮回的历史。一些温暖，能让你在自己身上发光发热，传给他人。一些伤害，也能让你亮出胳膊，提醒自己何谓底线。</p></blockquote><blockquote><p>我们常问为什么，沉下来，看一切，我们就是答案。</p></blockquote><blockquote><p>有种孤独是<br>极力挣脱随波逐流的自己，尝试做一些不合群的举动，一开始总会被人误解，经过这样的孤独，才有真正与别人不一样的底气。</p></blockquote><blockquote><p>“如果你未来想在这个行业中出头的话，你觉得要具备什么条件？”<br>“待的时间比别人更长？资历比其他人更老？”当我说出这样的答案时，浑身不寒而栗。不知从什么时候开始，我已经把人生翻盘的决定权完完全全交给了时间。</p></blockquote><blockquote><p>每个人的人生只能自己负责，别人的意见顶多只是参考而已。如果一个人一辈子只能重复同样的一天，那该是世界上最寂寞的事情吧。</p></blockquote><blockquote><p>这些年，见惯了彼此伤害，也曾经被亲近的人抓住七寸反击，总以为受的伤够多了，就不会在跌倒了。现实却是为了每一次的投入而付出更隐秘的自己，于是又换来一批更新的伤口。<br>一个人的坚强不是看他外壳有多硬，而是看他的伤疤有多深。<br>最终，我们把自己磨砺成不害怕伤害，却开始害怕一种创可贴式的关怀。<br>有时，柔软或许比强大更具力量吧。</p></blockquote><blockquote><p>有的人可笑，是因为愚蠢。有的人可笑，是因为执着。而且我相信，只有当你明白自己的时间并不如想象得那么多的时候，你才会对出现在生命中的任何事物如此挑剔。原谅我只有一光年的宽度，只允许你在我生命中走一程的距离，能走多远都可以，但不能重复地走来走去。</p></blockquote><blockquote><p>有些人的好像埋在地下的酒，总是要经过很久，离开之后，才能被人知道。剩下饮酒的人只能寂寞独饮至天明。最遥远的距离是人还在，情还在，回去的路已不在。</p></blockquote><blockquote><p>有人说有结果的付出叫付出，没结果的付出叫代价。其实人在年轻的时候无论有没有结果，都要去付出，除此之外好像也没有什么别的选择。<br>因为知道了不要盲目至追求结果，所以变得开始不着急，把所有的着眼点都放在了每一次的当下，只有对自己的每一次行动负责，才会获一个美好的结果。</p></blockquote><blockquote><p>道理对不对不是最重要的，态度对了才是最重要的。</p></blockquote><blockquote><p>我们可以选择不说真话，但一定不能说假话。不说真话，可以有自己的态度；说假话，则失去一个人处世的原则。</p></blockquote><blockquote><p>有一种孤独是<br>当大多数人不赞同我时，你却偏偏站在我这一方。第一瞬不是感动，而是觉得我怎能让你变得和我一样的孤独，而后才有满满的感动。少数人的温暖，也是一种心照不宣的孤独。</p></blockquote><blockquote><p>“当我讨厌一个人的时候，如果这个人突然说喜欢我，那我就一点也不讨厌对方了。就是这么有原则，无法讨厌一个有眼光的人。”</p></blockquote><blockquote><p>有一种孤独是<br>四周的一切都暗下去，看不清周遭，先是恐惧，然后归于平静。这时，突然可以听清空气的流动，开始看得清自己过去的每一步。这种自省的孤独，胜过一切的鼓励。</p></blockquote><blockquote><p>低谷，这个词若出现在现在，证明你已停止前进。若你坚持爬坡，这个词一定会出现在你的回忆的时光里。</p></blockquote><blockquote><p>一个人的时候或许并不孤独，置身于热闹人群中，才愈发孤独。</p></blockquote><blockquote><p>因为一座城而爱上一个人不是没有可能。有时你会重新爱上一座城，也许只是你曾在这里遇到过几个陌生人。</p></blockquote>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>你的孤独，虽败犹荣</tag>
      </tags>
  </entry>
  <entry>
    <title>读《重构》</title>
    <url>/%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<blockquote><ul><li>重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。</li><li>傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。</li><li>如果重构引入了性能损耗，先完成重构，再做性能优化。</li><li>重构早期的主要动力是尝试理解代码如何工作。</li><li>好代码的检验标准就是人们是否能轻而易举地修改它。</li><li>重构的唯一目的就是让我们开发很快，用更少的工作量创造更大的价值。</li></ul></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>《重构》这本书，虽然看着很厚，但是读起来却又感觉很薄。用上周末的时间，读完这本书还是有可能的。之前也有做过重构的工作，不过那都是经验之谈，如果被问起为什么这么重构，估计我也不能很好得回答这个问题。所以，在这种情况下通读《重构》，还是挺有收获的，起码从经验上升到了理论。</p><h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2><p>要了解重构，还是从 What，Why，How 三方面入手。</p><ul><li><p>重构是什么？</p></li><li><p>为什么要重构？</p></li><li><p>怎么去重构？</p></li></ul><p>重构，使用一系列重构手法，在不改变可观察行为的前提下，对软件内部结构的一种调整。目的是提高其可理解性，降低其修改成本。<br>什么时候重构？如果你看不懂一段代码是在做什么，那么重构它。如果一段代码的目的依赖于注释，那么重构它。如果，一段代码想要添加新的功能，却无处下手，那么重构它。重构就是为了更容易理解，更容易修改。如果不能满足以上条件，这时候就有必要考虑重构了。<br>程序也并非从头到尾翻新一遍才叫重构，步子不能迈大，更希望的是小步快走的节奏。随时随地重构，用小步积累起来慢慢改善系统的设计。当然在实际的开发中，还会遇到各种挑战，比如，新功能开发，测试，性能等问题。而这些，在《重构》的前两章都有介绍。<br>知道了什么和为什么，那么，怎么去重构呢？在重构前，我们还要知道如何辨别需要重构的代码。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>《重构》在第三章也分门别类列举了需要重构的代码所具有的特点。</p><ul><li>神秘命名，命名要清晰表达功能和用法。</li><li>重复代码，提炼重复代码，避免重复的代码结构。</li><li>过长函数，函数越长就越难理解，分解函数，使用小函数。</li><li>过长参数列表和全局数据。</li><li>可变数据，对数据的修改经常会导致难以发现和难以跟踪的 bug。</li><li>发散式变化，模块因不同原因在不同方向上发生了变化。</li><li>霰弹式修改，将变化的封装起来。</li><li>依恋情节，一个函数和另一个模块的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。</li><li>数据泥团和基本类型的偏执。</li><li>重复的 switch 和循环语句。</li><li>冗赘的元素、夸夸其谈通用性和临时字段。</li><li>过长的消息链和中间人。</li><li>内幕交易，避免模块间的大量数据交换，降低模块间的耦合性。</li><li>过大的类和异曲同工的类。</li><li>纯数据的类、被拒绝的遗赠和注释。</li></ul><p>以上就是书中列举的代码的坏味道，每一个坏味道中都有相应的重构手法。<br>第四章，小步快走虽然很大程度上保障重构后的系统稳定性，不过构筑一个测试体系就更好了。<br>从第五章开始，作者依据重构手法的不同划分为第一组重构、封装、搬移特性、重新组织数据、简化条件逻辑、重构 API、处理继承关系等。<br>本书的内容很多却又不多，正如作者所说，你可以把它当成重构字典，没必要记住每个重构手法，只需要在重构时知道采用什么样的策略即可。</p>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】JavaScript engine fundamentals: Shapes and Inline Caches</title>
    <url>/%E3%80%90%E8%AF%91%E3%80%91JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/</url>
    <content><![CDATA[<h1 id="JavaScript-引擎原理：外形与内联缓存"><a href="#JavaScript-引擎原理：外形与内联缓存" class="headerlink" title="JavaScript 引擎原理：外形与内联缓存"></a>JavaScript 引擎原理：外形与内联缓存</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>。</p><p>本次暂定翻译三篇文章：</p><ol><li><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</li><li><a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</li><li><a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</li></ol><h2 id="JavaScript-引擎工作流"><a href="#JavaScript-引擎工作流" class="headerlink" title="JavaScript 引擎工作流"></a>JavaScript 引擎工作流</h2><p>一切从你写的 JavaScript 代码开始。JavaScript 引擎会解析源码并将其转换成抽象语法树（AST）。基于 AST，解释器（interpreter）会进一步地生成字节码。</p><p><img src="../images/js-engine-pipeline.svg" alt="js-engine-pipeline" title="js-engine-pipeline"></p><p>为了能够运行得更快，字节码可能会和分析数据（profiling data）一同发给优化编译器（the optimizing compiler）。优化编译器会根据这些分析数据作出某些假设以此生成高度优化的机器码。</p><p>如果某个时刻，某种假设被证明是错误的，优化编译器将去优化并回滚到解释器部分。</p><h2 id="JavaScript-引擎中的解释器-编译器流程"><a href="#JavaScript-引擎中的解释器-编译器流程" class="headerlink" title="JavaScript 引擎中的解释器/编译器流程"></a>JavaScript 引擎中的解释器/编译器流程</h2><p>现在来关注下 JavaScript 代码被解释和优化的地方，并重温下主流 JavaScript 引擎之间的不同之处。</p><p>一般来说，在运行 JavaScript 代码过程中，会有解释器和优化编译器的参与。解释器会快速地生成尚未优化的字节码，而优化编译器会耗费一些时间用来生成高度优化的机器码。</p><p><img src="../images/interpreter-optimizing-compiler.svg" alt="interpreter-optimizing-compiler" title="interpreter-optimizing-compiler"></p><p>上面的流程和 V8 在浏览器和 Node 环境下的工作流程及其相似：</p><p><img src="../images/interpreter-optimizing-compiler-v8.svg" alt="interpreter-optimizing-compiler-v8" title="interpreter-optimizing-compiler-v8"></p><p>V8 引擎的解释器被称作 Ignition，主要负责生成和执行字节码。当字节码运行时，解释器会收集分析数据，这些数据之后可能会被用来提升执行速度。如果一个函数经常被调用，即 hot，那么，经过解释器转换来的字节码和收集到的分析数据会传给 TurboFan（V8 的优化编译器），进一步被加工成高度优化的机器码。</p><p><img src="../images/interpreter-optimizing-compiler-spidermonkey.svg" alt="interpreter-optimizing-compiler-spidermonkey" title="interpreter-optimizing-compiler-spidermonkey"></p><p>SpiderMonkey，Mozilla 的 JavaScript 引擎，拥有两个优化编译器，Baseline 和 IonMonkey。解释器将转换后的代码传给 Baseline 编译器，Baseline 编译器会将其加工成部分优化的代码。再加上收集到的分析数据，IonMonkey 编译器可以生成高度优化的代码。如果基于假设的优化不成立，IonMonkey 会将代码会滚到 Baseline 部分。</p><p><img src="../images/interpreter-optimizing-compiler-chakra.svg" alt="interpreter-optimizing-compiler-chakra" title="interpreter-optimizing-compiler-chakra"></p><p>Chakra，Microsoft 的 JavaScript 引擎，也有着类似的两个优化编译器，SimpleJIT 和 FullJIT。解释器将转换后的代码传给 SimpleJIT（JIT，Just-In-Time），SimpleJIT 会将其加工成部分优化的代码。再加上收集到的分析数据，FullJIT 可以生成高度优化的代码。</p><p><img src="../images/interpreter-optimizing-compiler-jsc.svg" alt="interpreter-optimizing-compiler-jsc" title="interpreter-optimizing-compiler-jsc"></p><p>JavaScriptCore（JSC），Apple 的 JavaScript 引擎，更是发挥到了极致，使用了三个不同的优化编译器，Baseline、DFG 和 FTL。低级解释器（LLInt）将转换后的代码传给 Baseline 编译器，经其加工后传给 DFG（Data Flow Graph） 编译器，进一步加工后，传给 FTL（Faster Than Light） 编译器。</p><p>为什么有些引擎的优化编译器会比其他引擎的多？这完全是取舍问题。解释器可以很快地生成字节码，但是字节码的效率不高。优化编译器虽然会花更长的时间，但是生成的机器码更为高效。是更快地去执行代码，还是花些时间去执行更优的代码，这都是需要考虑的问题。有些引擎添加多种不同特点（省时或高效）的优化编译器，虽然这会变得更加复杂，但却可以对以上的取舍有着更细粒度地控制。还有一点需要考虑的是，内存的使用。</p><p>以上只是强调了不同 JavaScript 引擎的解析器/编译器的区别。抛开这些不谈，从更高的层面来看，所有的 JavaScript 引擎有着相同的架构：一个解析器和一些解释器/编译器。</p><h2 id="JavaScript-对象模型"><a href="#JavaScript-对象模型" class="headerlink" title="JavaScript 对象模型"></a>JavaScript 对象模型</h2><p>再来看看，在某些具体实现上，JavaScript 引擎之间还有哪些相同之处。</p><p>例如，JavaScript 引擎是如何实现 JavaScript 对象模型的？它们又是如何提升对象属性访问速度的？事实证明，所有主流的引擎在这点实现上都非常得相似。</p><p>ECMAScript 规范把所有的对象定义为词典，将字符串键映射到属性特性（<a href="https://tc39.es/ecma262/#sec-property-attributes" rel="external nofollow noopener noreferrer" target="_blank">property attributes</a>）。</p><p><img src="../images/object-model.svg" alt="object-model" title="object-model"></p><p>除了 <code>[[Value]]</code>， 规范还定义了一下属性：</p><ul><li><code>[[Writable]]</code> 定义是否可写。</li><li><code>[[Enumerable]]</code> 定义是否可枚举。</li><li><code>[[Configurable]]</code> 定义是否可配置。</li></ul><p><code>[[双中括号]]</code> 是用来描述不能直接暴露给 JavaScript 的属性。不过你依然可以通过 <code>Object.getOwnPropertyDescriptor</code> 获取某个对象上的以上属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">foo</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(object, <span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// → &#123; value: 42, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>ok，这是 JavaScript 如何定义对象的。那么，数组呢？</p><p>你可以认为数组是一个特殊的对象。一个不同点是，数组会对数组索引特殊处理。数组索引是 JavaScript 规范中的一个特殊术语。数组索引是某个范围内的任何有效索引，即在 0 ～ 2³²−2 范围内的任何一个整数。</p><p>另一个不同点是，数组还有一个 <code>length</code> 属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">array.length; <span class="comment">// → 2</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">array.length; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure><p>在这个例子里，数组创建好后，<code>&#39;length&#39;</code> 值为 2。当我们给数组索引为 2 的位置赋值时，数组的 <code>&#39;length&#39;</code> 会自动更新。</p><p>在 JavaScript 中，数组的定义和对象很相似。例如，数组的所有的键（包括数组索引）都是字符串表示。数组的第一个元素存在键值为 <code>&#39;0&#39;</code> 的地方。</p><p><img src="../images/array-1.svg" alt="array-1" title="array-1"></p><p>另一个属性是 <code>&#39;length&#39;</code> 属性，该属性不可枚举不可配置。</p><p>一旦数组添加一个元素，JavaScript 会自动更新 <code>&#39;length&#39;</code>属性上的 <code>[[Value]]</code> 值。</p><p><img src="../images/array-2.svg" alt="array-2" title="array-2"></p><p>一般来说，数组的行为也是和对象非常相似。</p><h2 id="优化属性的访问"><a href="#优化属性的访问" class="headerlink" title="优化属性的访问"></a>优化属性的访问</h2><p>既然我们知道在 JavaScript 中如何定义对象的。接下来让我们深入了解 JavaScript 引擎是如何高效地处理对象的。</p><p>属性访问是最常见的一个操作，对 JavaScript 引擎来说，提升访问速度事件很有意义的事。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">	foo: <span class="string">'bar'</span>,</span><br><span class="line">	baz: <span class="string">'qux'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here, we’re accessing the property `foo` on `object`:</span></span><br><span class="line">doSomething(object.foo);</span><br><span class="line"><span class="comment">//          ^^^^^^^^^^</span></span><br></pre></td></tr></table></figure><h3 id="外形（Shapes）"><a href="#外形（Shapes）" class="headerlink" title="外形（Shapes）"></a>外形（Shapes）</h3><p>在 JavaScript 程序中，有相同键的对象很多，它们有相同的 <code>Shape</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">// `object1` and `object2` have the same shape.</span></span><br></pre></td></tr></table></figure><p>有着相同 <code>Shape</code> 的对象，自然会访问相同的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logX</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(object.x);</span><br><span class="line">	<span class="comment">//          ^^^^^^^^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">logX(object1);</span><br><span class="line">logX(object2);</span><br></pre></td></tr></table></figure><p>考虑到这一点，JavaScript 引擎可以基于 对象的 <code>Shape</code> 来优化对象属性的访问速度。</p><p>我们假设一个对象有 x、y 属性，且用着字典这种数据结构：它包含字符串表示的键，并且键指向各自的属性特性（property attributes）。</p><p><img src="../images/object-model.svg" alt="object-model" title="object-model"></p><p>如果要访问一个属性，例如 <code>object.y</code>，JavaScript 引擎会在 <code>JSObject</code> 中查找 <code>y</code>，然后加载对应的属性特性，最后返回 <code>[[Value]]</code>。</p><p>但是在内存中，这些属性特性要存储在哪儿呢？我们应该把它们当作 <code>JSObject</code> 的一部分存储吗？假设之后会有更多的拥有相同 <code>Shape</code> 的对象，如果我们在 <code>JSObject</code> 上存储一个包含属性名称和属性特性的完整字典的话，那显然会是一种浪费。因为拥有相同 <code>Shape</code> 的对象，它们的属性名称会重复。这回造成大量重复和不必要的内存使用。作为优化，引擎将对象的 <code>Shape</code> 单独地存储。</p><p><img src="../images/shape-1.svg" alt="shape-1" title="shape-1"></p><p><code>Shape</code> 包含所有的属性名称和属性特性，除了 <code>[[Value]]</code>。不过，<code>Shape</code> 包含了 <code>[[Value]]</code> 在 <code>JSObject</code> 上的偏移量，因此 JavaScript 引擎知道去哪里找到相应的值。 每个拥有相同 <code>Shape</code> 的 <code>JSObject</code> 都指向同一个 <code>Shape</code> 实例。现在，每个 <code>JSObject</code> 只需存储对象的值即可。</p><p><img src="../images/shape-2.svg" alt="shape-2" title="shape-2"></p><p>当我们有很多个对象时，好处也是显而易见的。不管有多少个对象，只要有相同的 <code>Shape</code>，<code>Shape</code> 和属性信息只需要存储一次。</p><p>所有的 JavaScript 引擎都用 Shapes 来优化，但叫法却不同：</p><ul><li>学术论文称之为 Hidden Classes（容易和 JavaScript 中的 Class 混淆）</li><li>V8 称之为 Maps（容易和 JavaScript 中的 Map 混淆）</li><li>Chakra 称之为 Types（容易和 JavaScript 中的动态类型与 typeof 混淆）</li><li>JavaScriptCore 称之为 Structures</li><li>SpiderMonkey 称之为 Shapes</li></ul><p>在这篇文章中，我们继续称之为 Shapes。</p><h3 id="过渡链与树（Transition-chains-and-trees）"><a href="#过渡链与树（Transition-chains-and-trees）" class="headerlink" title="过渡链与树（Transition chains and trees）"></a>过渡链与树（Transition chains and trees）</h3><p>如果一个对象有了一个确定的 <code>Shape</code>,然后又添加了一个属性，这会发生什么呢？JavaScript 引擎如何找到改变后的新 <code>Shape</code>？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object.x = <span class="number">5</span>;</span><br><span class="line">object.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>在 JavaScript 引擎中，这种 Shapes 结构称之为过渡链。如下：</p><p><img src="../images/shape-chain-1.svg" alt="shape-chain-1" title="shape-chain-1"></p><p>对象开始时没有任何属性，因此它会指向一个空的 <code>Shape</code>。下一条语句对象添加了一个属性 <code>&#39;x&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 0 的位置添加 5。下一条语句对象添加了一个属性 <code>&#39;y&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 和 <code>&#39;y&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 1 的位置添加 6。</p><blockquote><p>注意： 属性的添加顺序会影响 <code>Shape</code>。例如，<code>{x: 4, y: 5}</code> 和 <code>{y: 5, x: 4}</code> 有不同的 <code>Shape</code>。</p></blockquote><p>我们没有必要让每个 <code>Shape</code> 都存储完整的属性表。相反，每个 <code>Shape</code> 只需要知道新引入的属性即可。例如，在这种情况下，我们没有必要在最后一个 <code>Shape</code> 中存储属性 <code>&#39;x&#39;</code> 的信息，因为它可以在链的上游中被查找到。要达此目的，每个 <code>Shape</code> 都会和先前的 <code>Shape</code> 链接。</p><p><img src="../images/shape-chain-2.svg" alt="shape-chain-2" title="shape-chain-2"></p><p>如果你在 JavaScript 代码中写了 <code>o.x</code>，JavaScript 引擎会沿着过渡链查找属性 <code>&#39;x&#39;</code>，直到发现引入 <code>&#39;x&#39;</code> 的 <code>Shape</code>。</p><p>但是，如果没法创建过渡链呢？例如，给两个空对象添加不同的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123;&#125;;</span><br><span class="line">object2.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，不得不进行分支处理，用过渡树（transition tree）取代过渡链。</p><p><img src="../images/shape-tree.svg" alt="shape-tree" title="shape-tree"></p><p>在这里，我们创建了一个空对象 <code>a</code>并给它添加了属性 <code>&#39;x&#39;</code>。最终得到以一个包含单个值的 <code>JSObject</code>和两种 <code>Shape</code>（空的 <code>Shape</code> 和仅有属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>）。</p><p>第二个例子也是以一个空对象 <code>b</code> 开始，但是添加的是属性 <code>&#39;y&#39;</code>。最终得到两条 <code>Shape</code> 链和三个 <code>Shape</code>。</p><p>这是否意味着总是以空 <code>Shape</code> 开头呢？不一定。</p><p>引擎对已经存在属性的对象字面两做了优化。来看两个例子，一个是从空的对象开始添加属性 <code>&#39;x&#39;</code>，一个是已经存在属性 <code>&#39;x&#39;</code> 的对象字面量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><p>第一个例子中，我们从空的 <code>Shape</code> 过渡到包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，就如之前所看到的那样。</p><p>对于 <code>object2</code>，它直接生成包含属性 <code>&#39;x&#39;</code> 的对象而不是从空对象开始过渡。</p><p><img src="../images/empty-shape-bypass.svg" alt="empty-shape-bypass" title="empty-shape-bypass"></p><p>这个包含属性 <code>&#39;x&#39;</code> 的对象，以包含 <code>&#39;x&#39;</code> 的 <code>Shape</code> 开头，省去了空 <code>Shape</code> 这个步骤。至少 V8 和 SpiderMonkey 是这么做的。这种优化缩短了过渡链，使得创建对象更加高效。</p><p>Benedikt 的文章 <a href="https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc" rel="external nofollow noopener noreferrer" target="_blank">surprising polymorphism in React applications</a> 讨论了这些微妙之处是如何影响到实际性能的。</p><p>这有一个拥有属性 <code>&#39;x&#39;、</code>‘y’<code>、</code>‘z’` 的三维点对象的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123;&#125;;</span><br><span class="line">point.x = <span class="number">4</span>;</span><br><span class="line">point.y = <span class="number">5</span>;</span><br><span class="line">point.z = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>就如之前所学到的，在内存上，这回创建有三个 <code>Shape</code> 的对象（空 <code>Shape</code> 不计入）。访问对象的属性 <code>&#39;x&#39;</code>，例如，如果你在程序中写下了 <code>point.x</code>，JavaScript 引擎会顺着链表：它会从底部的 <code>Shape</code> 开始，一直向上查找，直到发现引入 <code>&#39;x&#39;</code> 的那个 <code>Shape</code>。</p><p><img src="../images/shapetable-1.svg" alt="shapetable-1" title="shapetable-1"></p><p>如果这种操作很频繁，就会显得很慢，尤其是一个对象有很多属性时。检索到需要的属性所花时间是 O（n），即线性的。为了提高检索速度，JavaScript 引擎加入了 <code>ShapeTable</code> 数据结构。<code>ShapeTable</code> 是个字典，它将属性和引入该属性的 <code>Shape</code> 关联起来。</p><p><img src="../images/shapetable-2.svg" alt="shapetable-2" title="shapetable-2"></p><p>且慢，我们又回到了字典查找……这不就是我们在引入 Shapes 之前的方式吗？为什么我们非要整出个 Shapes？</p><p>原因是 Shapes 可以实现另一种称之为内联缓存的优化。</p><h3 id="内联缓存（Inline-Caches-ICs-）"><a href="#内联缓存（Inline-Caches-ICs-）" class="headerlink" title="内联缓存（Inline Caches (ICs)）"></a>内联缓存（Inline Caches (ICs)）</h3><p>ICs 是 JavaScript 快速运行的关键因素。JavaScript 引擎可以利用 ICs 缓存对象的属性信息，从而减少属性查找的开销。</p><p>有个函数 <code>getX</code> ，接受一个对象并加载该对象上的属性 <code>x</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在 JSC（JavaScriptCore） 中运行这个函数，它会生成以下的字节码：</p><p><img src="../images/ic-1.svg" alt="js-engines/ic-1" title="js-engines/ic-1"></p><p>第一条指令（<code>get_by_id</code>）是从参数 <code>arg1</code> 中加载属性 <code>x</code>，并将其值存储到 <code>loc0</code> 中。第二条指令是返回 <code>loc0</code> 中存储的值。</p><p>JSC 还在 <code>get_by_id</code> 指令中嵌入了内联缓存，它是由两个未初始化的插槽组成。</p><p><img src="../images/ic-2.svg" alt="ic-2" title="ic-2"></p><p>现在给函数 <code>getX</code> 传入对象 <code>{ x: &#39;a&#39; }</code>。如我们所知，这个对象有一个包含属性 <code>x</code> 的 <code>Shape</code>，这个 <code>Shape</code> 存储了属性 <code>x</code> 的偏移量和特性。当我们第一次执行函数时，<code>get_by_id</code> 指令会查找属性 <code>x</code> 并检索到值被存储在偏移量为 <code>0</code> 位置。</p><p><img src="../images/ic-3.svg" alt="ic-3" title="ic-3"></p><p>嵌在 <code>get_by_id</code> 指令中的内联缓存会记住 <code>Shape</code> 和属性的偏移量。</p><p><img src="../images/ic-4.svg" alt="ic-4" title="ic-4"></p><p>在下次函数执行时，内联缓存会对比 <code>Shape</code>，如果与之前的 <code>Shape</code> 相同，就只需要通过缓存的偏移量加载值。具体来说，如果 JavaScript 引擎发现对象的 <code>Shape</code> 和之前记录的 <code>Shape</code> 一样，那么它就再也不需要去查找属性信息了 —— 属性信息的查找就可以完全跳过。相比每次都去查找属性信息，这样的操作会显著地提升速度。</p><h3 id="高效存储数组（Storing-arrays-efficiently）"><a href="#高效存储数组（Storing-arrays-efficiently）" class="headerlink" title="高效存储数组（Storing arrays efficiently）"></a>高效存储数组（Storing arrays efficiently）</h3><p>对于数组，使用数组索引作为数组的属性是很常见的，属性对应的值称之为数组元素。为每个数组的每个数组元素存储属性特性是一种铺张浪费的行为。在 JavaScript 引擎中，数组的索引属性默认是可读、可枚举和可配置的，且数组元素是与命名属性分开存储的。</p><p>思考以下这个数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">	<span class="string">'#jsconfeu'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>引擎存储了一个数组长度为 1 的数组，它指向一个包含偏移量和 <code>length</code> 特性的 <code>Shape</code>。</p><p><img src="../images/array-shape.svg" alt="array-shape" title="array-shape"></p><p>这个之前见过的很相似…… 但是数组元素的值存在哪呢？</p><p><img src="../images/array-elements.svg" alt="array-elements" title="array-elements"></p><p>每个数组都有一个独立的元素备份存储（elements backing store），包含着所有索引属性对应的值。JavaScript 引擎不必为数组元素存储属性特性，因为他们通常是可写、可枚举和可配置的，且数组索引可以替代偏移量的作用。</p><p>如果是不寻常的情况会怎样呢？比如，改变数组元素的属性特性（property attributes）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Please don’t ever do this!</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">	[],</span><br><span class="line">	<span class="string">'0'</span>,</span><br><span class="line">	&#123;</span><br><span class="line">		value: <span class="string">'Oh noes!!1'</span>,</span><br><span class="line">		writable: <span class="literal">false</span>,</span><br><span class="line">		enumerable: <span class="literal">false</span>,</span><br><span class="line">		configurable: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的这个代码片段是给对象属性 <code>&#39;0&#39;</code> 的特性设置成非默认值。</p><p>像这种情况，JavaScript 引擎会将整个元素备份存储表示为一个字典，把数组索引和属性特性关联起来。</p><p><img src="../images/array-dictionary-elements.svg" alt="array-dictionary-elements" title="array-dictionary-elements"></p><p>即使数组中只有一个元素的属性特性是非默认值，元素备份存储也会进入缓慢低效的模式（从 Elements 模式 到 Dictionary Elements 模式）。避免用 <code>Object.defineProperty</code> 改变数组索引！</p><h2 id="看点（Take-aways）"><a href="#看点（Take-aways）" class="headerlink" title="看点（Take-aways）"></a>看点（Take-aways）</h2><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>始终以相同的方式初始化对象，这样就可以复用 <code>Shape</code>。</li><li>不要没事瞎折腾数组元素的属性特性，它们本可以高效地工作。</li></ol>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】JavaScript engine fundamentals: optimizing prototypes</title>
    <url>/%E3%80%90%E8%AF%91%E3%80%91JavaScript-engine-fundamentals-optimizing-prototypes/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>。</p><p>本次暂定翻译三篇文章：</p><ol><li><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</li><li><a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</li><li><a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</li></ol><h2 id="Optimization-tiers-and-execution-trade-offs"><a href="#Optimization-tiers-and-execution-trade-offs" class="headerlink" title="Optimization tiers and execution trade-offs"></a>Optimization tiers and execution trade-offs</h2><p><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">上一篇文章</a>已经讨论了现代 JavaScript 引擎的工作流程：</p><p><img src="../images/js-engine-pipeline.svg" alt="js-engine-pipeline" title="js-engine-pipeline"></p><p>我们也指出了引擎间的相同之处和编译环节中的差异。为什么会这样？为什么一些引擎的编译器比其他引擎多？结论是基于更快地生成代码和生成更好的代码两者间的考量。</p><p><img src="../images/tradeoff-startup-speed.svg" alt="tradeoff-startup-speed" title="tradeoff-startup-speed"></p><p>解释器可以很快地生成字节码，但是字节码的效率不高。另一方面，优化编译器虽然会稍微花费些时间，却可以生成效率更高的机器码。</p><p>下图是 V8 模型，V8 的解释器称为 Ignition，是所有引擎中最快的解释器（从原始字节码执行速度的角度）。V8 的优化编译器称为 TurboFan，它最终会生成高度优化的机器码。</p><p><img src="../images/tradeoff-startup-speed-v8.svg" alt="tradeoff-startup-speed-v8" title="tradeoff-startup-speed-v8"></p><p>启动速度和执行速度是一些 JavaScript 引擎选择添加优化层的理由。比如，SpiderMonkey 就在解释器和 IonMonkey 编译器间添加了 Baseline 层。</p><p><img src="../images/tradeoff-startup-speed-spidermonkey.svg" alt="tradeoff-startup-speed-spidermonkey" title="tradeoff-startup-speed-spidermonkey"></p><p>解释器可以快速生成字节码，但是字节码执行的速度比较慢。Baseline 会花些时间生成代码，但同样会提供性能更好的代码。最后，IonMonkey 会花更长的时间去生成机器码，并能够更高效地执行。</p><p>来用一个具体的例子，看看不同引擎之间的处理差异。在这个循环里，一些代码重复执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4242424242</span>; ++i) &#123;</span><br><span class="line">	result += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>在 Ignition 解释器中，V8 开始执行字节码。在某个时刻引擎测定代码是 hot 的，就会启动 <code>TurboFan frontend</code>, <code>TurboFan frontend</code> 是负责整合分析数据（profiling data）并构建代码的初级机器码表现形式。这些东西会被送到处在其他线程的 <code>TurboFan</code> 优化程序中作进一步优化。</p><p><img src="../images/pipeline-detail-v8.svg" alt="pipeline-detail-v8" title="pipeline-detail-v8"></p><p>当优化程序进行时，V8 继续执行字节码。在某个时刻，优化程序生成可执行代码后，流程会接着执行下去。</p><p>同样，SpiderMonkey 也是在解释器中开始执行字节码。但是它有 <code>Baseline</code> 层，hot 代码会被送到这里。一旦 <code>Baseline</code> 编译器生成了 <code>Baseline</code> 代码，流程会接着执行下去。</p><p><img src="../images/pipeline-detail-spidermonkey.svg" alt="pipeline-detail-spidermonkey" title="pipeline-detail-spidermonkey"></p><p><code>Baseline</code> 代码运行一段时间后，SpiderMonkey 最终会启动 <code>IonMonkey frontend</code> 和 优化程序（类似于 V8）。IonMonkey 在优化时，<code>Baseline</code> 也会保持着运行状态。当优化完成后，已优化的代码将取代 <code>Baseline</code> 代码被执行。</p><p>Chakra 的架构和 SpiderMonkey 很相似。Chakra 尝试并行做很多事情同时又不会阻塞主线程。Chakra 会将字节码和编译器可能需要的分析数据复制出来，并发往编译器专用进程。</p><p><img src="../images/pipeline-detail-chakra.svg" alt="pipeline-detail-chakra" title="pipeline-detail-chakra"></p><p>当代码准备妥当后，引擎开始执行 SimpleJIT 代码。这种方式的好处在于复制所停留的时间远远小于编译器（ 编译器 frontend）所用的时间。缺点就是，这种启发式复制（copy heuristic）会使得某种优化所必须的信息丢失，因此这是在用代码质量换取时间。</p><p>在 JavaScriptCore，所有的优化编译器和主线程并发运行；主线程只是触发了另一个线程的编译任务。然后编译器通过复杂的加锁从主线程获取分析数据（profiling data）。</p><p><img src="../images/pipeline-detail-javascriptcore.svg" alt="pipeline-detail-javascriptcore" title="pipeline-detail-javascriptcore"></p><p>这种方式的优点是减少了因 JavaScript 优化引发的麻烦。缺点就是需要处理复杂的多线程问题和各种操作所带来的加锁成本。</p><p>我们讨论了快速生成代码，也讨论了生成快速的代码。但是，还要有一点需要注意：内存的使用！为了解释这个，这里有个两数字相加的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>以下是 V8 的 Ignition 编译器生成的字节码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">StackCheck</span><br><span class="line">Ldar a1</span><br><span class="line">Add a0, [<span class="number">0</span>]</span><br><span class="line">Return</span><br></pre></td></tr></table></figure><p>不要在意字节码的细节，重点是知道它只有 4 个指令！</p><p>当代码编程 hot 时，TurboFan 会生成以下高度优化过的机器码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">leaq rcx,[rip+<span class="number">0x0</span>]</span><br><span class="line">movq rcx,[rcx<span class="number">-0x37</span>]</span><br><span class="line">testb [rcx+<span class="number">0xf</span>],<span class="number">0x1</span></span><br><span class="line">jnz CompileLazyDeoptimizedCode</span><br><span class="line">push rbp</span><br><span class="line">movq rbp,rsp</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">cmpq rsp,[r13+<span class="number">0xe88</span>]</span><br><span class="line">jna StackOverflow</span><br><span class="line">movq rax,[rbp+<span class="number">0x18</span>]</span><br><span class="line">test al,<span class="number">0x1</span></span><br><span class="line">jnz Deoptimize</span><br><span class="line">movq rbx,[rbp+<span class="number">0x10</span>]</span><br><span class="line">testb rbx,<span class="number">0x1</span></span><br><span class="line">jnz Deoptimize</span><br><span class="line">movq rdx,rbx</span><br><span class="line">shrq rdx, <span class="number">32</span></span><br><span class="line">movq rcx,rax</span><br><span class="line">shrq rcx, <span class="number">32</span></span><br><span class="line">addl rdx,rcx</span><br><span class="line">jo Deoptimize</span><br><span class="line">shlq rdx, <span class="number">32</span></span><br><span class="line">movq rax,rdx</span><br><span class="line">movq rsp,rbp</span><br><span class="line">pop rbp</span><br><span class="line">ret <span class="number">0x18</span></span><br></pre></td></tr></table></figure><p>和字节码相比较，这里的代码会显得很多！通常来说，字节码会比机器码紧凑得多，尤其对比高度优化过的机器码。另一方面，字节码需要解释器来运行，而优化过的代码则可以被处理器直接执行。</p><p>这是 JavaScript 引擎不「优化一切」的原因之一（仅优化 「hot function」）。正如我们早先看到的，生成优化过的机器码会用很长的时间，除此之外，我们刚才也知道了优化过的机器码会占用用更多的内存空间。</p><p><img src="../images/tradeoff-memory.svg" alt="tradeoff-memory" title="tradeoff-memory"></p><h2 id="Optimizing-prototype-property-access"><a href="#Optimizing-prototype-property-access" class="headerlink" title="Optimizing prototype property access"></a>Optimizing prototype property access</h2><p><a href="https://mathiasbynens.be/notes/shapes-ics#optimizing-property-access" rel="external nofollow noopener noreferrer" target="_blank">先前的文章</a>阐述了 JavaScript 引擎使用 Shapes 和 Inline Caches 优化对象属性的访问。再次说明，引擎将对象的 Shape 和对象的值分开存储。</p><p><img src="../images/shape-2.svg" alt="shape-2" title="shape-2"></p><p>结合 Shapes 和 Inline Caches 可以加快代码中同一位置的属性重复性访问。</p><p><img src="../images/ic-4.svg" alt="ic-4" title="ic-4"></p><h3 id="Classes-and-prototype-based-programming"><a href="#Classes-and-prototype-based-programming" class="headerlink" title="Classes and prototype-based programming"></a>Classes and prototype-based programming</h3><p>我们已经知道了如何快速访问 JavaScript 对象上的属性，我们再看看 JavaScript 最近新增的特性：类。下面是 JavaScript 中类的语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">		<span class="keyword">this</span>.x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	getX() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似是个新概念，其实就是基于原型的语法糖。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype.getX = <span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，我们给 <code>Bar.prototype</code> 这个对象添加属性 <code>getX</code>，这和其它普通对象添加属性没有区别，因为在 JavaScript中， 原型也是个对象！像 JavaScript 这种基于原型的编程语言，方法可以通过原型共享，而字段则存储在实例中。</p><p>让我们看看通过 Bar 创建实例 foo 会发生什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>创建出来的实例（foo）拥有一个只包含属性 <code>&#39;x&#39;</code> 的 shape。foo 的原型指向 <code>Bar.prototype</code>。</p><p><img src="../images/class-shape-1.svg" alt="class-shape-1" title="class-shape-1"></p><p><code>Bar.prototype</code> 也有属于自己的 shape，它包含一个 <code>getX</code> 属性，这个属性的值是个返回 <code>this.x</code> 的函数（<code>getX</code>）。<code>Bar.prototype</code> 的原型是 <code>Object.prototype</code>。<code>Object.prototype</code> 是原型链的根源，因此它的原型是 <code>null</code>。</p><p><img src="../images/class-shape-2.svg" alt="class-shape-2" title="class-shape-2"></p><p>如果你用同一个类又创建了一个实例，那么这两个实例将共享 shape，两个实例也会指向同一个 <code>Bar.prototype</code>。</p><h3 id="Prototype-property-access"><a href="#Prototype-property-access" class="headerlink" title="Prototype property access"></a>Prototype property access</h3><p>ok，我们已经知道了定义一个类并用类创建实例的过程。那么，如果我们在实例上调用一个方法，又会发生什么呢？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> x = foo.getX();</span><br><span class="line"><span class="comment">//        ^^^^^^^^^^</span></span><br></pre></td></tr></table></figure><p>你可以认为方法的调用分为两个步骤：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = foo.getX();</span><br><span class="line"></span><br><span class="line"><span class="comment">// is actually two steps:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $getX = foo.getX;</span><br><span class="line"><span class="keyword">const</span> x = $getX.call(foo);</span><br></pre></td></tr></table></figure><p>步骤 1：加载方法，这个方法只不过是原型上的属性（而它恰好是个函数）。步骤 2：用实例去调用这个方法（重新绑定 <code>this</code>）。先看步骤 1：</p><p><img src="../images/method-load.svg" alt="method-load" title="method-load"></p><p>开始时，引擎从实例 foo 上查找并发现 foo 的 shape 上没有 <code>getX</code> 属性，于是它不得不沿着原型链向上查找。到达 <code>Bar.prototype</code> 后，开始查找它的 shape 并找到了 <code>getX</code> 属性。然后根据 <code>getX</code> 的属性信息（Offset：0）在 <code>Bar.prototype</code> 上找到了 <code>getX</code> 函数。</p><p>JavaScript 的灵活性使得原型链可能会突变，例如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</span><br><span class="line">foo.getX();</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(foo, <span class="literal">null</span>);</span><br><span class="line">foo.getX();</span><br><span class="line"><span class="comment">// → Uncaught TypeError: foo.getX is not a function</span></span><br></pre></td></tr></table></figure><p>这个例子中，<code>foo.getX()</code> 被调用了两次，但是每次都会有不同的含义，不同的结果。所以说，尽管原型在 JavaScript 中只是个对象，但是提升原型属性的访问速度依然比常规对象更具有挑战性。</p><p>通常情况下，原型属性的加载是个非常频繁的操作：每次方法调用都会去加载属性！</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> x = foo.getX();</span><br><span class="line"><span class="comment">//        ^^^^^^^^^^</span></span><br></pre></td></tr></table></figure><p>之前，我们讨论了使用 Shapes 和 ICs 优化常规对象的属性访问。那么，我们能否使用相同的策略去优化原型属性的重复性访问呢？下面，我们看看属性是如何加载的。</p><p><img src="../images/prototype-load-checks-1.svg" alt="prototype-load-checks-1" title="prototype-load-checks-1"></p><p>在这个案例中，为了提高重复加载的速度，我们需要知道三件事：</p><ol><li>foo 的 shape 不包含 <code>getX</code> 且没有改变过。这意味着 foo 没有添加、删除属性，或改变属性特性。</li><li>foo 的原型依然是 <code>Bar.prototype</code>。这意味着，foo 的原型没有通过 <code>Object.setPrototypeOf()</code> 或 <code>__proto__</code> 的方式改变过。</li><li><code>Bar.prototype</code> 的 shape 包含 <code>getX</code> 且没有改变过。这意味着 <code>Bar.prototype</code> 没有添加、删除属性，或改变属性特性。</li></ol><p>一般情况下，这意味着我们需要检查 1 遍实例本身，还有因每增加一个原型就就要增加的 2 遍检查直到找到我们想要的属性。<code>1+2N</code>（N 表示原型链上直到找到存在属性的原型的原型数量） 遍的检查看上去还不是特别糟糕，因为这时的原型链还比较短 —— 但是引擎会经常处理有着很长原型链的对象，就比如常见的 DOM 类。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> anchor = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// → HTMLAnchorElement</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> title = anchor.getAttribute(<span class="string">'title'</span>);</span><br></pre></td></tr></table></figure><p>现有个 <code>HTMLAnchorElement</code> 并调用 <code>getAttribute()</code> 方法。这简单的 anchor 元素涉及到 6 个原型！<code>getAttribute()</code> 不是 <code>HTMLAnchorElement</code> 原型上的方法，而是原型链上靠近顶部的原型上。</p><p><img src="../images/anchor-prototype-chain.svg" alt="anchor-prototype-chain" title="anchor-prototype-chain"></p><p><code>getAttribute()</code> 是在 <code>Element.prototype</code> 上发现的。这意味着我们每次调用 <code>anchor.getAttribute()</code> 时，都需要做以下这些事：</p><ol><li>检测到 <code>getAttribute</code> 不存在于 <code>anchor</code> 对象本身;</li><li>检测到 <code>anchor</code> 的原型是 <code>HTMLAnchorElement.prototype</code>;</li><li>确认没有 <code>getAttribute</code> 属性；</li><li>检测到下一个原型是 <code>HTMLElement.prototype</code>;</li><li>确认没有 <code>getAttribute</code> 属性；</li><li>继续检测下一个原型 <code>Element.prototype</code>;</li><li>找到 <code>getAttribute</code>。</li></ol><p>一共需要 7 次检测！而这种情况很常见，于是引擎想方设法去减少属性（原型上）加载时的检查次数。</p><p>回到更早的例子，当我们从 foo 访问 <code>getX</code> 时，共做了 3 次检查：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(x) &#123; <span class="keyword">this</span>.x = x; &#125;</span><br><span class="line">	getX() &#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Bar(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> $getX = foo.getX;</span><br></pre></td></tr></table></figure><p>在查找属性的过程中，每个牵涉到的原型都需要做缺失检查（确认属性是否存在）。如果我们能够在属性确认的步骤里同时检测原型链，那将会减少总的检查次数。引擎也正是这么做的：</p><p><img src="../images/prototype-load-checks-2.svg" alt="prototype-load-checks-2" title="prototype-load-checks-2"></p><p>每个 shape 都指向了原型，这意味着 foo 的原型改变时，引擎会自动过渡到新的 shape。现在我们只需要检查对象的 shape 就可以同时检测属性是否存在以及原型链的导向。</p><p>鉴于此，由于检查的次数从 <code>1+2N</code> 降低到 <code>1+N</code>，所以原型上属性的访问速度也变快了。由于在原型链上查找属性的时间复杂度是线性的，所以依然还是很耗时的。引擎使用了不同的方法让检查的次数趋于常量，尤其是同一属性的连续加载（访问）。</p><h3 id="Validity-cells"><a href="#Validity-cells" class="headerlink" title="Validity cells"></a>Validity cells</h3><p>为此，V8 特别处理了原型的 shapes。每个原型都有一个独一无二的 shape，这个 shape 不会被其它的对象共享（特别是其它的原型对象），每一个原型的 shape 都有与之关联的 <code>ValidityCell</code>。</p><p><img src="../images/validitycell.svg" alt="validitycell" title="validitycell"></p><p>如果与之关联的原型被修改，或该原型的上游（原型的原型，原型的原型的原型……）被修改，<code>ValidityCell</code> 都会被标记为无效。让我们看看这是到底怎么一回事？</p><p>为了加快原型上后续的属性加载，V8 使用 ICs 保存着 4 个字段：</p><p><img src="../images/ic-validitycell.svg" alt="ic-validitycell" title="ic-validitycell"></p><p>代码第一次执行时，ICs 开始工作了，它要缓存属性在原型上的偏移量 「<code>Offset</code>」，属性所在的原型 「<code>Prototype</code>」（本例中的 <code>Bar.prototype</code>），实例的 shape 「Shape」（本例中 foo 的 shape）,还有就是与原型的 shape 相关联的 <code>ValidityCell</code> 「<code>ValidityCell</code>」，这个原型是实例 shape 直接链接的那个原型（本例中的 <code>Bar.prototype</code>）。</p><p>若在下一次 ICs 命中时，引擎会检查 shape （实例的 shape）和 <code>ValidityCell</code>。如果还有效，引擎会直接从 ICs 中提取信息，根据 <code>Prototype</code> 和 <code>Offset</code> 字段获取属性信息，这样就跳过了之前繁琐的查找步骤。</p><p><img src="../images/validitycell-invalid.svg" alt="validitycell-invalid" title="validitycell-invalid"></p><p>当原型发生改变时，一个新的 shape 将会生成，同时先前的 <code>ValidityCell</code> 将会失效。因此在下次执行时，ICs 将不会起作用，性能自然不会好。</p><p>回过头来再看看之前的 DOM，例如，<code>Object.prototype</code> 发生变化后，影响的将不仅仅是自身，还包括链的下游 <code>EventTarget.prototype</code>、<code>Node.prototype</code>、<code>Element.prototype</code>，直到 <code>HTMLAnchorElement.prototype</code>。</p><p><img src="../images/prototype-chain-validitycells.svg" alt="prototype-chain-validitycells" title="prototype-chain-validitycells"></p><p>事实上，当你在代码中修改了 <code>Object.prototype</code>，就意味着将性能弃之不顾。所以，不要那样做！</p><p>让我们看一个具体的例子，有一个 Bar 类，它有 <code>loadX</code> 方法。我们将使用类的实例调用 <code>loadX</code> 若干次。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadX</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> bar.getX(); <span class="comment">// IC for 'getX' on `Bar` instances.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadX(<span class="keyword">new</span> Bar(<span class="literal">true</span>));</span><br><span class="line">loadX(<span class="keyword">new</span> Bar(<span class="literal">false</span>));</span><br><span class="line"><span class="comment">// IC in `loadX` now links the `ValidityCell` for</span></span><br><span class="line"><span class="comment">// `Bar.prototype`.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.newMethod = <span class="function"><span class="params">y</span> =&gt;</span> y;</span><br><span class="line"><span class="comment">// The `ValidityCell` in the `loadX` IC is invalid</span></span><br><span class="line"><span class="comment">// now, because `Object.prototype` changed.</span></span><br></pre></td></tr></table></figure><p>此时，ICs 中会记录调用 <code>loadX</code> 后的相关信息。然后我们修改了 <code>Object.prototype</code> —— 所有原型的根源 —— <code>ValidityCell</code> 会被标记为无效的，ICs 不会在下次执行时命中，性能也会变得糟糕。</p><p>改变 <code>Object.prototype</code> 是一个不好的行为，它使得原型链下游所有的 ICs 失去作用。这有另一个不推荐的行为。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* … */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run critical code:</span></span><br><span class="line">someObject.foo();</span><br><span class="line"><span class="comment">// End of critical code.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype.foo;</span><br></pre></td></tr></table></figure><p>我们拓展了 <code>Object.prototype</code>，它使得原型链下游的所有 ICs 失效。然后调用原型上的新方法，引擎便从头开始为原型属性的访问构建新的 ICs。最后，我们删除了之前添加的方法。</p><p>清除，听着挺不错的，其实在这种情况下，只会更糟。删除 <code>Object.prototype</code> 上的属性就意味着修改 <code>Object.prototype</code>，所有的 ISc 将再一次失效，引擎也将会再一次地重头开始构建 ICs。</p><h2 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h2><p>我们知道了 JavaScript 引擎是如何存储对象和类的，也知道了 Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型操作的。基于这些知识点，我们可以使用一些 JavaScript 编程技巧来提升性能：<strong>不要乱动原型</strong>（如果你真的，真的需要这么干，那么，至少要在代码运行前）。</p>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】The story of a V8 performance cliff in React</title>
    <url>/%E3%80%90%E8%AF%91%E3%80%91The-story-of-a-V8-performance-cliff-in-React/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>。</p><p>本次暂定翻译三篇文章：</p><ol><li><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</li><li><a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</li><li><a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</li></ol><h2 id="JavaScript-types"><a href="#JavaScript-types" class="headerlink" title="JavaScript types"></a>JavaScript types</h2><p>在 JavaScript 中，值有 8 总类型（当前）：<code>Number</code>，<code>String</code>，<code>Symbol</code>，<code>BigInt</code>，<code>Boolean</code>，<code>Undefined</code>，<code>Null</code>，<code>Object</code>。</p><p><img src="../images/01-javascript-types.svg" alt="01-javascript-types" title="01-javascript-types"></p><p>除了一个明显的例外，这些类型都可以用 <code>typeof</code> 直接查看。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// → 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// → 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span>;</span><br><span class="line"><span class="comment">// → 'bigint'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// → 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// → 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// → 'object' 🤔</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="comment">// → 'object'</span></span><br></pre></td></tr></table></figure><p><code>typeof null</code> 返回的是 <code>&#39;object&#39;</code>，而不是 <code>&#39;null&#39;</code>，要了解为什么，首先要把所有的 JavaScript 类型分成两组：</p><ul><li>objects(即，对象类型)</li><li>primitives(即，非对象类型)</li></ul><p>照此来说，<code>null</code> 表示「没有对象」，而 <code>undefined</code> 表示 「没有值」。</p><p><img src="../images/02-primitives-objects.svg" alt="02-primitives-objects" title="02-primitives-objects"></p><p>按照这个思路，Brendan Eich 在设计 JavaScript 时，受到 Java 的影响，使得右手边的值执行 <code>typeof</code> 后都返回 <code>object</code>。因此，即便规范里有 <code>Null</code> 类型，<code>typeof null === &#39;object&#39;</code> 依然成立。</p><p><img src="../images/03-primitives-objects-typeof.svg" alt="03-primitives-objects-typeof" title="03-primitives-objects-typeof"></p><h2 id="Value-representation"><a href="#Value-representation" class="headerlink" title="Value representation"></a>Value representation</h2><p>JavaScript 引擎能够在内存中表示任意的 JavaScript 值。然而，值得注意的是，JavaScript 引擎在内存中值类型的表现形式是不同于 JavaScript 中的类型描述。</p><p>例如，42，在 JavaScript 中是 <code>number</code> 类型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br></pre></td></tr></table></figure><p>在内存中有好多种方式表示整数，例如 42:</p><table><thead><tr><th style="text-align:center">representation</th><th style="text-align:center">bits</th></tr></thead><tbody><tr><td style="text-align:center">two’s complement 8-bit</td><td style="text-align:center"><code>0010 1010</code></td></tr><tr><td style="text-align:center">two’s complement 32-bit</td><td style="text-align:center"><code>0000 0000 0000 0000 0000 0000 0010 1010</code></td></tr><tr><td style="text-align:center">packed binary-coded decimal (BCD)</td><td style="text-align:center"><code>0100 0010</code></td></tr><tr><td style="text-align:center">32-bit IEEE-754 floating-point</td><td style="text-align:center"><code>0100 0010 0010 1000 0000 0000 0000 0000</code></td></tr><tr><td style="text-align:center">64-bit IEEE-754 floating-point</td><td style="text-align:center"><code>0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>ECMAScript 将数字标准化为 64 位浮点值，也称为双精度浮点或 Float64。但是，这并不意味着 JavaScript 引擎总是以 Float64 的形式存储数字 —— 这么做会很低效。引擎会选择其它的内部表现形式，除非观测到的行为完全匹配 Float64。</p><p>在真实的 JavaScript 应用中，大多数数字都是合法的 ECMAScript <a href="https://tc39.es/ecma262/#array-index" rel="external nofollow noopener noreferrer" target="_blank">数组索引</a>，即，属于 0 ~ 2³²−2 范围内的整数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">array[<span class="number">0</span>]; <span class="comment">// Smallest possible array index.</span></span><br><span class="line">array[<span class="number">42</span>];</span><br><span class="line">array[<span class="number">2</span>**<span class="number">32</span><span class="number">-2</span>]; <span class="comment">// Greatest possible array index.</span></span><br></pre></td></tr></table></figure><p>JavaScript 引擎会为数字选择最优存储的表达形式以此优化数组元素的访问效率。对于处理器的内存访问操作，数组索引必须是二进制补码的形式。用 Float64 表示数组是一种很费性能的行为，因为每次访问数组元素引擎都需要在 Float64 和二进制补码之间转换。</p><p>32 位的二进制补码表达形式对数组操作是很有用的。通常来说，处理器执行整型操作比执行浮点型操作要快得多。所以说，下面的例子，第一个循环比第二个循环快两倍。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// fast 🚀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0.1</span>; i &lt; <span class="number">1000.1</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// slow 🐌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作符也是一样。在下面的代码中，模运算符的性能取决于处理的是否是整数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> remainder = value % divisor;</span><br><span class="line"><span class="comment">// Fast 🚀 if `value` and `divisor` are represented as integers,</span></span><br><span class="line"><span class="comment">// slow 🐌 otherwise.</span></span><br></pre></td></tr></table></figure><p>如果两个操作数都是整数的形式，CPU 就可以高效地计算出结果。如果除数是 2 的倍数，V8 还会有额外的捷径。对于值是浮点型的形式，计算过程会变得复杂耗时。</p><p>因为整型操作的执行速度通常比浮点型要快很多，所以，引擎就应该使用二进制补码来表示所有的整型和整型操作的结果。遗憾的是，那是有悖于 ECMAScript 规范的！ECMAScript 采用了 Float64，某些整数运算实际上产生的是浮点型。在下面这种情况下，对于能够产生正确的结果很重要。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Float64 has a safe integer range of 53 bits. Beyond that range,</span></span><br><span class="line"><span class="comment">// you must lose precision.</span></span><br><span class="line"><span class="number">2</span>**<span class="number">53</span> === <span class="number">2</span>**<span class="number">53</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 supports negative zeros, so -1 * 0 must be -0, but</span></span><br><span class="line"><span class="comment">// there’s no way to represent negative zero in two’s complement.</span></span><br><span class="line"><span class="number">-1</span>*<span class="number">0</span> === <span class="number">-0</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 has infinities which can be produced through division</span></span><br><span class="line"><span class="comment">// by zero.</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span> === <span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="number">-1</span>/<span class="number">0</span> === -<span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 also has NaNs.</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> === <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><p>左边的值都是整型，而右边的却是浮点型。以上的操作在使用 32 位二进制补码的形式是没法正确执行的。JavaScript 引擎必须确保整型操作被合理地处理以生成想要的 Float64 结果。</p><p>对于在 31 位有符号整数范围内的小整数，V8 有特殊的表示形式，称为 Smi。对于非 Smi 的数值会被表示为 HeapObject，它是内存中某些实体的地址。我们使用一种特殊的 HeapObject，即所谓的 HeapNumber，来表示超出 Smi 范围的数字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> -<span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">-(<span class="number">2</span>**<span class="number">30</span>)<span class="number">-1</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  -(<span class="number">2</span>**<span class="number">30</span>) <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">-42</span> <span class="comment">// Smi</span></span><br><span class="line">        <span class="number">-0</span> <span class="comment">// HeapNumber</span></span><br><span class="line">         <span class="number">0</span> <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">4.2</span> <span class="comment">// HeapNumber</span></span><br><span class="line">        <span class="number">42</span> <span class="comment">// Smi</span></span><br><span class="line">   <span class="number">2</span>**<span class="number">30</span><span class="number">-1</span> <span class="comment">// Smi</span></span><br><span class="line">     <span class="number">2</span>**<span class="number">30</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  <span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">       <span class="literal">NaN</span> <span class="comment">// HeapNumber</span></span><br></pre></td></tr></table></figure><p>如上所示，某些数字被表示为 Smi，其它数字被表示为 HeapNumber。V8 对 Smi 专门优化，因为在真实的 JavaScript 编程中，小的整数是非常普遍的。Smi 没必要在内存中分配专用的实体，而且可以素快速地整型操作。</p><h2 id="Smi-vs-HeapNumber-vs-MutableHeapNumber"><a href="#Smi-vs-HeapNumber-vs-MutableHeapNumber" class="headerlink" title="Smi vs. HeapNumber vs. MutableHeapNumber"></a>Smi vs. HeapNumber vs. MutableHeapNumber</h2><p>有以下对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  x: <span class="number">42</span>,  <span class="comment">// Smi</span></span><br><span class="line">  y: <span class="number">4.2</span>, <span class="comment">// HeapNumber</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>x 的值 42 被编程为 Smi，因此它被存储在对象里。另一方面值 4.2 需要一个独立的实例（空间）来保存这个值，并且这个对象会指向这个实体。</p><p><img src="../images/04-smi-vs-heapnumber.svg" alt="04-smi-vs-heapnumber" title="04-smi-vs-heapnumber"></p><p>运行以下 JavaScript 代码片段：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o.x += <span class="number">10</span>;</span><br><span class="line"><span class="comment">// → o.x is now 52</span></span><br><span class="line">o.y += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → o.y is now 5.2</span></span><br></pre></td></tr></table></figure><p>这种情况下，x 的值可以就地更新，因为新的值 52 也在 Smi 的范围内。</p><p><img src="../images/05-update-smi.svg" alt="05-update-smi" title="05-update-smi"></p><p>然而，新的值 <code>y=5.2</code> 不在 Smi 范围内且不同于之前的值 4.2，因此 V8 为 y 重新分配了新的 HeapNumber 实体。</p><p><img src="../images/06-update-heapnumber.svg" alt="06-update-heapnumber" title="06-update-heapnumber"></p><p>HeapNumber 是不可变的，它使得某些优化成为可能。例如，我们把 y 赋值给 x：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">o.x = o.y;</span><br><span class="line"><span class="comment">// → o.x is now 5.2</span></span><br></pre></td></tr></table></figure><p>我们只需要把它连接到同一个 HeapNumber 上而不是重新分配一个新的实体（空间）。</p><p><img src="../images/07-heapnumbers.svg" alt="07-heapnumbers" title="07-heapnumbers"></p><p>HeapNumber 不可变也存在缺点，如果更新的值经常不在 Smi 的范围内，它就会变慢，例如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a `HeapNumber` instance.</span></span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">0.1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// Create an additional `HeapNumber` instance.</span></span><br><span class="line">  o.x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行创建了一个 HeapNumber 实例，其初始值为 0.1。在循环体中值从 1.1，2.1，3.1，4.2 变到 5.1，一共创建了 6 个 HeapNumber 实例，其中 5 个会在循环结束后变没有任何用处。</p><p><img src="../images/08-garbage-heapnumbers.svg" alt="08-garbage-heapnumbers" title="08-garbage-heapnumbers"></p><p>为了避免这种情况，作为优化，V8 提供了就地更新非 Smi 数值的方法。当一个字段对应着非 Smi 的数值，V8 会在 shape 上将这个字段标记为 Double，并分配一个保存 Float64 的 MutableHeapNumber 实体。</p><p><img src="../images/09-mutableheapnumber.svg" alt="09-mutableheapnumber" title="09-mutableheapnumber"></p><p>当字段里的值发生变化时，V8 不必分配一个新的 HeapNumber，而是在 MutableHeapNumber 实体中就地更新。</p><p><img src="../images/10-update-mutableheapnumber.svg" alt="10-update-mutableheapnumber" title="10-update-mutableheapnumber"></p><p>然而，需要注意的是，MutableHeapNumber 中的值是可以改变的，所以值不应该传来传去的。</p><p><img src="../images/11-mutableheapnumber-to-heapnumber.svg" alt="11-mutableheapnumber-to-heapnumber" title="11-mutableheapnumber-to-heapnumber"></p><p>例如，你把 <code>o.x</code> 赋值给变量 y，你不希望 y 会随着 <code>o.x</code> 的改变而改变！所以在给 y 赋值前，必须将 <code>o.x</code> 的值重新包装成 HeapNumber。</p><p>对于浮点型，V8 已经默默地包装了一下。但是，对于小的整数也采用和 MutableHeapNumber 相同的方法，就会显得浪费，因为 Smi 本就是一种更高效的表现形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// → no “boxing” for `x` in object</span></span><br><span class="line"></span><br><span class="line">object.x += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → update the value of `x` inside object</span></span><br></pre></td></tr></table></figure><p>为了避免低效率，我们会在 shape 上为小整数对应的字段上标记 Smi，并且会原地更新数值，只要这个数值在 Smi 范围内。</p><p><img src="../images/12-smi-no-boxing.svg" alt="12-smi-no-boxing" title="12-smi-no-boxing"></p><h2 id="Shape-deprecations-and-migrations"><a href="#Shape-deprecations-and-migrations" class="headerlink" title="Shape deprecations and migrations"></a>Shape deprecations and migrations</h2><p>如果一个字段里包含的值在 Smi 范围内，之后又不属于 Smi 范围，这中间发生了什么？现有两个对象，它们的 x 属性值都是 Smi 表示形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// → objects have `x` as `Smi` field now</span></span><br><span class="line"></span><br><span class="line">b.x = <span class="number">0.2</span>;</span><br><span class="line"><span class="comment">// → `b.x` is now represented as a `Double`</span></span><br><span class="line"></span><br><span class="line">y = a.x;</span><br></pre></td></tr></table></figure><p>这两个对象都指向同一个 shape，x 属性特性 Representation 被标记为 Smi：</p><p><img src="../images/13-shape.svg" alt="13-shape" title="13-shape"></p><p>当 <code>b.x</code> 变成 Double 形式，V8 会创建一个新的 shape，属性 x 的 Representation 被标记为 Double 且指向之前的空 shape。V8 也会为属性 x 分配一个 MutableHeapNumber 实体用来保存值 0.2。然后让对象 b 指向新创建的 shape 并且内部偏移量为 0 的位置指向刚分配的 MutableHeapNumber 实体。最后，我们把旧的 shape 标记为废弃的，并断开与过渡树（transition tree）的链接。这就完成了从空 shape 到新 shape 的过渡。</p><p><img src="../images/14-shape-transition.svg" alt="14-shape-transition" title="14-shape-transition"></p><p>我们不能同时完全删除旧 shape，因为对象 a 还在使用，而且短时间找到所有链接到旧 shape 的对象并更新它们，对 V8 来说是笔很大的开销。相反，V8 不急着处理：只有在改变对象 a 的时候才开始迁移到新的 shape。最终，标记为废弃的 shape 会慢慢淡出视野并被垃圾回收机制抹除。</p><p><img src="../images/15-shape-deprecation.svg" alt="15-shape-deprecation" title="15-shape-deprecation"></p><p>更棘手的问题是，如果对象上属性特性 Representation 发生变化的属性不是 shape 链上的最后一个，又会发生什么呢？</p><p><img src="../images/16-split-shape.svg" alt="16-split-shape" title="16-split-shape"></p><p>从产生分支的 shape 开始，我们为属性 y 创建了一个新的过渡链且 y 被标记为 Double。我们在使用新的过渡链时，也就意味着旧的过渡链将被废弃。在最后一步，我们把实例 o 迁移到新的 shape 并用 MutableHeapNumber 保存 y 的值。就这样，新对象不再使用老的那一套，一旦旧的 shape 上的链接都被移除掉，旧 shape 也会从过渡树上消失。</p><h2 id="Extensibility-and-integrity-level-transitions"><a href="#Extensibility-and-integrity-level-transitions" class="headerlink" title="Extensibility and integrity-level transitions"></a>Extensibility and integrity-level transitions</h2><p><code>Object.preventExtensions()</code> 防止将新属性添加到对象中。如果你这么做了，它将会抛异常。（如果是在非严格模式下，它不会抛异常而是默认什么都不做。）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br></pre></td></tr></table></figure><p><code>Object.seal</code> 与 <code>Object.preventExtensions</code> 相似，但是它会把所有的属性标记为不可配置，这就意味着你不能删除它们，或改变他们的可枚举性，可配置性，可写性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br></pre></td></tr></table></figure><p><code>Object.freeze</code> 与 <code>Object.seal</code> 相似，但是它将所有属性标记为不可写以防止属性值被修改。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br><span class="line">object.x = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot assign to read-only property x</span></span><br></pre></td></tr></table></figure><p>让我们来思考一个具体的例子，有两个都只有属性 y 的对象，并阻止第二个对象有任何的扩展。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(b);</span><br></pre></td></tr></table></figure><p>就如我们所知的，从空的 shape 过渡到一个有属性 x （被标记为 Smi）的新 shape 上。当我们阻止 b 的扩展时，我们会过渡到标记为不可扩展的新 shape 上。这个新 shape 没有任何属性，仅仅作为一个标识。</p><p><img src="../images/17-shape-nonextensible.svg" alt="17-shape-nonextensible" title="17-shape-nonextensible"></p><p>注意，我们不能就地更新有 x 的 shape，因为对象 a 依然是可扩展的。</p><h2 id="The-React-performance-issue"><a href="#The-React-performance-issue" class="headerlink" title="The React performance issue"></a>The React performance issue</h2><p>让我们用以上学到的知识来解析下 <a href="https://github.com/facebook/react/issues/14365" rel="external nofollow noopener noreferrer" target="_blank">the recent React issue #14365</a>。简单重现这个 bug：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(o);</span><br><span class="line">o.y = <span class="number">0.2</span>;</span><br></pre></td></tr></table></figure><p>有一个拥有两个字段的对象，而且它们的属性特性 Representation 被标记为 Smi。我们阻止对象的进一步扩展，但最终我们还是强制改变第二字段的属性特性 Representation 的值（Double）。</p><p>就如之前学到的，大致流程如下：</p><p><img src="../images/18-repro-shape-setup.svg" alt="18-repro-shape-setup" title="18-repro-shape-setup"></p><p>每个属性的特性 Representation 都被标记为 Smi，并最终过渡到被标记为不可扩展的 shape 上。</p><p>我们需要将 y 的属性特性 Representation 标记为 Double，这意味着我们需要从引入 y 属性之前的 shape 开始。在这个例子中，就是引入 x 属性的那个 shape。但是， V8 会很困惑，因为当前的 shape 是不可扩展的，而找到的 shape 却是可扩展的。V8 不知道怎么去处理这个过渡树。因此，V8 不再试图搞清楚这些关系，而是创建了一个独立的 shape，这个 shape 和先前的过渡树没有任何关联，而且也不被任何其它对象共享。可以把它当作孤立的 shape：</p><p><img src="../images/19-orphaned-shape.svg" alt="19-orphaned-shape" title="19-orphaned-shape"></p><p>你可以想象，如果有很多对象的话，这样会变得很糟糕，因为整个 shape 系统已经失去价值。</p><p>在 React 的案例中，当开始分析数据时，FiberNode 上的一些字段需要记录时间戳。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>这些字段（比如，actualStartTime）初始化值是 0 或 -1，因此属性特性 Representation 为 Smi。但是，之后由 <code>performance.now()</code> 生成的浮点型数值被保存在这些字段中，因此属性特性 Representation 被标记为 Double。除此之外，React 还阻止 FiberNode 实例扩展属性。</p><p>刚开始的状况如下：</p><p><img src="../images/20-fibernode-shape.svg" alt="20-fibernode-shape" title="20-fibernode-shape"></p><p>如预期，两个实例共享着 shape 树。但是之后，一旦你存储了真实的时间戳，V8 就会无从下手：</p><p><img src="../images/21-orphan-islands.svg" alt="21-orphan-islands" title="21-orphan-islands"></p><p>V8 先后给 node1，node2 分别分配了独立的 shape，且它们之间没有任何关联。真实中的 React 应用有着数万个这样的 FiberNode。你可以想象，这种情况将会严重影响到 V8 的性能。</p><p>幸运的是，这个<a href="https://chromium-review.googlesource.com/c/v8/v8/+/1442640/" rel="external nofollow noopener noreferrer" target="_blank">问题</a>在 <a href="https://v8.dev/blog/v8-release-74" rel="external nofollow noopener noreferrer" target="_blank">V8 v7.4</a> 中解决了。研发人员找到了改变属性特性 Representation 的方法，V8 终于知道它该怎么做了：</p><p><img src="../images/22-fix.svg" alt="22-fix" title="22-fix"></p><p>两个 FiberNode 实例指向不可扩展的 shape，shape 中的 <code>actualStartTime</code> 被标记为 Smi。当 <code>node1.actualStartTime</code> 被分配新的值时，将会生成一条新的过渡链，而且之前的过渡链会被标记为废弃的。</p><p><img src="../images/23-fix-fibernode-shape-1.svg" alt="23-fix-fibernode-shape-1" title="23-fix-fibernode-shape-1"></p><p>可以注意到，现在的过渡链可以正确的过渡转移。</p><p><img src="../images/24-fix-fibernode-shape-2.svg" alt="24-fix-fibernode-shape-2" title="24-fix-fibernode-shape-2"></p><p>当 <code>node2.actualStartTime</code> 也被重新分配时，所有的链接都指向了新的 shape，过渡树中废弃的部分将会被垃圾回收机制清除。</p><p>React 团队将 FiberNode 所有关于时间的字段都改成了 Double 形式从而缓解这个问题。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// Force `Double` representation from the start.</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="comment">// Later, you can still initialize to the value you want:</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>由 React 具体的 Bug 引出了 V8 特有的问题，通常来说，开发者不必对某个版本的 JavaScript 引擎做优化。不过，当时事情向不好的方向发展时，我们也不会束手无策。</p><p>要知道 JavaScript 引擎在幕后做了很多事，尽可能的不要去混合类型。例如，给一个数字字段初始化为 null，这样做的话会使得一些优化化为泡影，而且可读性降低。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don’t do this!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">null</span>;</span><br><span class="line">  y = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">0.1</span>;</span><br><span class="line">p.y = <span class="number">402</span>;</span><br></pre></td></tr></table></figure><p>换句话说，写可读性代码，性能自然会紧跟其后！</p><h2 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h2><p>本文覆盖了一下几点：</p><ol><li>JavaScript 区分了 primitives 和 objects，而且 typeof 不靠谱。</li><li>即使是相同类型的值也会有不同的表达形式。</li><li>JavaScript 引擎会为每个属性找到最优的表达形式。</li><li>讨论了 V8 处理 shape 的废弃，迁移和可扩展。</li></ol><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>以相同的方式初始化对象类型，这样 shape 系统会更高效。</li><li>为你的字段选择合理的值（「Representation」：Smi 或 非 Smi）。</li></ol>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>从Function入手原型链</title>
    <url>/%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><p><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-function-objects" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>Function</em></strong></a> 是函数? 是构造函数? 还是函数对象? 在翻阅 <strong><em>ECMA</em></strong> 规范时, 这几个名词也是无缝切换中, 稍不留神就可能跑偏了.<br>都应该知道, 构造函数是用来打造具有相同属性和行为事物的模具.<br>在作为构造函数之前, 它首先是个函数, 函数是可以被调用的(这也是区别于其它对象的因素). 它是由一系列语句组成, 并最终返回一个值. 每一个函数被创建的时候, 都有一个 <strong><em>prototype</em></strong> 属性.<br>普通函数能够变成构造函数, 那都是 <a href="#new操作符"><strong><em>new</em></strong></a> 将函数的 <strong><em>prototype</em></strong> 和生成的实例关联起来了. 换句话说, 每个普通函数都有称为构建函数的潜质.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见的构造函数模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> man_1 = <span class="keyword">new</span> Man(<span class="string">'夜曉宸'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要经过 new 调教后, 我也可以被称为构造函数了</span></span><br><span class="line"><span class="keyword">let</span> man_2 = <span class="keyword">new</span> man(<span class="string">'夜曉宸'</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="Function和内置函数"><a href="#Function和内置函数" class="headerlink" title="Function和内置函数"></a>Function和内置函数</h2><p>都说函数是 <strong><em>JavaScript</em></strong> 里的头等对象, 这话一点不假. 在 <a href="https://www.yexiaochen.com/为强制类型转换正名/#more"><strong><em>为强制类型转换正名</em></strong></a> 里已经提到过, <strong><em>JavaScript</em></strong> 里的数据类型除了基本数据类型, 就是复杂数据类型. 而这些复杂数据类型都和 <strong><em>Function</em></strong> 有着密切关系.</p><h3 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a>Function构造函数</h3><p>函数的身影在 <strong><em>JavaScript</em></strong> 中随处可见, 有造字符串类型的 <strong><em>String</em></strong> 函数, 有造数值类型的 <strong><em>Number</em></strong> 函数, 除了这些内置函数, 还有上面我自己写的 <strong><em>Man</em></strong> 和 <strong><em>man</em></strong> 函数. <strong><em>JavaScript</em></strong> 的作者在写 <strong><em>JavaScript</em></strong> 语言的时候, 可能知道有且需要 <strong><em>String</em></strong>, <strong><em>Number</em></strong> 这样的函数处理写数据, 于是有了内置函数这么一说. 那么内置函数满足不了我们的需求呢, 如何去创建一个函数呢? 其实, 在没有这些内置函数之前, 就有了这么一个东西. 那就是为创建函数而生的函数 —— <strong><em>Function</em></strong>. 等会儿, 有点绕😵, 创建函数的函数? 那岂不是把自己也给创建了🤔? 是的, 没错, 就是这么一个奇葩的存在.</p><blockquote><p>The Function constructor is the %Function% intrinsic object and the initial value of the Functionproperty of the global object. When Functionis called as a function rather than as a constructor, it creates and initializes a new Function object. Thus the function call Function(…)is equivalent to the object creation expression new Function(…)with the same arguments.</p></blockquote><p>所以说, 包括这些内置函数, 它们都是由 <strong><em>Function</em></strong> 构建函数造出来的. 如何去验证函数是不是函数造出来的呢?</p><hr><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><blockquote><p>All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance.</p></blockquote><p>每个普通对象都有一个 <strong><em>[[Prototype]]</em></strong>, 这个属性就是用来实现原型继承用的.<br>上面👆也提到了, 在用构造函数造 <strong><em>new</em></strong> 出实例对象时, 实例对象内部的 <strong><em>[[Prototype]]</em></strong> 会关联到构造函数的 <strong><em>prototype</em></strong> 所指向的对象. <strong><em>new</em></strong> 主要做以下两件事:</p><ol><li>将实例对象的 <strong><em>[[Prototype]]</em></strong> 关联到构造函数的 <strong><em>prototype</em></strong> 上.</li><li>将 <strong><em>this</em></strong> 绑定到新创建的实例对象上, 并调用构造函数(就是将函数体里的语句执行一遍).</li></ol><p>类似于:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// _proto_ 和 [[Prototype]] 不是同一个东西, 后者是内部使用的.</span></span><br><span class="line">    ojb._proto_ = func.prototype;</span><br><span class="line">    func.call(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Object.getPrototypeOf()</code> 是用来检测指定对象内部 <strong><em>[[Prototype]]</em></strong> 属性的值.<br>对于上面👆的 <strong><em>Man</em></strong> 和 <strong><em>man_1</em></strong> 关系, 试一波.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(man_1) === Man.prototype  <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Function和函数"><a href="#Function和函数" class="headerlink" title="Function和函数"></a>Function和函数</h3><p>回头再看看 <strong>String</strong>, <strong>Number</strong>, <strong>Boolean</strong>, <strong>Array</strong>, <strong>Object</strong>, <strong>Function</strong>, <strong>RegExp</strong>, <strong>Date</strong>, <strong>Error</strong>, <strong>Symbol</strong> 这些内置函数和 <strong><em>Function</em></strong> 构造函数的关系(注意包含了 <strong><em>Function</em></strong> 自身). 这里是把这些内置函数作为由 <strong><em>Function</em></strong> 构造出来的实例对象对待的. <em>(函数也是对象的一子类型)</em></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">String</span>) === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Number</span>) === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Boolean</span>) === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Array</span>) === <span class="built_in">Function</span>.prototype     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>) === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>) === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">RegExp</span>) === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Date</span>) === <span class="built_in">Function</span>.prototype      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Error</span>) === <span class="built_in">Function</span>.prototype     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Symbol</span>) === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Man) === <span class="built_in">Function</span>.prototype       <span class="comment">// true 👀👆🌰</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(man_1) === <span class="built_in">Function</span>.prototype     <span class="comment">// false 👀👆🌰</span></span><br></pre></td></tr></table></figure><p>在之前的 <a href="https://www.yexiaochen.com/为强制类型转换正名/#more"><strong><em>为强制类型转换正名</em></strong></a> 已经知道了, <strong><em>JavaScript</em></strong> 里的对象类型基本上也就是那么多. 以上函数的原型链, 最终会指向 <strong><em>Function.prototype</em></strong> (仅为目前, 后面还有 <strong><em>Object.prototype</em></strong> 和 <strong><em>null</em></strong> ). 这也是解释了为什么任何一个普通函数都可以调用 <strong><em>call</em></strong> , <strong><em>apply</em></strong> 等 <strong><em>Functon.prototype</em></strong> 上的方法.</p><hr><h3 id="Function和原型"><a href="#Function和原型" class="headerlink" title="Function和原型"></a>Function和原型</h3><p>所有的函数的原型链里都将会出现 <strong><em>Functon.prototype</em></strong>, 由构造函数 <strong><em>new</em></strong> 出来的实例对象的 <strong><em>[[Prototype]]</em></strong> 会关联到构造函数 <strong><em>prototype</em></strong> 上.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(num) === <span class="built_in">Number</span>.prototype     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Man) === <span class="built_in">Function</span>.prototype   <span class="comment">// true 👀👆🌰</span></span><br></pre></td></tr></table></figure><p>到目前为止, 任何函数或对象都可以追溯到 <strong><em>Functon.prototype</em></strong> 和 构造函数的 <strong><em>prototype</em></strong> 上. 那么接下来, 又如何沿着原型链再往后找呢?</p><blockquote><p>The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object.</p></blockquote><p>这句话告诉我们, <strong><em>Function</em></strong> 的原型是一个函数对象. <del>可我们也知道, 所有的函数都应该来自于 <strong><em>Function</em></strong>. 由此可推导, <strong><em>Function.prototype</em></strong> 内部属性 [[Prototype]] 应指向 <strong><em>Function.prototype</em></strong>. 实际上并不是这样. 同样情况的还有 <strong><em>Array</em></strong>.</del></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>.prototype) === <span class="built_in">Function</span>.prototype   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><del><strong><em>ECMA</em></strong> 规范也给出了解释, 不知是不是解释这个的.</del></p><blockquote><p>It does not have a [[Construct]] internal method so it is not a constructor.</p></blockquote><blockquote><p>NOTE The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p></blockquote><p><del>以上推导可忽略.</del> 所以呢,</p><blockquote><p>The value of the [[Prototype]] internal slot of the Function prototype object is the intrinsic object %ObjectPrototype%.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>.prototype) === <span class="built_in">Object</span>.prototype     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其它的构造函数也是一样.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">String</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Number</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Boolean</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an Array exotic objects.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Array</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Function</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is a built-in function object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">RegExp</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Date</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Error</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// true String.prototype is an ordinary object.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Symbol</span>.prototype) === <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p>所有的函数或对象的原型链都会追溯到 <strong><em>Object.prototype</em></strong> 上, 难道这里就是终点么? 不是的, 还有个 <strong><em>null</em></strong> . 所以, 最终,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) === <span class="literal">null</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><p>总结一波:</p><ol><li><strong><em>Function</em></strong> 是构造函数的地方, 构造函数是函数, 内建函数也是函数.</li><li>被构造出来的实例对象内部属性 <strong><em>[[Prototype]]</em></strong> 会关联到构造函数的 <strong><em>prototype</em></strong> 所指向的对象.</li><li><p><strong><em>prototype chain</em></strong> 的走向为:</p><ol><li><code>instance =&gt; constructor.prototype =&gt; Object.prototype =&gt; null</code>. (构造函数造出的实例对象走向)</li><li><code>function =&gt; Function.prototype =&gt; Object.prototype =&gt; null</code>.(函数走向)</li><li>…</li></ol></li></ol><p>上图说明一切.<br><img src="../images/Function和原型链.jpg" alt="Function和原型链"></p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Function</tag>
        <tag>函数</tag>
        <tag>new操作符</tag>
        <tag>原型链</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>为强制类型转换正名</title>
    <url>/%E4%B8%BA%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%AD%A3%E5%90%8D/</url>
    <content><![CDATA[<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.</p></blockquote><p>作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.</p><p><strong>猜猜看</strong>😏:</p><ol><li>作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: <code>&#39;hello&#39;.charAt(0)</code> (<a href="#内置类型和内建函数的关系">内置类型和内建函数的关系</a>)</li><li><code>a &amp;&amp; (b || c)</code> 这波操作我们知道, 那么 <code>if (a &amp;&amp; (b || c))</code>, 这里又做了哪些操作? (<a href="#条件判断">||和&amp;&amp;</a>)</li><li><code>if (a == 1 &amp;&amp; a== 2) { dosomething }</code>, <strong>dosomething</strong>竟然执行了, 什么鬼? (<a href="#ToPrimitive">ToPrimitive</a>)</li><li><code>[] == ![]</code> =&gt; true ?; <code>false == []</code> =&gt; true ?; <code>&quot;0&quot; == false</code> =&gt; true ?(<a href="#抽象相等">抽象相等</a>)</li><li><code>if (~indexOf(&#39;a&#39;))</code>, 这波操作熟悉不? (<a href="#隐式强制类型转换">+/-/!/~</a>)</li><li>在<strong>String</strong>, <strong>Number</strong>, <strong>Boolean</strong>类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (<a href="#抽象操作">抽象操作</a>)</li></ol><p>下面就要学会用实力碰运气.</p><hr><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JavaScript 有七种内置类型. <strong>空值</strong>: null, <strong>未定义</strong>: undefined, <strong>布尔值</strong>: boolean, <strong>数字</strong>: number, <strong>字符串</strong>: string, <strong>对象</strong>: object, <strong>符号</strong>: symbol. 除 <strong>对象</strong>:object, 为复杂数据类型, 其它均为基本数据类型.</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>常用的内建函数: <strong>String()</strong>, <strong>Number()</strong>, <strong>Boolean()</strong>, <strong>Array()</strong>, <strong>Object()</strong>, <strong>Function()</strong>, <strong>RegExp()</strong>, <strong>Date()</strong>, <strong>Error()</strong>, <strong>Symbol()</strong>.</p><h3 id="内置类型和内建函数的关系"><a href="#内置类型和内建函数的关系" class="headerlink" title="内置类型和内建函数的关系"></a>内置类型和内建函数的关系</h3><p>为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了<strong><em><code>问题 1</code></em></strong>.</p><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><strong><em>typeof</em></strong> =&gt; 基本类型的检测均有同名的与之对应. <strong>null</strong> 除外(不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为 0 会被判断为 Object 类型, null 的二进制表示为0, 前三位自然为0, 所以执行 typeof 时会返回 <code>&#39;object&#39;</code>.), null是假值, 也是唯一一个typeof检测会返回 <code>&#39;object&#39;</code> 的基本数据类型值.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">'object'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>复杂数据类型typeof检测返回 <code>&#39;object&#39;</code>, function(函数)除外. 函数因内部属性 <code>[[Call]]</code> 使其可被调用, 其实属于可调用对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p><strong><em>Object.prototype.toString</em></strong> =&gt; 通过typeof检测返回<code>&#39;object&#39;</code>的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(…)来查看.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(num))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [object String]</span></span><br><span class="line"><span class="comment">// [object Number]</span></span><br><span class="line"><span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><hr><h2 id="抽象操作"><a href="#抽象操作" class="headerlink" title="抽象操作"></a>抽象操作</h2><p>在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.1" rel="external nofollow noopener noreferrer" target="_blank">ToPrimitive</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.8" rel="external nofollow noopener noreferrer" target="_blank">ToString</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="external nofollow noopener noreferrer" target="_blank">ToNumber</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.2" rel="external nofollow noopener noreferrer" target="_blank">ToBoolean</a></strong>. 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则(显式和隐式的命名叫法来自《你不知道的JavaScript》). 这里就解释了<strong><em><code>问题 5</code></em></strong>和<strong><em><code>问题 6</code></em></strong>.</p><h3 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h3><p>该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法<code>[[DefaultValue]]</code> 遵循一定规则返回非复杂数据类型, 规则详见<strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8" rel="external nofollow noopener noreferrer" target="_blank">DefaultValue</a></strong>. 故 <strong>ToString</strong>, <strong>ToNumber</strong>, <strong>ToBoolean</strong>在处理Object时, 会先经过<strong>ToPrimitive</strong>处理返回基本类型值.</p><p><strong><code>[[DefaultValue]](hint)</code>语法:</strong><br><code>[[DefaultValue]]</code>的规则会依赖于传入的参数<code>hint</code>, <strong>ToString</strong>传入的 <code>hint</code> 值为 <code>String</code>, <strong>ToNumber</strong>传入的 <code>hint</code> 值为 <code>Number</code>.</p><ol><li><code>[[DefaultValue]](String)</code> =&gt; 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]](Number)</code> =&gt; 该规则正好和上规则调用 <code>toString</code>, <code>valueOf</code> 的顺序相反. 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]]()</code> =&gt; 未传参时, 按照 <code>hint</code>值为 <code>Number</code> 处理. <code>Date</code> 对象除外, 按照<code>hint</code>值为 <code>String</code> 处理.</li></ol><p>现在我们就用以上的知识点来解释<strong><em><code>问题 3</code></em></strong>是什么鬼.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"0"</span>); <span class="comment">// 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a_1:'</span>, a);</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a==1 &amp; a==2'</span>, <span class="string">'i:'</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a==1 &amp; a==2 i: 3</span></span><br></pre></td></tr></table></figure><p>我们改写了内建函数 <strong><em>Number</em></strong> 原型上的 <code>valueOf</code> 方法, 并使得一个字符串转换成 <strong><em>Number</em></strong> 对象, 第一次 <strong><em>Object</em></strong> 类型和 <strong><em>Number</em></strong> 类型做比较时, <strong><em>Object</em></strong> 类型将进行 <strong><em>ToPrimitive</em></strong> 处理(<a href="#抽象相等">抽象相等</a>), 内部调用了 <strong><em>valueOf</em></strong>, 返回 <strong><em>2</em></strong>. 第二次同样的处理方式, 返回 <strong><em>3</em></strong>.</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>该抽象操作负责处理非字符串到字符串的转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">“null”</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">“undefined”</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">true =&gt; “true”; false =&gt; “false”</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">number</td><td style="text-align:center"><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.8.1" rel="external nofollow noopener noreferrer" target="_blank">ToString Applied to the Number Type</a></td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">先经<a href="#ToPrimitive">ToPrimitive</a>返回基本类型值, 再遵循上述规则</td></tr></tbody></table><h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>该抽象操作负责处理非数字到数字的转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">+0</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">NaN</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">true =&gt; 1; false =&gt; 0</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center"><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3.1" rel="external nofollow noopener noreferrer" target="_blank">ToNumber Applied to the String Type</a></td></tr><tr><td style="text-align:center">number</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">先经<a href="#ToPrimitive">ToPrimitive</a>返回基本类型值, 再遵循上述规则</td></tr></tbody></table><p><strong>常见的字符串转换数字:</strong></p><ol><li>字符串是空的 =&gt; 转换为0.</li><li>字符串只包含数字 =&gt; 转换为十进制数值.</li><li>字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.</li><li>字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.</li><li>字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.</li></ol><h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>该抽象操作负责处理非布尔值到布尔值转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">“” =&gt; false; 其它 =&gt; true</td></tr><tr><td style="text-align:center">number</td><td style="text-align:center">+0, −0, NaN =&gt; false; 其它 =&gt; true</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">true</td></tr></tbody></table><p><strong>真值</strong> &amp; <strong>假值</strong><br>假值(强制类型转换<strong>false</strong>的值) =&gt; <code>undefined</code>, <code>null</code>, <code>false</code>, <code>+0</code>, <code>-0</code>, <code>NaN</code>, <code>&quot;&quot;</code>.<br>真值(强制类型转换<strong>true</strong>的值) =&gt; 除了假值, 都是真值.</p><p><strong><em>特殊的存在</em></strong><br>假值对象 =&gt; documen.all 等. eg: <code>Boolean(window.all)</code> // false</p><hr><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><h3><a href="#" class="headerlink" title="+/-/!/~"></a>+/-/!/~</h3><ol><li><strong><code>+/- 一元运算符</code></strong> =&gt; 运算符会将操作数进行ToNumber处理.</li><li><strong><code>!</code></strong> =&gt; 会将操作数进行ToBoolean处理.</li><li><strong><code>~</code></strong> =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (…)中作类型转换时, 只有<code>-1</code>时, 才为假值.</li><li><strong><code>+加号运算符</code></strong> =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.</li></ol><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ol><li><code>if (...)</code>, <code>for(;;;)</code>, <code>while(...)</code>, <code>do...while(...)</code>中的条件判断表达式.</li><li><code>? :</code> 中的条件判断表达式.</li><li><code>||</code> 和 <code>&amp;&amp;</code> 中的中的条件判断表达式.</li></ol><p>以上遵循ToBoolean规则.</p><h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="||和&amp;&amp;"></a>||和&amp;&amp;</h3><ol><li>返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.</li><li><strong><code>||</code></strong> =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;</li><li><strong><code>&amp;&amp;</code></strong> =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;</li></ol><p>结合条件判断, 解释下<strong><em><code>问题 2</code></em></strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">if</span> (a &amp;&amp; (b || c)) &#123;</span><br><span class="line">    dosomething()</span><br><span class="line">&#125;</span><br><span class="line">a &amp;&amp; (b || c) 返回 <span class="string">'hello'</span>, <span class="keyword">if</span>语句中经Toboolean处理强制类型转换为<span class="literal">true</span>.</span><br></pre></td></tr></table></figure><h3 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h3><p>这里的知识点是用来解释 <strong><em>问题 4</em></strong> 的, 也是考验人品的地方. 这下我们要靠实力拼运气.</p><ol><li><p>同类型的比较.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ <span class="number">0</span> == <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false, 唯一一个非自反的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>null</em></strong> 和 <strong><em>undefined</em></strong> 的比较.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>Number</em></strong> 类型和 <strong><em>String</em></strong> 类型的比较. =&gt; <strong><em>String</em></strong> 类型要强制类型转换为 <strong><em>Number</em></strong> 类型, 即 <strong><em>ToNumber(String)</em></strong>.(参见<a href="#ToNumber">ToNumber</a>)</p></li><li><strong><em>Boolean</em></strong> 类型和其它类型的比较. =&gt; <strong><em>Boolean</em></strong> 类型要强制类型转换为 <strong><em>Number</em></strong> 类型, 即 <strong><em>ToNumber(Boolean)</em></strong>.(参见<a href="#ToNumber">ToNumber</a>)</li><li><strong><em>Object</em></strong> 类型和 <strong><em>String</em></strong> 类型或 <strong><em>Number</em></strong> 类型. =&gt; <strong><em>Object</em></strong> 类型要强制转换为基本类型值, 即 <strong><em>ToPrimitive(Object)</em></strong>.(参见<a href="#ToPrimitive">ToPrimitive</a>)</li><li>其它情况, <strong><em>false</em></strong>.</li></ol><p>回头看看<strong><em>问题 4</em></strong>中的等式. <code>[] == ![]</code>, <code>false == []</code>, <code>&quot;0&quot; == false</code>.<br><code>[] == ![]</code> =&gt; <code>!</code> 操作符会对操作数进行<strong><em>ToBoolean</em></strong>处理, <code>[]</code> 是真值, <code>!true</code> 则为 <strong><em>false</em></strong>. 再遵循第 <strong><em>4</em></strong> 点, <strong><em>Boolean</em></strong> 类型经过 <strong><em>ToNumber</em></strong> 转换为 <strong><em>Number</em></strong>类型, 则为数值 <code>0</code>. 再遵循第 <strong><em>5</em></strong> 点, 对 <code>[]</code> 进行 <strong><em>ToPrimitive</em></strong> 操作, 先后调用 <code>valueOf()</code>, <code>toString()</code>直到返回基本类型, 直到返回 <code>&quot;&quot;</code>. <em>(先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; “”, 基本类型值, 返回该基本类型值.)</em>. 再遵循第 <strong><em>3</em></strong> 点, 对 <code>&quot;&quot;</code> 进行 <strong><em>ToNumber</em></strong>处理, 则为数值 <code>0</code>. 到此, <code>0 == 0</code>, 再遵循第 <strong><em>1</em></strong> 点(其实没写全😌, 详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="external nofollow noopener noreferrer" target="_blank">The Abstract Equality Comparison Algorithm</a>), return true, 完美!😏.<br><code>false == []</code> =&gt; 同理 <code>[] == ![]</code>.<br><code>&quot;0&quot; == false</code> =&gt; 同理 <code>[] == ![]</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[] == ![]   <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// true</span></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><p>运气是留给有准备的人, 所以呢, 我要准备买彩票了.😏</p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>强制类型转换</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>从观察者模式说起</title>
    <url>/%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式的定义"><a href="#观察者模式的定义" class="headerlink" title="观察者模式的定义"></a>观察者模式的定义</h2><p>Observer(观察者)是一种设计模式, 其中, 一个对象(称为 subject) 维持一系列依赖于它的观察者对象, 将有关状态的任何变更自动通知给观察者.<br>当一个目标(subject)需要告诉观察者发生了什么有趣的事情, 它会向观察者广播一个通知. 当我们不再希望某个特定的观察者获得其注册目标(subject)发出的改变通知时, 该目标可以将它从观察者列表中删除.</p><blockquote><p>“一个或多个观察者对目标的状态感兴趣, 它们通过将自己依附在目标对象上以便注册所感兴趣的内容. 目标状态发生改变并且观察者可能对这些改变感兴趣, 就会发送一个通知消息, 调用每个观察者的更新方法. 当观察者不再对目标状态感兴趣时, 它们可以简单地将自己从中分离.” ———《设计模式: 可复用面向对象软件基础》</p></blockquote><h2 id="观察者模式的理解"><a href="#观察者模式的理解" class="headerlink" title="观察者模式的理解"></a>观察者模式的理解</h2><p>从观察者模式的定义中可以对观察者模式有个大体的了解. 观察者模式中有两类, 一类被称为目标(Subject), 一类被称为观察者(Observer). Subject的工作是维护一系列的Observer, 可以对它们进行添加、删除和通知的操作. Observer的工作则是为Subject状态发生变化需要获得通知的对象提供更新接口.</p><h2 id="戏说观察者模式"><a href="#戏说观察者模式" class="headerlink" title="戏说观察者模式"></a>戏说观察者模式</h2><p>先不管观察者模式是什么, 我们可以试着想想如何从观察者模式的定义去实现这些功能. 下面我们从一个小故事说起.<br>从前有个人. 凭着天资聪颖再加上闯荡江湖多年, 无论从事什么行业都能称为行业翘楚, 算是有名气的人物.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;&#125;        <span class="comment">// 我是有个人. Subject是江湖送我的绰号.</span></span><br></pre></td></tr></table></figure><p>有一天, 有一个初创公司慕名前来拜访, 探讨如何在现在这个激烈的竞争环境下赢得一席之地.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;&#125;       <span class="comment">// 我是一家初创公司, Observer是我公司的名字.</span></span><br></pre></td></tr></table></figure><p>两人见面直奔主题.<br>‘你可以派些人来, 我给他们做培训. ’, Subject如此说道. Observer点头同意.<br>‘可是我如何才能让他们服从并执行呢?’, Subject问到. ‘我们可以向你提供统一的对接方式’, Observer回答到.<br>‘行, 谁要有兴趣谁就过来吧’</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* update是我们的对接方式, fn是我们的职能.</span></span><br><span class="line"><span class="comment">只需要走update这个流程, 我们会各司其职.</span></span><br><span class="line"><span class="comment">下面这是个我们的模子, 每个走出去的人都大体这样.*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.update = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了后续的开展, 夜曉宸也做了准备. 为随后要来的人腾出了空间, 并想好了如何接待每个人.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.observesList = [];     <span class="comment">// 这里是为参与者腾出的空间.</span></span><br><span class="line">    &#125;</span><br><span class="line">    addObserver(observer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.push(observer);       <span class="comment">// 招待每一个参与者, 就是引导参与者进入腾出的空间.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不日, Observer派人带着各自本职职务过来了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer1 = <span class="keyword">new</span> Observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;order&#125;</span>: 我是财务, 我要开始算绩效发工资了&lt;br/&gt;`</span>));</span><br><span class="line"><span class="keyword">const</span> observer2 = <span class="keyword">new</span> Observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;order&#125;</span>: 我是后勤客服, 有什么事情需要帮助的?&lt;br/&gt;`</span>));</span><br><span class="line"><span class="keyword">const</span> observer3 = <span class="keyword">new</span> Observer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">document</span>.write(<span class="string">`<span class="subst">$&#123;order&#125;</span>: 我是人事, 我要招人了&lt;br/&gt;`</span>));</span><br></pre></td></tr></table></figure><p>既然人来了, 那就接待.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();      <span class="comment">// 事务繁忙, 派了一个影分身.</span></span><br><span class="line">subject.addObserver(observer1);     <span class="comment">// 引导observer1进入房间.</span></span><br><span class="line">subject.addObserver(observer2);     <span class="comment">// 引导observer2进入房间.</span></span><br><span class="line">subject.addObserver(observer3);     <span class="comment">// // 引导observer3进入房间.</span></span><br></pre></td></tr></table></figure><p>‘既然来到了这个房间, 就要明确一点, 那就是你们得听我指令, 到时我会使用你们公司统一的对接方式’</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    notify(context) &#123;</span><br><span class="line">        <span class="comment">// 由公司提供的统一对接方式，向在场的每一个Observer传达并让其执行.</span></span><br><span class="line">        <span class="keyword">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘如果你们不想呆下去了, 可以和我说, 我可以引导你们出去’</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    removeObserver(observer) &#123;</span><br><span class="line">        <span class="comment">// 对于不再感兴趣的Observer，可以将其剔除，其不会再收到任何来自Subject的通知.</span></span><br><span class="line">        <span class="keyword">let</span> pos = <span class="keyword">this</span>.observerList.indexOf(observer);</span><br><span class="line">        <span class="keyword">this</span>.observerList.splice(pos, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘现在, 要下达指令了!’</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略</span></span><br><span class="line">subject.notify(<span class="string">'描述下各自的职能'</span>);</span><br></pre></td></tr></table></figure><p>‘好了, 这些就是我们培训的内容, 就是这么简单’<br>‘就这么简单?!?, 既然这样, 就送我出去吧, 我不想再呆下去了 ’, observer2说到.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略</span></span><br><span class="line">subject.removeObserver(observer2);</span><br></pre></td></tr></table></figure><p>到此故事告一段落了, <em><a href="https://codepen.io/yexiaochen/pen/xQqKNW" rel="external nofollow noopener noreferrer" target="_blank">Observer模式</a>在线Demo.</em></p><h2 id="再看观察者模式"><a href="#再看观察者模式" class="headerlink" title="再看观察者模式"></a>再看观察者模式</h2><p>我们从几段对话中, 稀里糊涂的完成了本文开头观察者模式所定义的那样. 有负责管理一系列依赖的对象, 有提供更新接口的对象. 我们可以看到, 当subject1发出通知时, 每个observe都能去执行. observer们的行为依赖于subject1的. 为什么能够做到这一点, 那是因为observe们的行为作为自身的一部分寄存在了subject1, subject1就可以在需要的时候去自己腾出的小屋子里通知observer们执行.<br>如果subject1 带着这么一波参加过培训的observer们回去交差, 肯定会被笑话. subject1和observer们的这种协作方式, 被称做观察者模式. 这不过是一个模式, 何时存储何种东西, 何时又去执行存储的东西那才是关键. 如果放到上面的小故事里, 那就是何时需要何种人, 何时开始去做事, 这都需要审时度势. 只有这样公司才能在激烈的竞争环境中赢得一席之地. 只有这样, 观察者模式才能发挥它最大的作用.</p>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从游戏角度说作用域</title>
    <url>/%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%A7%92%E5%BA%A6%E8%AF%B4%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是 JavaScript 里的一个非常重要和基础的概念. 很多人认为自己理解了作用域, 但是在遇到闭包时却说不出个所以然, 甚至不能识别出来.<br>闭包也是个非常重要, 且经常被误解的概念. 然而闭包就是基于作用域书写代码时所产生的自然结果. 倘若抛开作用域讲闭包, 那都是耍流氓. 闭包可以说在平时的代码里随处可见, 但真正让闭包发挥积极作用的做法是隔离作用域、模块函数等.<br>作用域机制是不能直接查看的, 我们首先模拟一个场景来尽可能的说明作用域这套规则, 然后通过代码片段和开发者工具进行验证.</p><h2 id="游戏存档"><a href="#游戏存档" class="headerlink" title="游戏存档"></a>游戏存档</h2><p>想必大家都有玩过游戏的经验. 刚开始的时候, 也就是第一关, 难度比较简单. 到了第二关的时候, 就在第一关的基础上加些难缠的角色, 难度相应地加大了. 关卡越是往后, 难缠的角色也就会越来越多.<br>可在游戏的时候, 由于各种原因, 往往我们不可能一下子通过所有的关卡, 所以游戏提供了存档的功能. 下次再玩的时候可以从存档里续上. 如果不想这样, 完全可以从头玩起.<br>为什么我们能从存档里直接跳到上次的关卡, 很显然, 这里是有记录存储的. 比如第一关有个场景食人花和海王, 第二关又多了个邪恶人等等. 每个关卡都会记录该关卡新增的角色或场景同时也会存储之前关卡的记录. 这样就保证了不同的存档的独立性, 无论在哪个关卡存档, 下次也定会续上之前的地方. 当然了, 我们也可以回到上一个关卡.</p><p><img src="../images/Aquaman.png" alt="Aquaman"><br>(<em>海王之雄风&amp;敌人之邪恶</em>)</p><h2 id="几个知识点"><a href="#几个知识点" class="headerlink" title="几个知识点"></a>几个知识点</h2><p>结合上面的场景, 我们再回头看看以下几个知识点.</p><ol><li><p>标识符: 变量、函数、属性的名字, 或者函数的参数.</p></li><li><p>每个函数都有自己的执行环境. 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行后, 栈将其环境弹出, 把控制权返回之前的执行环境.</p></li><li><p>执行环境定义了变量或函数有权访问的其它数据. 每个执行环境都有一个与之关联的变量对象, 环境中定义的所有变量和函数都保存在这个对象中. 某个执行环境中的所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁.</p></li><li><p>当代码在一个环境中执行时, 会创建变量对象的一个作用域链.</p></li><li><p>作用域链是保证对执行环境有权访问的所有变量和函数的有序访问. 作用域的前端始终都是当前执行的代码所在的变量对象. 如果这个环境是函数, 则将其活动对象作为变量对象. 活动对象在最开始只包含一个变量, 即 arguments 对象. 作用域链中的下一个变量对象来自包含(外部)环境. 全局执行环境的变量对象始终都是作用域链的最后一个对象.</p></li><li><p>当某个环境中为了读取或写入而引入一个标识符时, 必须通过搜索来确定该标识符来确定该标识符实际代表什么. 搜索过程从作用域链的前端开始, 向上逐级查询与给定名字匹配的标识符. 如果在局部环境中找到了该标识符, 搜索过程停止, 变量就绪. 如果在局部环境中没有找到该变量名, 则继续沿作用域链向上搜索. 搜索过程将一直追溯到全局环境的变量对象. 如果在全局环境中也没有找到这个标识符, 则意味着该变量尚未声明.</p></li><li><p>作用域链本质上时一个指向变量对象的指针列表, 它只引用但实际不包含变量对象.</p></li></ol><p>如果我们把以上的几个知识点串起来, 这就是所谓的作用域链规则了. 上图解释一波.(arguments 应该加到变量对象里的, 图中没体现, 疏忽)</p><p><img src="../images/ScopeChain.png" alt="Scope Chain"></p><p>现在我们从最后两行说起,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outer = outerFn(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> inner = outer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>执行 <code>outer = outerFn(10)</code> 后, outer 拥有了返回函数的引用. <code>outer(10)</code> 在执行的时候它会创建 <strong>属于它自己</strong> 的作用域链, 这里包含函数所处外部环境的变量对象.<br>在读取 initial 变量时, 在 Inner 变量对象中没有检索到, 它会沿着作用域链向上搜索, 在 outer 变量对象里找到了该标识符, 搜索过程停止, 变量就绪.<br>函数在定义的时候就已经决定了之后执行时, 作用域里将包含什么. 这也解释了, 即使我们把定义在函数内部的函数扔在外边执行也能访问到函数内部的变量. 这和内部函数在哪执行没有半毛钱关系.<br>为什么强调 <strong>属于它自己</strong> 的呢?</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> innerFn_1 = outer();</span><br><span class="line"><span class="keyword">let</span> a_1 = innerFn_1()</span><br><span class="line"><span class="keyword">let</span> innerFn_2 = outer();</span><br><span class="line"><span class="keyword">let</span> a_2 = innerFn_2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a_1_1 = innerFn_1();</span><br><span class="line"><span class="keyword">let</span> a_2_2 = innerFn_2();</span><br></pre></td></tr></table></figure><p>innerFn_1 和 innerFn_2 都属于自己的作用域链, 而 a_1 和 a_2 则分别在 innerFn_1 和 innerFn_2 上创建了属于自己的作用域链. 所以它们函数里的 num 是属于不同作用域链里的变量. 但对于 a_1 和 a_1_1 来说它们都是基于 innerFn_1, 拥有同一 outer 变量对象, num 自然也是同一个, 所以会累加. 同理 a_2 和 a_2_2.</p><p>如果理解了这个, 那么面试常考的一题就小菜一碟了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是执行的时候才会创建变量对象的一个作用域链.</p><blockquote><p>闭包是什么?</p></blockquote><p>如果理解了以上的概念, 就会觉得闭包是作用域埋的一个彩蛋, 用的好就是惊喜, 用的不好就成惊吓了.<br>当函数可以记住并访问所在的作用域, 即使函数是在当前作用域之外执行, 这时就产生了闭包. 这就和之前提到的游戏存档差不多.<br>好了, 扔几个闭包出来巩固一下.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer_1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">'hello world'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    outer_2(inner)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer_2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也有闭包.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> array(<span class="number">99999999</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有开头所说的可以结合开发者工具直观地看一下, 一张动态图解释一切.</p><p><img src="../images/devToolsWithScope.gif" alt="devToolsWithScope"></p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>闭包之所以能成为闭包, 是因为它记录了函数所在的作用域. 现主流的自动垃圾收集机制正因为闭包的这个特点而不能释放内存. 闭包的滥用会导致导致内存能分配的空间变少, 最终崩溃.</p><p>正常来说, 函数在执行的过程中, 局部变量会被分配相应的内存空间, 以便存储它们的值, 直至函数执行结束. 此时局部变量占有的空间会被释放以供将来使用.</p><p>常说的回收机制之一, 标记清除, 它的工作原理是, 当变量进入执行环境时, 储存在内存中的所有变量都会被加上标记(至于什么标记我们不关心), 然后找到 <strong>环境中的变量</strong> 以及 <strong>被环境中引用的变量</strong>, 把它们之前加的标记给去掉. 而剩下的被标记的变量将被视为 <strong>准备</strong> 删除的变量. 最后, 垃圾收集器找出不再继续使用的变量, 释放其占用的内存. 所以, 一旦数据不再被需要, 应解除引用, 将其值设置为null.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">outer = <span class="literal">null</span>;</span><br><span class="line">inner = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>内部函数的执行环境会保存着外部环境活动对象的引用, 内部函数被扔出去后, 就意味着外部环境不能被销毁了.</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>执行环境里记录的不只是这些, 它也记录了函数调用栈、函数调用方式等. this 和作用域有关系, 但不是你们想象的那种关系. 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments. 内部函数在搜索这两个变量时, 只会搜索到其活动对象为止(即当前变量对象). 因此永远不可能直接访问到外部函数中的这两个变量. 除非我们把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 很常见是不是😂</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部的 this 在函数执行时才正式被赋予相应的值, 所以说函数的调用位置很关键. 可以这么说, 谁 <strong>直接</strong> 调用了这个函数, this 就指向了谁. 如果不是对象在直接调用这个函数, 我们可统统认为是 undefined, 非严格模式浏览器环境下就是 window. 如果真想知道为什么, 可以直接看规范(神烦).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b_a = b.a;</span><br><span class="line">a();    <span class="comment">//1. undefined;</span></span><br><span class="line">b_a();  <span class="comment">//2. undefined;</span></span><br><span class="line">b.a();  <span class="comment">//3. &#123;a: f, b: f&#125;;</span></span><br><span class="line">b.b()();    <span class="comment">//4. undefined;</span></span><br><span class="line">(<span class="literal">true</span> &amp;&amp; b.a)() <span class="comment">//5. undefined;</span></span><br><span class="line"><span class="keyword">new</span> a();    <span class="comment">//6. &#123;&#125;</span></span><br><span class="line">b.call(b);  <span class="comment">//7. &#123;a: f, b: f&#125;;</span></span><br></pre></td></tr></table></figure><p>从 1~6, 我们看看哪个对象直接调用了该函数. 第 1 个没找到调用对象, 就是个普通函数调用. 第 2 个经过 <code>b_a = b.a</code> 赋值操作后, 返回的就是那个普通函数, 就是一普通的函数调用. 第 3 个很直接, 就是 b 这个对象了. 第 4 个是个闭包, 首先 this 只在当前活动对象里找 this 对象, 不知道是哪个对象, 但肯定不会是 b. 第 5 个和第 2 个是一个道理. 第 6 个吧, 貌似不算是函数调用了吧, 不过我们知道, this 是指向新创建的空对象. 第 7个就更直接了, 人家都指名道姓就差喊出来了.<br>this 绑定对象的几条准则貌似在我这里就只剩一条了😌.</p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>this</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MVVM模式简单代码实现</title>
    <url>/%E5%85%B3%E4%BA%8EMVVM%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在写 <a href="http://www.yexiaochen.com/%E5%85%B3%E4%BA%8EMVC%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">关于MVC模式简单代码实现</a> 的过程中，觉得最麻烦的就是操作 DOM。所以这次升级了，打算用 React。用过 React 的同学都知道，React 在更新视图时，必须要通过 <code>setState</code> 方式改变状态，这一过程是需要我们主动调用的。而 Vue 是通过对 <code>data</code> 下的变量赋值直接更新了视图，Vue 之所以这么简单，是因为采用了数据劫持的方式。所以，这次的目的就是在 React 的基础上实现和 Vue 类似的效果。</p><p>实现思路就是利用高阶组件里的反向继承对包裹组件的 <code>state</code> 劫持。这是一个练手的小项目，没考虑那么多。为什么这么闲呢，那是因为之前写了 <a href="http://www.yexiaochen.com/%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript/">用Type驯化JavaScript</a> 这篇文章，所以就捣鼓出这么一个玩意。</p><p>所有代码可见<a href="https://github.com/yexiaochen/mvvm_react_typescript" rel="external nofollow noopener noreferrer" target="_blank">github</a></p><center><br><br><img src="../images/mvvm_typescript_React.gif" alt="MVVM"><br><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mvvm.tsx</span></span><br><span class="line"><span class="keyword">const</span> hocExtends = <span class="function">(<span class="params">WrapperComponent: ComponentClass</span>) =&gt;</span> (</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrapperComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props: any) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">this</span>.state = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; ...this.state &#125;, &#123;</span><br><span class="line">        <span class="keyword">get</span>: function (target, key, receiver) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (target, key, value, receiver): any &#123;</span><br><span class="line">          self.setState(&#123;</span><br><span class="line">            [key]: value</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">filterSearchStuff(searchStuff: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; stuffData &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">let</span> stuffItem: IStuff = stuffData.find(<span class="function">(<span class="params">item: IStuff</span>) =&gt;</span> item.stuff === searchStuff)</span><br><span class="line">    <span class="keyword">this</span>.state.stuffItem = stuffItem;</span><br><span class="line">    <span class="comment">// this.setState(&#123;</span></span><br><span class="line">    <span class="comment">//   stuffItem</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>TypeScript</tag>
        <tag>react</tag>
        <tag>高阶组件</tag>
        <tag>反向继承</tag>
      </tags>
  </entry>
  <entry>
    <title>关于MVC模式简单代码实现</title>
    <url>/%E5%85%B3%E4%BA%8EMVC%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>经过之前的<a href="http://www.yexiaochen.com/%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5/">咬文嚼字说策略</a>、<a href="http://www.yexiaochen.com/%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">在JavaScript中尝试组合模式</a>、<a href="http://www.yexiaochen.com/%E7%99%BD%E8%AF%9DMVC-MVP-MVVM/">白话MVC/MVP/MVVM</a> 和 较早之前的<a href="http://www.yexiaochen.com/%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">进击的观察者模式</a>等文章的铺垫，终于可以把这些理论的东西用于实践了。废话不多说，直奔主题。</p><blockquote><p>GoF 并不将 MVC 引述为一种设计模式，而是把它看做是构建一个用户界面的类的集合。按照他们的观点，它实际上是三种经典设计模式的变异组合：观察者模式，策略模式和组合模式。依赖于框架中的 MVC 如何实现，它也可能会使用工厂和模板模式。GoF Book 提到这些模式在使用 MVC 工作时是非常有用的附加功能。</p></blockquote><p>功能示意:<br><img src="../images/filter.gif" alt="filter.gif"></p><p>由一组数据展示三类表格，分别是【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图。另外可以修改指定 stuff 的 scale 或 salary 信息。</p><p>stuffs 信息：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stuffs = [</span><br><span class="line">    &#123;</span><br><span class="line">    stuff: <span class="string">'person_1'</span>,</span><br><span class="line">    scale: <span class="string">'甲'</span>,</span><br><span class="line">    salary: <span class="string">'6000'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    stuff: <span class="string">'person_2'</span>,</span><br><span class="line">    scale: <span class="string">'乙'</span>,</span><br><span class="line">    salary: <span class="string">'5000'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">    stuff: <span class="string">'person_3'</span>,</span><br><span class="line">    scale: <span class="string">'丙'</span>,</span><br><span class="line">    salary: <span class="string">'9000'</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>常规的写法可以这么来：</p><p></p><p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="yexiaochen" data-slug-hash="aXWLRz" style="height:265px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border:2px solid #000;margin:1em 0;padding:1em" data-pen-title="tableOrdinary"><br><span>See the Pen <a href="https://codepen.io/yexiaochen/pen/aXWLRz/" rel="external nofollow noopener noreferrer" target="_blank"><br>tableOrdinary</a> by 夜曉宸 (<a href="https://codepen.io/yexiaochen" rel="external nofollow noopener noreferrer" target="_blank">@yexiaochen</a>)<br>on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h2 id="职责分配"><a href="#职责分配" class="headerlink" title="职责分配"></a>职责分配</h2><p>既然说了 MVC 有那么多好处，我们就用 MVC 的模式来改造下我们的代码。首先我们先划分下职责。<br>Model 负责对数据的处理并返回目标数据，在这个场景下是筛选 stuff、修改stuff 等职责。<br>View 负责对目标数据的渲染和处理用户的响应，在这个场景下是各个表格的渲染、change 事件的委托等职责。<br>Control 负责协调 Model 和 View，在这个场景下是处理委托、处理数据等职责。</p><p><strong>此处的 MVC 实现是针对一个 Model 对应多个 View 的代码实现</strong> ，也是为了把观察者模式，策略模式和组合模式模式都用起来。</p><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图就是三个 View，每个 View 都可以独立渲染自己的一组视图。结合组合模式，我们我们造些视图的叶对象和分支对象。</p><p><img src="../images/View.png" alt="View"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $APP = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>叶对象（此处有两类视图）：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leafView_1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> renderTable = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: renderTable()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leafView_2 = <span class="function">(<span class="params">Control</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> $ONE = <span class="built_in">document</span>.getElementById(<span class="string">'one'</span>);</span><br><span class="line">    <span class="keyword">let</span> $SCALE;</span><br><span class="line">    <span class="keyword">let</span> $SALARY;</span><br><span class="line">    <span class="keyword">const</span> renderSearchTable = <span class="function"><span class="params">params</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> handleModify = <span class="function"><span class="params">e</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> bindEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支对象：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> branchView = <span class="function">(<span class="params">Control</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> $SEARCH, $ALL;</span><br><span class="line">    <span class="keyword">const</span> Views = [];</span><br><span class="line">    <span class="keyword">const</span> addView = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> handleSearch = <span class="function"><span class="params">event</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> bindEvent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">const</span> initDOM = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    initDOM();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render,</span><br><span class="line">        addView,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>Model 主要是将数据处理成目标数据，并提供 View 注册通知接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Model = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> stuffData = [];</span><br><span class="line">    <span class="keyword">let</span> filterData = [];</span><br><span class="line">    <span class="keyword">let</span> Views = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> ajaxFun = <span class="function"><span class="params">()</span> =&gt;</span> [...]; <span class="comment">// 模拟后台获取数据；</span></span><br><span class="line">    <span class="keyword">const</span> setStuffData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> filterStuff = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> setFilterStuff = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> findStuff = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> modifyStuffData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> register = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> notify = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        setStuffData,</span><br><span class="line">        setFilterStuff,</span><br><span class="line">        modifyStuffData</span><br><span class="line">        register,</span><br><span class="line">        notify,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>鉴于此处有多类视图，Model 和 View 之间，我们采用了发布订阅模式而不是观察者模式。Model 需要收集 View，然后在数据改变时候更新视图。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Control = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ModelInstance = Model();</span><br><span class="line">    <span class="keyword">const</span> View_1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> View_2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> init = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> filter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">const</span> modifyStuffInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init,</span><br><span class="line">        filter,</span><br><span class="line">        modifyStuffInfo</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整的 MVC 代码：</p><p></p><p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="yexiaochen" data-slug-hash="MLErQa" style="height:265px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;border:2px solid #000;margin:1em 0;padding:1em" data-pen-title="MVC"><br><span>See the Pen <a href="https://codepen.io/yexiaochen/pen/MLErQa/" rel="external nofollow noopener noreferrer" target="_blank"><br>MVC</a> by 夜曉宸 (<a href="https://codepen.io/yexiaochen" rel="external nofollow noopener noreferrer" target="_blank">@yexiaochen</a>)<br>on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>就这么简单的一个需求，改成 MVC 模式后就多了 100 多行代码。就如上篇文章所说一样，如果是简单的需求压根没必要这么折腾。不过，改成 MVC 后，它们各自职责也就更加清晰了，对以后的维护也会好些。</p>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>MVC</tag>
        <tag>策略模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>从迭代器模式到迭代协议</title>
    <url>/%E4%BB%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。</p><p>迭代器分为内部迭代器和外部迭代器。内部迭代器只需一次初始调用，而外部迭代器必须显式地请求迭代下一个元素，这样我们就可以手动控制迭代过程。</p><p>实现一个内部迭代器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.innerIterator = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        callback &amp;&amp; callback.call(<span class="keyword">this</span>[i], <span class="keyword">this</span>[i], i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].innerIterator(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'item:'</span>, item, <span class="string">'index:'</span>, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// item: 1 index: 0</span></span><br><span class="line"><span class="comment">// item: 2 index: 1</span></span><br><span class="line"><span class="comment">// item: 3 index: 2</span></span><br></pre></td></tr></table></figure><p>实现一个外部迭代器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.outerInterator = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; <span class="keyword">this</span>.length ?</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="keyword">this</span>[index++], <span class="attr">done</span>: <span class="literal">false</span>&#125;:</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].outerInterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> next; (next = iterator.next()) &amp;&amp; !next.done;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'item'</span>, next.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// item 1</span></span><br><span class="line"><span class="comment">// item 2</span></span><br><span class="line"><span class="comment">// item 3</span></span><br></pre></td></tr></table></figure><h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>了解了迭代器模式，再来看看 ES6 中补充的迭代协议。可迭代（iterable）协议和迭代器（iterator）协议。</p><p>可迭代协议：<br>一个可迭代对象（或其原型上），必须有一个 <code>Symbol.iterator</code> 的属性，该属性所对应的值为返回一个对象的无參函数，被返回对象符合迭代器协议。当可迭代对象需要迭代时，调用该方法。</p><p>一些数据类型内置了 <code>@@iterator</code> 方法，有自己默认的迭代行为。（<strong>String</strong>, <strong>Array</strong>, <strong>TypedArray</strong>, <strong>Map</strong> , <strong>Set</strong> 等都是内置可迭代对象， 因为它们的原型对象都有一个 <code>@@iterator</code> 方法.）（<em><code>[Symbol.iterator]</code>、<code>@@iterator</code> 可以认为是一回事</em>）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = (<span class="string">'hi'</span>)[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="keyword">var</span> a = iterator.next();</span><br><span class="line"><span class="comment">// a &#123; value: 'h', done: false &#125;</span></span><br></pre></td></tr></table></figure><p>迭代器协议：<br>一个迭代器必须实现了 <code>next()</code> 方法，该方法是返回一个对象的无參函数。被返回的对象有两个必要的属性：done 和 value。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.Iteration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;,</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; <span class="keyword">this</span>.length ?</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="keyword">this</span>[index++], <span class="attr">done</span>: <span class="literal">false</span>&#125;:</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> Iteration = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].Iteration();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> Iteration) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// value 2</span></span><br><span class="line"><span class="comment">// value 3</span></span><br><span class="line"><span class="comment">// value 4</span></span><br></pre></td></tr></table></figure><p>不能发现，Iteration 同时满足可迭代协议和迭代协议。又因为是可迭代的，<code>for...of</code> 是可以直接使用，而且这个和外部迭代器十分相似。</p><p>一旦一种数据结构有了 <code>@@iterator</code> 方法后， 就认为是可迭代的。ES6 中许多新的方法就是基于此的 <code>解构赋值</code>、<code>扩展运算符</code>、<code>yield*</code>，还有 <code>for..of</code>、<code>Array.from()</code>等。</p><p>知道了以上知识，也就知道了为什么对象不可以直接使用 <code>for...of</code> 了。不过我们可以在对象原型上添加 <code>@@iterator</code> 方法，使之成为可迭代的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.Iteration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>), index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;,</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> current = index++;</span><br><span class="line">                <span class="keyword">return</span> current &lt; keys.length?</span><br><span class="line">                &#123;<span class="attr">value</span>: [keys[current], <span class="keyword">this</span>[keys[current]]], <span class="attr">done</span>: <span class="literal">false</span>&#125;:</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;.Iteration();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'key:'</span>, key, <span class="string">'value:'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key: a value: 1</span></span><br><span class="line"><span class="comment">// key: b value: 2</span></span><br><span class="line"><span class="comment">// key: c value: 3</span></span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>像以上的的对象都是我们自己手动实现的，符合可迭代协议和迭代协议的对象。看起来很麻烦，还好这些工作已经有函数替我们做了，那就是生成器函数。</p><p>生成器函数是可以作为迭代器工厂的函数，当它被执行时会返回一个新的 Generator 对象，该对象符合可迭代协议和迭代器协议。</p><p>现在我们用生成器函数使得对象符合迭代协议：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.Iteration = <span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(<span class="keyword">this</span>))&#123;</span><br><span class="line">        <span class="keyword">yield</span> [key, value]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;.Iteration()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'key:'</span>, key, <span class="string">'value:'</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key: a value: 1</span></span><br><span class="line"><span class="comment">// key: b value: 2</span></span><br><span class="line"><span class="comment">// key: c value: 3</span></span><br></pre></td></tr></table></figure><p>在这里生成器只是作为迭代器而已，其实它还是消息双向传递系统。也正是这些特性的存在，使得异步流程控制又向前迈了一大步。</p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>迭代协议</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构碎碎念</title>
    <url>/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="前端架构碎碎念"><a href="#前端架构碎碎念" class="headerlink" title="前端架构碎碎念"></a>前端架构碎碎念</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看了一些关于前端架构相关的书籍和博客，觉得有点自我膨胀了，竟然想对着前端架构这一说法指指点点。从跨入这个行业开始，就觉得架构师就是位于技术金字塔的顶端的那拨人，是引导行业或团队技术走向的那拨人。然而从行业上对前端架构的定义和必备的技能来看，觉得前端架构就是一个伪概念，又或是拔高自己身份的幌子。</p><p>类比于建房子，考虑到人文因素，会有中西风格；考虑到地理位置，会有南北之分；考虑到简易方便，还会有组合式集装箱房屋。设计师会运用自己专业知识并集合各种因素，设计出符合当前环境的房屋。而架构师也是如此，他们需要从业务、技术等角度构造出合理的组织架构。前端技术不断发展演进，从模块化的摸索，到 MV* 的实践，再到当今组件化的盛行。这些技术人不断折腾，不断改进前端架构，使之更符合这个时代。在市场的筛选下，最终也留下了最适合当前的前端技术方案。不过，大部分前端架构师并不具备这种能力，充其量就是经验丰富的包工头，某种前端技术方案的践行者。</p><p>设计师怎么练成的，我们不知道。但是类比包工头，我们还是知道前端 Leader 应该做什么。</p><h2 id="开工前的前期准备"><a href="#开工前的前期准备" class="headerlink" title="开工前的前期准备"></a>开工前的前期准备</h2><p>这里的前期准备，指的是从零启动一个项目，我们需要做的准备工作。而最能体现整个项目的技术含量的活估计有大半在这里了。作为一个包工头，不是说我能把砖砌得有多好，而是足够了解现有的资源和工作流，并搭建好基础设施，为日后项目高效推进起个好头。</p><p>在很早以前，数据和视图耦合，那时候没有前端的什么事，最多作为页面仔为后端提供模板，或者说画几个展示用的静态页面。之后 ajax 的兴起，让数据和视图的关系开始松绑，前端在数据的赋能下，迎来了一次大发展。人要与数据交互，必然要通过某个媒介，而前端在获取部分数据的权限后，又反过来促进了人与数据的互动关系。即使后面的 Node，我也认为是前端为争取操作数据权限而做的努力。毕竟，这个年代数据才是王道。</p><p>视图怎么获取数据？视图怎么展示数据？视图怎么更好得获取数据？视图怎么更好得展示数据？（…没想那么多…）</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>从早期的服务端直出到现在的服务端渲染，视图的渲染兜兜转转貌似又回到的起点。但此非彼，不可同日而语。ajax 被 Google 使用后，随之而来的是前后端的分离。前端应用也是跟随时代而呈现不同的架构设计，比如多页面应用、单页面应用、同构渲染、微前端等。它们的出现是为了解决某些问题而给出的技术方案，所以说即使过时，却依然有其价值。</p><p>多页面应用，相对来说，比较简单。简单的多页面应用，比如静态页面，这里可能压根没 JS 的事。复杂点的多页面应用，可能要引入模板引擎，路由等。要是觉得原生操作 DOM 不方便，可以使用 jQuery。多页面应该在项目启动的时候，会加载需要的资源，由于浏览器缓存策略，第二次加载相同的资源时，可能就不需要重复请求了。在结合一点 MV* 模式，快和单页面应用没什么区别了。只是现在流行的单页面不需要直接操作 DOM ，而是交给框架底层处理了。</p><p>以上的应用说来说去可能都是同一个应用，在某些场景，就需要聚合多个前端应用，有路由分发的方案，有 iframe 作为容器的方案等。</p><h3 id="前端规范"><a href="#前端规范" class="headerlink" title="前端规范"></a>前端规范</h3><p>「书同文，车同轨」</p><p>既然是包工头，自然不大可能是一个光杆司令。制定规范，不仅可以使成员代码风格趋于统一，同时也可以使新手养成良好的编码习惯。对于前端来说，HTML、CSS、JS 分别代表了结构层、表现层和行为层。在代码层次上，它们都有自己的一套标准，可以结合各自 lint工具 + Prettier 轻松规范代码。从组件规范角度，还包括 UI 组件规范、模块化规范、项目组件化设计方案等。</p><p>编辑器最好也能够统一下，如果能够摸索出能够提高效率的一系列使用方法，同步给全组成员就更好了。</p><h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><p>都 9102 年，自动化构建已成为现代前端工程不可或缺的一个环节。自动化构建可以做很多事，比如文件编译，资源合并，压缩优化等。构建工具很多，但所做的事基本上是差不多的，读取入口配置文件 ➡ 生成模块依赖图 ➡ 加载模块 ➡ 模块文件编译处理 ➡️ 模块文件合并 ➡️ 文件资源优化 ➡ 输出最终资源。</p><p>不论是生产环境还是开发环境，都需要构建工具的参与。生产环境侧重于性能，比如文件压缩优化，去除无用代码注释等。测试环境侧重于开发体验，比如模块热替换，生成 sourcemap 等。像之前的代码规范，也可以借助构建工具自动化格式化代码，或提示错误。</p><h3 id="项目代码示例"><a href="#项目代码示例" class="headerlink" title="项目代码示例"></a>项目代码示例</h3><p>项目在正是启动之前，需要验证程序是否按照自己的预期去执行。验证可行后，并按照自己定义的一系列规范编写示例代码，这样有助于其他成员了解该项目的规范。同时，对内组织技术培训，介绍系统的架构和注意事项。</p><p>其实，技术验证的过程不应该放在整个开发流程中。工作之余，我们可以多接触新的技术和尝试新的架构设计。在未知的领域，我们无法准确评估时间，临时磨枪可能会导致整个项目的延期。</p><h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><p>技术是为业务服务的，项目启动了，意味着开始偿还业务债了。而前端 Leader 职责也开始发生变化，不仅仅从事技术活，还要参与到团队管理、项目管理等非技术活。项目进入正轨后，人人都成为了螺丝工，技术上的难题基本上很少再会遇到。但是这并不代表整个开发过程会变得一帆风顺。</p><h3 id="沟通协调"><a href="#沟通协调" class="headerlink" title="沟通协调"></a>沟通协调</h3><p>「凡事有交代，件件有着落，事事有回音」</p><p>不管是普通成员，还是团队 Leader，都应该具备这样的做事风格，对自己和别人都有个交代。</p><p>前端在整个研发队伍中，是一个比较尴尬的存在。尤其在比较重视业务的团队里，好事没捞到，麻烦事却不断找上门。比如页面抛异常，测试伙伴第一个就找前端。产品伙伴不靠谱，频繁找前端。遇到不靠谱的后端小伙伴，联调测试时也会跑来质疑前端。最后可能领导跑来找你谈话，说你们前端团队怎么老是出问题。讲真，这话没法接。感觉前端就是一个接锅侠，时间长了，对团队士气有很大的影响，这也是前端 Leader 需要解决的问题。</p><p>对于产品，需求评审严格把关，对于不合理或不紧急的需求，延迟或降低其优先级。对于测试伙伴，对其进行技术培训，了解开发者工具的简单使用，和常见异常报错分析科普。对于后端，制定相关约束。以上规范要形成文档保存，方便后来者。</p><p>当然诸如此类的问题会有很多，对于问题要敏感并及时发现，分析导致问题的根源，最后对症下药逐步解决问题。事情说得很简单，但事实上，人们习惯于存在问题的现状而不自知或发现问题却习惯于有问题的现状。</p><h3 id="提升团队能力"><a href="#提升团队能力" class="headerlink" title="提升团队能力"></a>提升团队能力</h3><p>众人拾柴火焰高，只有大伙儿力往一处使，才能产生 1 + 1 &gt; 2 的效果。可是编码并不是力气活，成员的参差不齐，很大的程度上会拖团队的后退。比如，一个新手的代码提交不规范，很可能导致某些人的哀嚎。</p><p>代码审查，是一个提高自己编码能力的好机会。之前的 Lint 规则可以很好地校正代码风格，而在代码审查中，就可以发现逻辑上的问题或知道可以让代码更出彩的方法。</p><p>代码重构算是一种提升编程能力的方式，不过有很多人对代码重构有着很大的误解，也不见得项目中对重构的重视。重构可以本着小步快走的原则，增加程序的可读性和可维护性。何时去重构？需要重构的标准的是什么？如果程序冗长啰嗦看不懂，那就重构它。如果一段程序过分依赖于注释，那就重构它。如果你想添加新功能，却无从下手，那就重构它。只要是可读性差，可维护性差，你都有理由去重构它。</p><p>代码审查还有一个好处就是，可以帮助我们熟悉业务。如果项目业务很复杂，至少要保证有两个人对同一模块有足够的了解。</p><p>新人培训和技术分享，新人刚接入项目时，有必要对其进行基础的技术培训，如业务培训、技术栈相关知识培训、调试能力培训等，这些都要有相关的文档。这些看着无关紧要的培训，对于新手来说，往往是一大助力。</p><p>技术分享，并不指望一次简单的分享就让所有的成员学会一项技能，不过这对团队的技术视野和团队技术氛围会有很大帮助。对于技术分享的人，有不同的说法，有人主张新人主持分享，这样可以加快新人融入团队，老人也可以一旁补充说明。而有些人，则认为让最擅长的人去做擅长的事。不知道孰好孰坏，不予置评。</p><p>我认为团队能力还应该包括存续能力，也就是即便成员流动快，新到位的成员也能很快接入项目。这就需要各种文档记录，新人培训文档，技术架构文档，业务文档，技术分享文档，开发规范文档，工作交接文档等。</p><h3 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h3><p>后端由本地开发环境部署到测试环境，按正常的节奏来，前后端联调会很顺利。然而，实际开发中，联调的占比会很大。主要的原因有，</p><ol><li>前后端沟通效率低，有问题相互质疑。</li><li>后端自测力度不够，考虑不周全。</li><li>接口协议变动频繁。</li><li>接口文档不详实。<br>…</li></ol><p>最简单粗暴的方法就是引入接口管理平台，引入绩效考核制度。</p><h3 id="持续化集成-持续化交付-持续化部署"><a href="#持续化集成-持续化交付-持续化部署" class="headerlink" title="持续化集成 持续化交付 持续化部署"></a>持续化集成 持续化交付 持续化部署</h3><p>这一块就不是前端自己能够决定的事情了，有条件的话可以自己搭建代码托管平台，使用 gitlab ，现在人家提供一条龙服务，可以尝试一波。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>和代码打交道不可怕，和人打交道也不可怕，可怕的是这个前端 Leader 有想法。</p>]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化空对象数组</title>
    <url>/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="初始化空对象数组"><a href="#初始化空对象数组" class="headerlink" title="初始化空对象数组"></a>初始化空对象数组</h1><blockquote><p>在给对象设置属性时, 如果对象不存在很容易报错.</p><p><img src="../images/property.png" alt="property"></p><p>有些场景, 在对对象数组处理时, 设置对象属性前判断对象是否存在. 与其这样, 还不如直接初始化为空对象数组.</p></blockquote><h2 id="9个考生就来了6个"><a href="#9个考生就来了6个" class="headerlink" title="9个考生就来了6个"></a>9个考生就来了6个</h2><hr><pre><code>考试时, 每个考生都有自己位置. 考生对照着可以很容易在考场里找到自己的座位.
秉着公平、公正、公开的原则, 考生被稀疏地散布在考场的各个角落.
</code></pre><p>假设考场 3*3 排列, 考生的信息:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"row"</span>:<span class="number">1</span>,<span class="attr">"col"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"Ada"</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">3</span>,<span class="attr">"col"</span>:<span class="number">3</span>,<span class="attr">"name"</span>:<span class="string">"Aaron"</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">1</span>,<span class="attr">"col"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"Aditi"</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">3</span>,<span class="attr">"col"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"Aditi"</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">1</span>,<span class="attr">"col"</span>:<span class="number">3</span>,<span class="attr">"name"</span>:<span class="string">"Aditi"</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">3</span>,<span class="attr">"col"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"Abbott"</span>&#125;]</span><br></pre></td></tr></table></figure><p>将考场位置做成一个表格, 对考生位置按排统计, 来标注考生出勤情况.</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"row"</span>:<span class="number">1</span>,<span class="attr">"col_1"</span>:<span class="string">"Ada"</span>,<span class="attr">"col_2"</span>:<span class="string">"Aditi"</span>,<span class="attr">"col_3"</span>:<span class="string">"Aditi"</span>&#125;,</span><br><span class="line"> &#123;&#125;,</span><br><span class="line"> &#123;<span class="attr">"row"</span>:<span class="number">3</span>,<span class="attr">"col_3"</span>:<span class="string">"Aaron"</span>,<span class="attr">"col_2"</span>:<span class="string">"Aditi"</span>,<span class="attr">"col_1"</span>:<span class="string">"Abbott"</span>&#125;]</span><br></pre></td></tr></table></figure><p><em>(为嘛没有第二排? 自知考不过, 缺考了呗🙁)</em><br>开发中, 对原始数据进行处理是一件很平常的事. so, 这个数据的处理应该很简单…吧😅</p><h2 id="Array-3-fill-试一波"><a href="#Array-3-fill-试一波" class="headerlink" title="Array(3).fill({}) 试一波"></a><code>Array(3).fill({})</code> 试一波</h2><hr><blockquote><p>如何初始化空对象数组?</p></blockquote><p>原始数据是以学生个体的信息存储展示的, 现在则按排为单位对数据进行处理. 理所当然的会想到先初始化三个空对象数组.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;&#125;)</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123;&#125;, &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p>动作很快姿势很帅. 不过, 这样真的可以么? 长得倒是像那么一回事, 可实际上完全行不通. <code>Array.prototype.fill()</code> 的用法是, 指定某个值来填充数组.<br>也就是说, <code>{}</code> 在 studentRow 里复制了三次. 如果是简单类型值倒也罢了, 但是换做复杂类型值, 修改每一个 <code>{}</code> , 都会影响其它的 <code>{}</code>. 因为它们都是对同一个对象的引用.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(&#123;&#125;);</span><br><span class="line">studentRow[<span class="number">0</span>].name = <span class="string">'tony'</span>;</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'tony' &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'tony' &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'tony' &#125; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(obj);</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// &#123;obj, obj, obj&#125;</span></span><br><span class="line">studentRow[<span class="number">0</span>].name = <span class="string">'tony'</span>;</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'tony' &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'tony' &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; name: 'tony' &#125; ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点:</strong></p><ul><li>将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值.</li><li>当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.</li></ul><h2 id="Array-3-和-map-gt-结合有问题"><a href="#Array-3-和-map-gt-结合有问题" class="headerlink" title="Array(3) 和 map(() =&gt; {}) 结合有问题"></a><code>Array(3)</code> 和 <code>map(() =&gt; {})</code> 结合有问题</h2><hr><blockquote><p><code>Array(3).fill({})</code> 行不通. 那么, <code>Array(3).map(() =&gt; {})</code>?</p></blockquote><p>如果说 <code>Array(3).fill({})</code> 不可行, 是因为三个空对象是对同一个对象的引用. 那么我们就设法返回三个不同的空对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &lt;3 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p>结果很失望, 这个表达式就干了两件事, <code>Array(3)</code> 和 <code>map(() =&gt; {})</code>. 所以问题很好排查.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// &gt; arr</span></span><br><span class="line"><span class="comment">// [ &lt;3 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p>对于数组中并不存在的单元, <code>map()</code> 也是束手无策.</p><blockquote><p>我说: 肚里要有货🙏</p></blockquote><p>肚里没货, 我们就造一些. <code>Array.prototype.fill()</code> 又有出头之日了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><p><strong>警告:</strong></p><ul><li><p>如若一个数组没有任何单元, 但它的 length 属性中却显示有单元数量, 这样奇特的数据结构会导致一些怪异的行为. 我们将包含至少一个 “空单元” 的数组称之为 “稀疏数组”. undefined 单元非 “空单元”.</p></li><li><p>永远不要创建和使用空单元数组.</p></li></ul><h2 id="箭头函数中的-return"><a href="#箭头函数中的-return" class="headerlink" title="箭头函数中的 return"></a>箭头函数中的 <code>return</code></h2><hr><blockquote><p>你以为 <code>Array(3).fill(undefined).map(() =&gt; {})</code> 就完事了? 图样图森破 👼</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">undefined</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><blockquote><p>哦, 我知道了, 你没有 return 啊</p></blockquote><p>额, 这和 return 没有关系. 不信你可以加一个试试😏<br>其实, <code>{}</code> 在这里被视作语法块了, 没有任何意义. 可恨就可恨在, 它和空对象长得一摸一样.<br>既然这样, 那我们就不用字面量定义一个空对象了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">undefined</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>));</span><br><span class="line">studentRow[<span class="number">0</span>].name = <span class="string">'tony'</span>;</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p>这样就达到初始化对象数组的目的了. 可是, <code>Array(3).fill(undefined).map(() =&gt; {})</code> 为什么行不通, 如何补救?</p><blockquote><p>规避问题在某种意义上不等于解决问题.</p></blockquote><p><code>{...}</code> 里面的代码会被解析为一系列语句. <code>{}</code> 也因此不能达到我们预期的结果. 所以, 我们可以用 <code>(...)</code> 将 <code>{}</code> 包装成表达式, 即 <code>({})</code>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">undefined</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;));</span><br><span class="line">studentRow[<span class="number">0</span>].name = <span class="string">'tony'</span>;</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点:</strong></p><ul><li><p>若函数体的表达式个数多于一个, 或者函数题包含非表达式语句的时候才需要用 <code>{...}</code> 包裹.</p></li><li><p>如果只有一个表达式, 并且省略了 <code>{...}</code> 的话, 则附加一个隐式 return. 若在块体内需要指定返回值, 则需要明确的 return.</p></li><li><p>箭头函数提供了简练的语法, 但不是普通函数的替代品. 箭头函数的主要设计目的是改变 this 的行为. 普通函数内的 this 是动态绑定, this 指向谁取决于调用者. 而箭头函数里的 this 是基于作用域的, 是可预测的.(可参考<a href="http://www.yexiaochen.com/%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%A7%92%E5%BA%A6%E8%AF%B4%E4%BD%9C%E7%94%A8%E5%9F%9F/">从游戏角度说作用域</a>).</p></li></ul><h2 id="令人绝望的Array-prototype-fill"><a href="#令人绝望的Array-prototype-fill" class="headerlink" title="令人绝望的Array.prototype.fill()"></a>令人绝望的<code>Array.prototype.fill()</code></h2><hr><blockquote><p>你以为结束了, 其实才刚刚开始</p></blockquote><p>这是真正的开始, 没看错, 是的, 我们之前所做的可能都是无用功.</p><p><img src="../images/Array.prototype.fill.png" alt="Array.prototype.fill兼容性"></p><p>是的, IE 是魔鬼. 费尽了周折, 才发现一切都是徒劳.<br>难道就这么放弃了?</p><blockquote><p>‘放弃’能吃么? 能吃就吃了它, 啥? 不能吃?!? 提它作甚!!!</p></blockquote><p><code>Array.prototype.fill()</code> 方便之处就是能够简便填充数组. 此法不行, 另寻他法.</p><h2 id="Function-prototype-apply-了解一下"><a href="#Function-prototype-apply-了解一下" class="headerlink" title="Function.prototype.apply() 了解一下"></a><code>Function.prototype.apply()</code> 了解一下</h2><hr><p><code>Function.prototype.apply()</code> 入参有两个. 第一个参数是 <strong>函数方法</strong> 的调用者, 第二个参数是 <strong>函数方法</strong> 的入参(要区分入参和入参的不同). <strong>函数方法</strong> 的入参可以是数组也可以是类数组. 我们的目的就是填充数组, 所以我们要在类数组上做文章. 就拿 <code>console.log</code> 做例子🌰. (直接复制我之前的博客内容😌).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log_1</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(arg)</span><br><span class="line">&#125;</span><br><span class="line">log_1(<span class="number">1</span>);</span><br><span class="line">log_1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改造下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log_2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line">    log.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">log_2(<span class="number">1</span>);</span><br><span class="line">log_2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure><p>这是 <code>Function.prototype.apply()</code> 使用的方法. 如果我们把 log_2 里的 arguments 换成 <code>{length: 3}</code>,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log_2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line">    log.apply(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">3</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line">log_2()</span><br><span class="line"><span class="comment">// undefined undefined undefined</span></span><br></pre></td></tr></table></figure><p><code>{length: 3}</code> 和 <code>[undefined, undefined, undefined]</code> 在传入 <code>apply(null;...)</code> 后, 在参数的处理上, 最后的结果是一样的.<br>那么, <code>Array(3).fill(undefined).map(() =&gt; ({}))</code> 可改造成,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">3</span>&#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;));</span><br><span class="line">studentRow[<span class="number">0</span>].name = <span class="string">'tony'</span>;</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p>在这里 Array 作为普通函数调用, 以上等同于</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> studentRow = <span class="built_in">Array</span>(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// &gt; studentRow</span></span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><hr><p>只是初始化一个空对象数组, 结果整出这么多幺蛾子.<br>处理数据其实就那么几行代码. 大致长这模样,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> studentRow = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123;<span class="attr">length</span>: <span class="number">3</span>&#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;&#125;));</span><br><span class="line">    params.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    studentRow[item.row<span class="number">-1</span>][<span class="string">`row`</span>] = item.row;</span><br><span class="line">    studentRow[item.row<span class="number">-1</span>][<span class="string">`col_<span class="subst">$&#123;item.col&#125;</span>`</span>] = item.name;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> studentRow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>空对象数组</tag>
      </tags>
  </entry>
  <entry>
    <title>前端笔试之手写代码</title>
    <url>/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="扁平化嵌套数组-flat实现"><a href="#扁平化嵌套数组-flat实现" class="headerlink" title="扁平化嵌套数组/flat实现"></a>扁平化嵌套数组/flat实现</h2><p><strong>描述</strong>：将嵌套多层的数组展开平铺成只有一层的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, [<span class="number">2</span>, &#123;&#125;]] ]</span><br><span class="line">handle(array) <span class="comment">// [1, 1, 2, 3, 1, 2, &#123;&#125;]</span></span><br></pre></td></tr></table></figure><p><strong>方法一</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> <span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(array).replace(<span class="regexp">/\[|]/g</span>,<span class="string">''</span>)&#125;</span>]`</span>)</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON.parse()/JSON.stringify()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="external nofollow noopener noreferrer" target="_blank"><code>String.prototype.replace()</code></a></p><p><strong>方法二</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> array.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator.concat(<span class="built_in">Array</span>.isArray(currentValue) ? handle(currentValue): currentValue), [])</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.reduce()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.concat()</code></a></p><p><strong>方法三</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(array.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        array = [].concat(...array)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/while" rel="external nofollow noopener noreferrer" target="_blank"><code>while</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.some()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters" rel="external nofollow noopener noreferrer" target="_blank"><code>剩余参数</code></a></p><p><strong>其它方法</strong>：……</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p><strong>描述</strong>：将数组中重复的元素过滤掉。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">'3'</span>, <span class="string">'3'</span>, <span class="number">0</span> , <span class="number">1</span>]</span><br><span class="line">handle(array)   <span class="comment">// [1, 2, '3', 0]</span></span><br></pre></td></tr></table></figure><p><strong>方法一</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> [...new <span class="built_in">Set</span>(array)]</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 2, '3', 0 ]</span></span><br></pre></td></tr></table></figure><p>知识点：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="external nofollow noopener noreferrer" target="_blank"><code>Set</code></a></p><p><strong>方法二</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> array.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">    !accumulator.includes(currentValue) &amp;&amp; accumulator.push(currentValue)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;, [])</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 2, '3', 0 ]</span></span><br></pre></td></tr></table></figure><p>知识点：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.includes()</code></a></p><p><strong>方法三</strong>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="params">item</span> =&gt;</span> map.has(item) ? <span class="literal">false</span> : map.set(item))</span><br><span class="line">&#125;</span><br><span class="line">handle(array)   <span class="comment">// [ 1, 2, '3', 0 ]</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="external nofollow noopener noreferrer" target="_blank"><code>Map</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.filter()</code></a></p><p><strong>其它方法</strong>：……</p><h2 id="模拟bind实现"><a href="#模拟bind实现" class="headerlink" title="模拟bind实现"></a>模拟bind实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>), context = args.shift();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(...arguments))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" rel="external nofollow noopener noreferrer" target="_blank"><code>apply、call、bind</code></a></p><h2 id="模拟Call实现"><a href="#模拟Call实现" class="headerlink" title="模拟Call实现"></a>模拟Call实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>), context = args.shift();</span><br><span class="line">    context = <span class="built_in">Object</span>(context);</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">delete</span> context.fn) &amp;&amp; result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="模拟New实现"><a href="#模拟New实现" class="headerlink" title="模拟New实现"></a>模拟New实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">    <span class="keyword">let</span> o = fn.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'object'</span> ? o : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="external nofollow noopener noreferrer" target="_blank"><code>Object.create()</code></a></p><h2 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">String</span>(num).replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+(?!\d))/g</span>, <span class="string">','</span>)</span><br><span class="line">handle(num) <span class="comment">// 123,456,789</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" rel="external nofollow noopener noreferrer" target="_blank"><code>正则表达式</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" rel="external nofollow noopener noreferrer" target="_blank"><code>String.prototype.replace()</code></a></p><h2 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">123456654321</span>;</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'abababababab'</span>;</span><br><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str_1 = <span class="built_in">String</span>(params).replace(<span class="regexp">/[^0-9A-Za-z]/g</span>, <span class="string">''</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> str_2 = str_1.split(<span class="string">''</span>).reverse().join();</span><br><span class="line">    <span class="keyword">return</span> str_1 === str_2 ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">handle(num) <span class="comment">// true</span></span><br><span class="line">handle(str) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" rel="external nofollow noopener noreferrer" target="_blank"><code>String.prototype.split()</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" rel="external nofollow noopener noreferrer" target="_blank"><code>Array.prototype.join()</code></a></p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!timeId) &#123;</span><br><span class="line">            timeId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">                timeId = <span class="literal">null</span></span><br><span class="line">            &#125;, interval)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" rel="external nofollow noopener noreferrer" target="_blank"><code>window.setTimeout</code></a></p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">fn, interval</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (now - lastTime &gt; interval) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            lastTime = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timeId;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeId) clearTimeout(timeId)</span><br><span class="line">        timeId = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数节流、函数防抖区别</strong>：函数节流和函数防抖较容易混淆，可以这么比喻，对于函数节流，门外有人频繁敲门，但是门卫按固定时间来决定是否开门。对于函数防抖，门外有人频繁敲门，门卫按最后一次敲门来决定是否开门。</p><p><strong>知识点</strong>：<a href="https://developer.mozilla.org/es/docs/Web/API/WindowTimers/clearTimeout" rel="external nofollow noopener noreferrer" target="_blank"><code>window.clearTimeout</code></a></p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(params)) &#123;</span><br><span class="line">        <span class="keyword">return</span> params.reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">            (<span class="keyword">typeof</span> currentValue === <span class="string">'object'</span>) ? accumulator.push(deepClone(currentValue)) : accumulator.push(currentValue);</span><br><span class="line">            <span class="keyword">return</span> accumulator;</span><br><span class="line">        &#125;, [])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(params).reduce(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> &#123;</span><br><span class="line">            (<span class="keyword">typeof</span> params[currentValue] === <span class="string">'object'</span>) ? accumulator[currentValue] = deepClone(params[currentValue]) : accumulator[currentValue] = params[currentValue];</span><br><span class="line">            <span class="keyword">return</span> accumulator;</span><br><span class="line">        &#125;, &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.handles = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    subscribe(type, handle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.handles[type]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handles[type] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handles[type].push(handle)</span><br><span class="line">    &#125;</span><br><span class="line">    unsubscribe(type, handle) &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = <span class="keyword">this</span>.handles[type].indexOf(handle)</span><br><span class="line">        <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handles.length = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ~pos &amp;&amp; <span class="keyword">this</span>.handles[type].splice(pos, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    publish() &#123;</span><br><span class="line">        <span class="keyword">let</span> type = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">this</span>.handles[type].forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">            handle.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pub = <span class="keyword">new</span> Pubsub()</span><br><span class="line">pub.subscribe(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'a'</span>, ...arguments)&#125;)</span><br><span class="line">pub.publish(<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// a 1 2 3</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> partial = </span><br><span class="line">    (fn, ...presetArgs) =&gt;</span><br><span class="line">            (...laterArgs) =&gt; </span><br><span class="line">                fn(...presetArgs, ...laterArgs)</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curry =</span><br><span class="line">    (fn, arity = fn.length, nextCurried) =&gt;</span><br><span class="line">        (nextCurried = <span class="function"><span class="params">prevArgs</span> =&gt;</span></span><br><span class="line">            nextArg =&gt; &#123;</span><br><span class="line">                <span class="keyword">var</span> args = prevArgs.concat( [nextArg] );</span><br><span class="line">                <span class="keyword">if</span> (args.length &gt;= arity) &#123;</span><br><span class="line">                    <span class="keyword">return</span> fn( ...args );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextCurried( args );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )( [] );</span><br></pre></td></tr></table></figure><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt;</span><br><span class="line">        result =&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> list = fns.slice();</span><br><span class="line">            <span class="keyword">while</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result = list.pop()( result );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h2 id="简易模块依赖管理器"><a href="#简易模块依赖管理器" class="headerlink" title="简易模块依赖管理器"></a>简易模块依赖管理器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleManage = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> modules = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> define = <span class="function">(<span class="params">name, deps, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    deps = deps.map(<span class="function"><span class="params">item</span> =&gt;</span> modules[item])</span><br><span class="line">    modules[name] = <span class="built_in">module</span>(...deps);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> exports = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> modules[name];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    define,</span><br><span class="line">    exports,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="Promise化"><a href="#Promise化" class="headerlink" title="Promise化"></a>Promise化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise_wrap = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fn(...[<span class="function">(<span class="params">error, value</span>) =&gt;</span> error ? </span><br><span class="line">                                reject(error):</span><br><span class="line">                                resolve(value), ...arguments])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">var</span> callback_async = <span class="function">(<span class="params">callback, x = <span class="built_in">Date</span>.now(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'callback_async:初始时间戳'</span>, x)</span><br><span class="line">        <span class="comment">// do something now</span></span><br><span class="line">        <span class="comment">// throw 'callback-outer: error'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// do something in the future</span></span><br><span class="line">                <span class="comment">// throw 'callback-inner: error'</span></span><br><span class="line">                <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x</span><br><span class="line">                callback &amp;&amp; callback(<span class="literal">null</span>, </span><br><span class="line">                            <span class="string">`callback_async:在<span class="subst">$&#123;interval&#125;</span>毫秒后异步完成`</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(&#123;callback&#125;)</span><br><span class="line">                callback(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        callback(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise_wrap(callback_async)(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="对象可迭代"><a href="#对象可迭代" class="headerlink" title="对象可迭代"></a>对象可迭代</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.Iteration = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>), index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;,</span><br><span class="line">            next: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> current = index++;</span><br><span class="line">                <span class="keyword">return</span> current &lt; keys.length?</span><br><span class="line">                &#123;<span class="attr">value</span>: [keys[current], <span class="keyword">this</span>[keys[current]]], <span class="attr">done</span>: <span class="literal">false</span>&#125;:</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器自执行器"><a href="#生成器自执行器" class="headerlink" title="生成器自执行器"></a>生成器自执行器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator_wrap = <span class="function"><span class="keyword">function</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> gen = generator.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> handleNext = <span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">yield</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> next;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                next = gen.next(<span class="keyword">yield</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">                resolve(next.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="params">yield</span> =&gt;</span> &#123;</span><br><span class="line">                    handleNext(<span class="keyword">yield</span>);</span><br><span class="line">                &#125;, error =&gt; &#123;</span><br><span class="line">                    gen.throw(error);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        handleNext();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>咬文嚼字说策略</title>
    <url>/%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote><p>设计模式是: 在面向对象软件过程中针对特定问题的简洁而优雅的解决方案. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出可重复使用面向对象的设计技巧.</p></blockquote><p>JavaScript 可以模拟实现传统面向对象语言的设计模式. 然而仅仅是生搬硬套, 未免会失去 JavaScript 的灵活性. 不如溯本求源, 看看这些设计模式到底在传达什么, 然后遵循此点.</p><h2 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h2><blockquote><p><strong>策略模式</strong>: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.</p></blockquote><p>字面意思, 就是定义封装多种算法, 且各个算法相互独立. 当然, 也不仅仅是算法. 只要定义一些规则, 经处理后输出我们想要的结果就成. 在此我们称单个封装后的算法为一个策略. 一系列封装后的算法称为一组策略.</p><blockquote><p>一个基于策略模式的程序至少由两部分组成. 第一部分是一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分是环境类 Context, Context 接受客户的请求, 随后把请求委托给某一个策略类.</p></blockquote><p>这是面向传统面向对象语言中的说法. 在面向对象思想中, 通过对组合, 多态等技术的使用来实现一个策略模式. 在 JavaScript 中, 对于一个简单的需求来说, 这么做就有点大材小用了.<br>所以, 上面的那句话, 我们换种说法就是, 策略模式需要至少两部分, 一部分是保存着一组策略. 另一部分则是如何分配这些策略, 即如何把请求委托给某个/些策略. 其实这也是策略模式的目的, 将算法的使用与算法的实现分离.</p><h2 id="评级"><a href="#评级" class="headerlink" title="评级"></a>评级</h2><p>快到年底了, 公司打算制定一个标准用来给员工评级发福利.</p><table><thead><tr><th style="text-align:center">考核项目\等级</th><th style="text-align:center">甲</th><th style="text-align:center">乙</th><th style="text-align:center">丙</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">100&gt;a&gt;=90</td><td style="text-align:center">90&gt;a&gt;=80</td><td style="text-align:center">80&gt;a&gt;=70</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">100&gt;b&gt;=90</td><td style="text-align:center">90&gt;b&gt;=80</td><td style="text-align:center">80&gt;b&gt;=70</td></tr></tbody></table><p>以A、B考核项目来评定甲乙丙等级.<br>现有考核人员:</p><table><thead><tr><th style="text-align:center">考核项目\考核人</th><th style="text-align:center">person_1</th><th style="text-align:center">person_2</th><th style="text-align:center">person_3</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">80</td><td style="text-align:center">93</td><td style="text-align:center">92</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">85</td><td style="text-align:center">70</td><td style="text-align:center">90</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> persons = [</span><br><span class="line">    &#123;<span class="attr">A</span>: <span class="number">80</span>, <span class="attr">B</span>: <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">A</span>: <span class="number">93</span>, <span class="attr">B</span>: <span class="number">70</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">A</span>: <span class="number">92</span>, <span class="attr">B</span>: <span class="number">90</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在策略模式中一部分, 我们提到的分配策略. 要想分配策略, 首先就要知道所有的策略, 只有这样我们才能针对性的委托给某个/些策略. 这, 也是策略模式的一个缺点.</p><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><p>甲乙丙等级对 A、B 的分值要求是不一样的. 所以我们可以这么做:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rating</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = person.A;</span><br><span class="line">    <span class="keyword">let</span> b = person.B;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= <span class="number">90</span> &amp;&amp; b &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'甲'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">80</span> &amp;&amp; b &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'乙'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">70</span> &amp;&amp; b &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'丙'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'凭啥级, 还不赶紧卷铺走人'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">persons.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">    person.rate = rating(person);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &gt; persons</span></span><br><span class="line"><span class="comment">// [ &#123; A: 80, B: 85, rate: '乙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 93, B: 70, rate: '丙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 92, B: 90, rate: '甲' &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="策略模式下的评级"><a href="#策略模式下的评级" class="headerlink" title="策略模式下的评级"></a>策略模式下的评级</h2><p>如果换成策略模式, 第一部分就是保存一组策略. 现在我们以甲乙丙三种定级标准来制定三种策略, 用对象来存贮策略. 考虑到以后可能有 D、E、F 等考核项目的存在, 我们稍微改一下:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">    <span class="string">'甲'</span>: <span class="function">(<span class="params">person, items</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> boolean = items.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person[item] &gt;= <span class="number">90</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (boolean) <span class="keyword">return</span> <span class="string">'甲'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'乙'</span>: <span class="function">(<span class="params">person, items</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> boolean = items.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person[item] &gt;= <span class="number">80</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (boolean) <span class="keyword">return</span> <span class="string">'乙'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'丙'</span>: <span class="function">(<span class="params">person, items</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> boolean = items.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> person[item] &gt;= <span class="number">70</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (boolean) <span class="keyword">return</span> <span class="string">'丙'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>策略就制定好了. 对象的键对应着策略的名称, 对象的值对应着策略的实现. 然而, 我们发现, 任何一个策略都不能单独完成等级的评定. 可是, 我们有说一组策略只能选择其中一个么? 为了达成某个目的, 策略组封装了一组相互独立平等替换的策略. 一个策略不行, 那就组合呗. 这也是策略模式另一部分存在的意义, 即如何分配策略.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rating</span>(<span class="params">person, items</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> strategies[<span class="string">'甲'</span>](person, items)</span><br><span class="line">        || strategies[<span class="string">'乙'</span>](person, items)</span><br><span class="line">        || strategies[<span class="string">'丙'</span>](person, items)</span><br><span class="line">&#125;</span><br><span class="line">persons.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">    person.rate = rating(person, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &gt; persons</span></span><br><span class="line"><span class="comment">// [ &#123; A: 80, B: 85, rate: '乙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 93, B: 70, rate: '丙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 92, B: 90, rate: '甲' &#125; ]</span></span><br></pre></td></tr></table></figure><h2 id="逻辑的转移"><a href="#逻辑的转移" class="headerlink" title="逻辑的转移"></a>逻辑的转移</h2><blockquote><p>所有的设计模式都遵循一条原则. 即 “找出程序中变化的地方, 并将变化封装起来”.</p></blockquote><p>将不变的隔离开来, 变化的封装起来. 策略模式中, 策略组对应着程序中不变的地方. 将策略组制定好存贮起来, 然后想着如何去分配使用策略.<br>当然, 如何制定策略和如何分配策略之间的关系十分紧密, 可以说两者相互影响.<br>再次看看制定的策略, “找出程序中变化的地方, 并将变化封装起来”, 我们可以再次改造一下.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line"><span class="string">'甲'</span>: <span class="number">90</span>,</span><br><span class="line"><span class="string">'乙'</span>: <span class="number">80</span>,</span><br><span class="line"><span class="string">'丙'</span>: <span class="number">70</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rating</span>(<span class="params">person, items</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> level = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">person, items</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> boolean = items.every(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> person[item] &gt;= strategies[value];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (boolean) <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level(<span class="string">'甲'</span>)(person, items)</span><br><span class="line">        || level(<span class="string">'乙'</span>)(person, items)</span><br><span class="line">        || level(<span class="string">'丙'</span>)(person, items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">persons.forEach(<span class="function"><span class="params">person</span> =&gt;</span> &#123;</span><br><span class="line">    person.rate = rating(person, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &gt; persons</span></span><br><span class="line"><span class="comment">// [ &#123; A: 80, B: 85, rate: '乙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 93, B: 70, rate: '丙' &#125;,</span></span><br><span class="line"><span class="comment">// &#123; A: 92, B: 90, rate: '甲' &#125; ]</span></span><br></pre></td></tr></table></figure><p>在上面的这种做法中, 我们把制定策略的逻辑挪到了分配策略里了. 所以说, 如何制定策略和如何分配策略, 依情况而定.<br>不过回头在看一看这段代码, 是不是和平时用对象映射的做法很相似.<br>当然, 策略模式的用法还有很多, 最常见的是规则校验.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下:</p><ol><li><p>策略模式至少包括两部分, 制定策略和分配策略.</p></li><li><p>策略模式的目的在于, 将策略制定和策略分配隔离开来.</p></li><li><p>策略制定和策略分配关系密切, 相互影响.</p></li></ol>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>在JavaScript中尝试组合模式</title>
    <url>/%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组合模式就是用小的子对象来构建更大的对象, 将对象组合成树形结构, 以表示 “部分-整体” 的层次结构. 位于底层最小的对象, 我们在这里称为叶对象, 由叶对象组成的组合对象我们称为分支对象, 位于最顶层的根对象在这里我们也称为分支对象. 不过它们只是结构上呈现出父子关系. 组合模式最大的好处可以一致性地对待分支对象和叶对象, 这也就要求了它们有着相同的接口.<br>在<a href="http://www.yexiaochen.com/%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5/">咬文嚼字说策略</a>中, 我们对员工进行考核, 划分了甲乙丙三个等级. 现在, 公司决定结合等级以资鼓励.<br><em>以下所有代码参见<a href="https://codepen.io/yexiaochen/pen/bzgQWb" rel="external nofollow noopener noreferrer" target="_blank">compositeMode</a>.</em></p><h2 id="开销的占比"><a href="#开销的占比" class="headerlink" title="开销的占比"></a>开销的占比</h2><p>现有考核人员:</p><table><thead><tr><th style="text-align:center">考核项目\考核人</th><th style="text-align:center">等级</th><th style="text-align:center">月薪</th></tr></thead><tbody><tr><td style="text-align:center">person_1</td><td style="text-align:center">甲</td><td style="text-align:center">6k</td></tr><tr><td style="text-align:center">person_2</td><td style="text-align:center">乙</td><td style="text-align:center">9k</td></tr><tr><td style="text-align:center">person_3</td><td style="text-align:center">乙</td><td style="text-align:center">4k</td></tr><tr><td style="text-align:center">person_4</td><td style="text-align:center">乙</td><td style="text-align:center">5k</td></tr><tr><td style="text-align:center">person_5</td><td style="text-align:center">丙</td><td style="text-align:center">6k</td></tr><tr><td style="text-align:center">person_6</td><td style="text-align:center">丙</td><td style="text-align:center">5k</td></tr><tr><td style="text-align:center">person_7</td><td style="text-align:center">丙</td><td style="text-align:center">6k</td></tr><tr><td style="text-align:center">person_8</td><td style="text-align:center">丙</td><td style="text-align:center">4k</td></tr><tr><td style="text-align:center">person_9</td><td style="text-align:center">甲</td><td style="text-align:center">8k</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> persons = [</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'甲'</span>, <span class="attr">salary</span>: <span class="number">6000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'乙'</span>, <span class="attr">salary</span>: <span class="number">9000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'乙'</span>, <span class="attr">salary</span>: <span class="number">4000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'乙'</span>, <span class="attr">salary</span>: <span class="number">5000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'丙'</span>, <span class="attr">salary</span>: <span class="number">6000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'丙'</span>, <span class="attr">salary</span>: <span class="number">5000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'丙'</span>, <span class="attr">salary</span>: <span class="number">6000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'丙'</span>, <span class="attr">salary</span>: <span class="number">4000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'丙'</span>, <span class="attr">salary</span>: <span class="number">9000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">scale</span>:<span class="string">'甲'</span>, <span class="attr">salary</span>: <span class="number">6000</span>, <span class="attr">company</span>: <span class="string">'JavaScript'</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>等级与月薪相关, 分别为3倍月薪、2倍月薪、1倍月薪.</p><table><thead><tr><th style="text-align:center">等级</th><th style="text-align:center">甲</th><th style="text-align:center">乙</th><th style="text-align:center">丙</th></tr></thead><tbody><tr><td style="text-align:center">月薪倍率</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scaleMap = &#123;</span><br><span class="line">  <span class="string">'甲'</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">'乙'</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="string">'丙'</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到底需要拿出多少钱奖励呢? 甲乙丙三组人分别占比多少呢? 针对这样的需求, 我们尝试着用组合模式计算一下.</p><h2 id="叶对象与分支对象"><a href="#叶对象与分支对象" class="headerlink" title="叶对象与分支对象"></a>叶对象与分支对象</h2><p>上面也提到了, 组合模式中有两类对象. 一个是分支对象, 一个是叶对象. 分支对象是叶对象的集合, 保存着叶对象的引用, 可以操作叶对象(比如添加, 执行). 而叶对象只要暴露接口即可.<br>现在我们从简单的开始, 造一个生产叶对象的函数.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> leaf = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...params,</span><br><span class="line">        expense() &#123;</span><br><span class="line">            <span class="keyword">return</span> scaleMap[params.scale]*params.salary</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分支对象就稍微麻烦些了, 因为需要管理叶对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> branch = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...params,</span><br><span class="line">        members: [],</span><br><span class="line">        add(item) &#123;</span><br><span class="line">            <span class="keyword">this</span>.members.push(item)</span><br><span class="line">        &#125;,</span><br><span class="line">        expense() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.members.reduce(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> sum + item.expense()</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>expense()</code> 的方法不论是在分支对象还是叶对象上, 或者说不清楚是分支对象还是叶对象, 我们都可以得到相应的结果. 在分支对象里, 保存着叶对象的引用, 我们可以对叶对象进行任何操作.</p><h2 id="从JSON数据到树形结构"><a href="#从JSON数据到树形结构" class="headerlink" title="从JSON数据到树形结构"></a>从JSON数据到树形结构</h2><p>组合模式就是这么简单, 剩下的就是如何 JSON 数据转换成层次分明的结构了.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> convertData = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> branchList = [];</span><br><span class="line">    <span class="keyword">const</span> branchObjs = [];</span><br><span class="line">    array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> leafObj = leaf(item);</span><br><span class="line">        <span class="keyword">if</span> (!branchList.includes(item.scale))&#123;</span><br><span class="line">            <span class="keyword">let</span> params = &#123;</span><br><span class="line">                scale: item.scale</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> branchObj = branch(params)</span><br><span class="line">            branchObjs.push(branchObj)</span><br><span class="line">            branchList.push(item.scale)</span><br><span class="line">        &#125;</span><br><span class="line">    branchObjs.filter(<span class="function"><span class="params">obj</span> =&gt;</span> obj.scale == item.scale)[<span class="number">0</span>].add(leafObj);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> branchObjs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'branchObjs'</span>, convertData(persons))</span><br><span class="line"><span class="keyword">const</span> scaleA = convertData(persons)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> scaleB = convertData(persons)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> scaleC = convertData(persons)[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'甲'</span>, scaleA.expense())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'乙'</span>, scaleB.expense())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'丙'</span>, scaleC.expense())</span><br></pre></td></tr></table></figure><p>最终结果展示</p><p><img src="../images/compositeMode.png" alt="compositeMode"></p><p>如果我们想知道公司的总支出, 也可以把 scaleA, scaleB, scaleC 组合在一起作为公司的一子集.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> company = branch();</span><br><span class="line">company.add(scaleA);</span><br><span class="line">company.add(scaleB);</span><br><span class="line">company.add(scaleC);</span><br><span class="line">company.expense()</span><br></pre></td></tr></table></figure><p><img src="../images/companyExpense.png" alt="companyExpense"></p><p>不难发现, 我们可以随意组装对象而不会影响到其它节点, 任何一个集合或个体都能够单独运行. 我们也可以根据需要去组合更复杂的结构. 但是, 如果通过组合模式创建了太多的对象, 那么这些对象可能会让系统负担不起.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>组合模式对象形式上至少有两种, 分支对象和叶对象.</p></li><li><p>分支对象和叶对象拥有相同的接口, 且对一组叶对象操作具有同步一致性.</p></li><li><p>组合模式是 HAS-A (聚合)关系, 不是 IS-A.</p></li></ol>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性的属性</title>
    <url>/%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>vue 的大行其道, 使得 <code>Object.defineProperty</code> 被更多人所认识. vue 利用 <code>Object.defineProperty</code> 提供的特性实现了数据绑定. 我们也可以据此动手实现一个简单的数据绑定(可参照<a href="https://www.yexiaochen.com/%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">进击的观察者模式</a>).</p><p>难道 <code>Object.defineProperty</code> 能做的只有这些么? 很显然不是.</p><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><blockquote><p>The Property Descriptor type is used to explain the manipulation and reification of Object property attributes.</p></blockquote><p>属性描述符到底是什么? 说白了就是对象属性的属性解释与具化, 就是对象属性本身具有哪些属性.</p><p>平时我们创建一个对象并为对象添加属性时, 可以这样</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.a = <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><p>有了对象字面量后, 想要达到同样的效果就更加省事了. 现在也都提倡使用字面量来创建对象.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'hello world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说程序员都是懒人嘛, 怎么简单怎么来. 通过 <code>Object.defineProperty</code> 为对象添加属性的方式也就淡出人们的视野.</p><blockquote><p>同样是为对象添加属性, 它们有什么区别呢?</p></blockquote><p>程序员身体可以懒, 但脑子要勤快, 要始终保持一颗好奇心.</p><p>其实不论是通过赋值, 还是通过字面量, 还是通过 <code>Object.defineProperty</code>, 最终还是殊途同归.</p><p>讲真, 平时的开发中, 使用对象字面量创建对象并添加属性时,压根就不会考虑到对象属性非个人意愿的改变了. 在我们看来, 对象就是存储着键值、键值映射用的. 我们可以任意添加, 删除, 更改对象属性, 我们认为这是理所当然的. 现实也的确如此, 你有对它为所欲为的权利.</p><h2 id="添加属性的差异"><a href="#添加属性的差异" class="headerlink" title="添加属性的差异"></a>添加属性的差异</h2><blockquote><p>可是为什么呢?🧐<br>😠你哪来的那么多为什么? 你为什么为什么呢!!!😠</p></blockquote><p>如果你稍微对 <code>Object.defineProperty</code> 有点了解, 应该知道通过这种方式定义的繁琐. 你也应该知道对象属性的操作也是有限制的. 想要放开权限, 我们需要这样做</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象字面量添加属性只是默认都为 true. 所以我们才可以为所欲为. 不相信么? 我们可以通过 <code>Object.getOwnPropertyDescriptor</code> 验证一下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.a = <span class="string">'hello world'</span></span><br><span class="line"><span class="keyword">let</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &gt; property</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello world',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>通过 <code>Object.getOwnPropertyDescriptor</code> 添加的属性, 可以自由灵活地设置属性描述符. 如果我不想配置的话, 它也有自己的默认值. 需要注意的是, 这里的默认值和对象字面量添加属性与赋值属性不同, 默认值为 false.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &gt; property</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br></pre></td></tr></table></figure><p>属性描述符等位数据描述符和访问描述符. 以上说的都是数据描述符.</p><h2 id="传闻中的Vue优化方案"><a href="#传闻中的Vue优化方案" class="headerlink" title="传闻中的Vue优化方案"></a>传闻中的Vue优化方案</h2><blockquote><p>道理我都懂, 那你这句话是啥个意思?</p><blockquote><p>压根就不会考虑到对象属性非个人意愿的改变了.</p></blockquote></blockquote><p>在 Vue 的 data 选项中，Vue 将遍历此对象所有的属性，并使用 <code>Object.defineProperty</code> 中的访问描述符 get/set 访问描述符重新定义一遍. 再结合观察者模式, 每次属性变化时都会收到通知, 从而达到数据绑定的效果. 显然并不是所有的属性都需要被转换监听.</p><p>对于展示型的数据, 就没有必要也不会出现数据内部属性的变化, 所以没必要做以上的处理. <code>Object.freeze</code> (用法可见<a href="http://www.yexiaochen.com/Object%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">Object构造函数</a>)处理后的对象, 就可以使得对象属性添加、修改等操作失效. 这样不去转换也不用去监听, 性能自然也就提高了.</p><h2 id="属性描述符键值"><a href="#属性描述符键值" class="headerlink" title="属性描述符键值"></a>属性描述符键值</h2><blockquote><p>枯燥的描述开始…</p></blockquote><h3 id="数据描述符和访问描述符同事具有的键值"><a href="#数据描述符和访问描述符同事具有的键值" class="headerlink" title="数据描述符和访问描述符同事具有的键值"></a>数据描述符和访问描述符同事具有的键值</h3><hr><p><strong><code>configurable</code></strong> : 若为 false, 不能删除该属性, 不能切换属性描述符(数据描述符切到访问描述符,或访问描述符切到数据描述符), 不能更改该属性的属性(对于数据描述符来说, value 属性除外, Writable 属性从 true 置为 false 除外). 说白了就是属性描述符的开关, 管理着该属性的属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hi world'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hi world'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hi world',</span></span><br><span class="line"><span class="comment">// writable: true,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hi world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: true,</span></span><br><span class="line"><span class="comment">// configurable: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hi world'</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p><strong><code>enumerable</code></strong> : 若为 true, 则在 for…in 枚举中可被枚举到.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'hello world'</span>,</span><br><span class="line">    b: <span class="string">'hi world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'c'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hey world'</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> propertyArray = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// &gt; propertyArray</span></span><br><span class="line"><span class="comment">// [ 'a', 'b' ]</span></span><br></pre></td></tr></table></figure><h3 id="仅数据描述符具有的键值"><a href="#仅数据描述符具有的键值" class="headerlink" title="仅数据描述符具有的键值"></a>仅数据描述符具有的键值</h3><hr><p><strong><code>value</code></strong> : 对象的该属性对应的值. 可以为任何有效的 JavaScript 值.</p><p><strong><code>writable</code></strong> : 若为false, 更改 value 将会失败.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hello world'</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.a = <span class="string">'hi world'</span></span><br><span class="line"><span class="keyword">let</span> property_1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    value: <span class="string">'hey world'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> property_2 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">// &gt; property_1</span></span><br><span class="line"><span class="comment">// &#123; value: 'hello world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &gt; property_2</span></span><br><span class="line"><span class="comment">// &#123; value: 'hey world',</span></span><br><span class="line"><span class="comment">// writable: false,</span></span><br><span class="line"><span class="comment">// enumerable: false,</span></span><br><span class="line"><span class="comment">// configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看出, 通过赋值更改属性值时, 会更改无效.</p><p>但是通过 <code>Object.defineProperty</code> 更改时, 将会成功更改属性值. 对此, 规范有提到, 当可配置不可写时更改属性值,会有 Writable 置为 true, =&gt; 设置 value =&gt; Writable 置为 false.</p><blockquote><p>Step 8.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false. This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true, a new [[Value]] is set, and then [[Writable]] is set to false.</p></blockquote><p>通过赋值和 <code>Object.defineProperty</code> 方式修改 value, 可以看出它们内部操作还是存在着差异.</p><h3 id="仅访问描述符具有的键值"><a href="#仅访问描述符具有的键值" class="headerlink" title="仅访问描述符具有的键值"></a>仅访问描述符具有的键值</h3><hr><p><strong><code>get</code></strong> : 访问该属性时, 该方法都会被执行.</p><p><strong><code>set</code></strong> : 修改该属性时, 该方法都会被执行.</p><p>vue 就是利用了访问描述符的这些特性, 实现了数据绑定.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> val</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'a'</span>, &#123;</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        val = value</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set =&gt; value'</span>, val)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get =&gt; value'</span>, val)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &gt; obj</span></span><br><span class="line"><span class="comment">// &#123; a: [Getter/Setter] &#125;</span></span><br><span class="line"><span class="comment">// &gt; obj.a = 'hello world'</span></span><br><span class="line"><span class="comment">// set =&gt; value hello world</span></span><br><span class="line"><span class="comment">// 'hello world'</span></span><br><span class="line"><span class="comment">// &gt; obj.a</span></span><br><span class="line"><span class="comment">// get =&gt; value hello world</span></span><br><span class="line"><span class="comment">// 'hello world'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>属性描述符</tag>
        <tag>defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>序言</title>
    <url>/%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<blockquote><p>忙活了好多天终于把博客搭建好了.平时上班的比较忙,利用零零散散的时间看了好多关于搭建博客的文章,消化之后,发现博客的搭建并不是想象那样麻烦.以前一直有搭建博客的想法,可是每每在搭建的过程中就放弃了.原因有很多,一部分是因为从没有接触过类似博客搭建的知识,也有部分原因是也没有搭建博客的需求.</p></blockquote><h2 id="为什么写"><a href="#为什么写" class="headerlink" title="为什么写"></a>为什么写</h2><p><strong>做任何事都是有原因的.</strong></p><p>有搭博客写博客的想法也是一直都是存在的.在大学的那会儿,一直觉得做程序员是一类高大上的人物,所以一直对这个行业心怀憧憬.平时看些技术型文章时,一般都是来自大牛的博客,写的文章或在第三方平台,或在自己搭建的博客上.就在那个时候,心中就有了能够拥有属于自己博客的想法.于是呢,自己也是有过尝试,但是对于毫无基础的菜鸟来说,那是一种折磨.挑战新的事物的确有意思,但是突然接触到好多不懂的概念,也是一种酸爽.不过随着经历和经验的积累,也慢慢发现,学习任何新的事物,都要有个循循渐进的过程,储备的足够了自然会从量变转为质变.当然这也是后来话了.在这个阶段搭建博客想法无非就是觉得新鲜,满足一下小虚荣.结局呢,可想而知,没有足够的动力,是不能完成有些许挑战性的任务的.</p><p><strong>毕竟动物趋于安逸,生性懒惰,没有压力,哪来的奔波.人,也是动物.</strong></p><p>毕业之后,就开始步入社会,这时候就要考虑如何谋生了.所幸的是,自己从一开始就选择了前端这个行业.从一个毕业就是失业的专业跳到了一个陌生的领域,除了曾经那一丝丝的憧憬让人有所安慰外,剩下的就是彷徨不安.在自学了一段时间的前端基础后,迫于对自身学习成果的不满和外在压力,硬着头皮投递了各家招聘网站的公司.白天参加面试,晚上还要学习巩固白天面试官提的问题.人的潜力或效率有时候还真是逼出来的.在面试期间的确学到了好多东西,也大概的知道了,这类行业到底需要什么样的人.</p><p><strong>人知道的越多,也就越知道不知道的太多.</strong></p><p>那时候自己就迫切希望能够稳定下来夯实一下自己的基础.经过一段时间的东奔西跑,找到了人生的第一份正式的工作.准确的说,是被找上了.不是说我的技术有多厉害,而是这份工作压根不需要什么技术.本来我是想拒绝的,也坦言了自己的状况.毕竟我是抱着学技术的心态出来的.可是经过一轮轮的面试,我也是知道,技术的重要性,再加上人家知道情况后还是要留人,那我也就留着呗.留在公司后,就是用cms搭个网站,申请个微信公众号做微信运营什么的.那时候真的什么都不知道,各种百度啊什么的.不过最终还是让我捣鼓出来了.之后日子也就安逸了,不过每天也是提心吊胆的,生怕哪一天老板又整出什么幺蛾子.时间空出来了,搭建博客的想法也是突然又重现在脑海中.趁着机会可以建站搭博客.所以,回家后又开始忙活起如何建站.可想法是好的,现实却偏偏作对.公司一直筹划着一些活动,微信上的一些活动也要同步得做起来,我又开始了各种网站收集资源.所以,搭博客的想法又泡汤了,而且学的前端基础在这段时间也丢了不少.<br>换了工作后,接触的到了具体实在的项目,积累的相关经验也就多了起来,一些笔记类的应用也用了起来.在开发过程中会遇到许多问题,自己也就更加主动去接受新的知识.可是虽然看到了好的文章,也收藏了起来,但是同样也犯了好多人犯的毛病.收藏夹里的记录一天天增加,却从来没有再次看过.而且,平时看的东西太过零散,无法形成自己的一套知识体系. 动力有了,搭建博客的想法也最终可以落实了.</p><h2 id="怎么去写"><a href="#怎么去写" class="headerlink" title="怎么去写"></a>怎么去写</h2><p>个人平时不善言辞,尤其平时做工作汇报时,最是尴尬,忙得要死结果几句话就给总结了.这突然让我想起了学生时代写作文的时候,我是如何凑足字数的.由于自身随心随性,不喜欢约束,只要有个大的目标就行了.个人觉得,约束后的自己不再是自己.有规划更要有自己的想法.我向来不喜欢照搬别人的做法.即使权威,也是不行.</p><p><strong>模具可以快速生产出许多成品,却无法产出一件精品.</strong></p><p>写东西也是要看状态的,尤其在写总结性的东西,需要把自己的想法加进去.状态在了,有时候看待问题会更加彻底.至于偏向于技术类型的东西,那就随便了,起码在我看来,那都是套路.无非就是要记录一下问题的解决方案.</p><h2 id="写什么"><a href="#写什么" class="headerlink" title="写什么"></a>写什么</h2><p>虽然搭博客的起因更多的来源于总结自己的工作经验.但是</p><blockquote><p>这个世界不只有眼前的苟且,还有诗与远方</p></blockquote><p>对于洒脱成性的我,看待生活时,总会时不时得冒出自己的想法和感悟.虽说不是写诗,但是凝练文采,沉淀底蕴,未尝不可.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>终于到了小结了,本以为自己言语匮乏.没想到也已经写了这么多.万一哪天灵感来了,估计会写出一部中篇小说.万事开头难,本来想是直接进入主题,写经验总结的.但唯恐坚持不下去,就写了这篇序言,以增加仪式感,希望自己能够坚持下去.</p>]]></content>
      <categories>
        <category>不语</category>
      </categories>
      <tags>
        <tag>序言</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>异步的JavaScript(回调篇)</title>
    <url>/%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript/</url>
    <content><![CDATA[<blockquote><p>唯一比不知道代码为什么崩溃更可怕的事情是，不知道为什么一开始它是工作的！</p></blockquote><p>在 ECMA 规范的最近几次版本里不断有新成员加入，尤其在处理异步的问题上，更是不断推陈出新。然而，我们在享受便利的同时，也应该了解异步到底是怎么一回事。</p><h2 id="现在与将来"><a href="#现在与将来" class="headerlink" title="现在与将来"></a>现在与将来</h2><p>JavaScript 是单线程的，一次只能专注于一件事。如果浏览器只靠 JavaScript 引擎线程来完成所有工作，先不说能不能搞定，即使可以，那也会花费很长时间。幸好在浏览器里 JavaScript 引擎并不孤单，还有 GUI 渲染线程、事件触发线程、定时触发器线程、异步http请求线程等其它线程。这些线程之间的协作才有了我们看到的浏览器界面效果（远不止这些）。</p><p>(盗了一张图)<br><img src="../images/thread.png" alt="thread"></p><p>一个程序在执行过程中可能会有等待用户输入、从数据库或文件系统中请求数据、通过网络发送并等待响应，或是以固定时间间隔执行重复任务（比如动画）等情况。（这些情况，当下是无法得出结果的，但是一旦有了结果，我们知道需要去做些什么。）</p><p>JavaScript 引擎不是一个人在战斗，它把以上的任务交给其它线程，并计划好任务完成后要做的事，JavaScript 引擎又可以继续做自己的事了。从这里可以看出，一个程序的运行包括两部分，现在运行和将来运行。<strong>而现在运行和将来运行的关系正是异步编程的核心。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> params = &#123;<span class="attr">type</span>:<span class="string">'asynchronous'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> response = ajax(params,<span class="string">'http://someURL.com'</span>); <span class="comment">// 异步请求</span></span><br><span class="line"><span class="keyword">if</span> (!response) <span class="keyword">throw</span> <span class="string">'无数据！'</span>;</span><br></pre></td></tr></table></figure><p>以上代码肯定会抛错的，异步请求任务交出去之后，程序会继续运行下去。由于ajax(…) 是异步操作，即使立刻返回结果，当下的 response 也不会被赋值。一个是现在，一个是将来，两者本就不属于一个时空的。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>现在和将来是相对的，等将来的时刻到了，将来也就成为了现在。<br>JavaScript 引擎运行在宿主环境中，宿主环境提供了一种机制来处理程序中多个块的执行，且执行每个块时调用 JavaScript 引擎，这种机制被称为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" rel="external nofollow noopener noreferrer" target="_blank">事件循环</a>。即，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。<br>“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。</p><p><strong>点击图片进入或<a href="http://latentflip.com/loupe" rel="external nofollow noopener noreferrer" target="_blank">点此进入</a>：</strong><br><a href="http://latentflip.com/loupe" rel="external nofollow noopener noreferrer" target="_blank"><img src="../images/EventLoop.gif" alt="EventLoop"></a></p><p>一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。<br>在事件循环期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.waitForMessage()) &#123;</span><br><span class="line">    queue.processNextMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有事件需要进行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互，IO 和定时器会向事件队列中加入事件。</p><p>(又盗了一张图)<br><img src="../images/render.png" alt="render"></p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>任务队列（job queue）建立在事件循环队列之上。（Promise 的异步特性就是基于任务。）<br>最好的理解方式，它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目（一个任务）。<br>即，由 Call Stack 生成的任务队列会紧随其后运行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>  <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>  <span class="title">promise3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'setTimeout3'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'promise4'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// setTimeout1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout2</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// promise4</span></span><br><span class="line"><span class="comment">// setTimeout3</span></span><br></pre></td></tr></table></figure><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Callback_function" rel="external nofollow noopener noreferrer" target="_blank">回调函数</a>。回调函数经常被用于继续执行一个异步完成后的操作，它们被称为异步回调。立即执行的称之为同步回调。<br>回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。<br>回调是 JavaScript 语言中最基础的异步模式。<br>生活中，我们喜欢和有条理的人打交道，因为我们的大脑习惯了这种思维模式。然而回调的使用打破了这种模式，因为代码的嵌套使得我们要在不同块间切换。嵌套越多，逻辑越复杂，我们也就越难理解和处理代码，尤其在表达异步的方式上。</p><p>(又盗了一张图)<br><img src="../images/callbackHell.jpg" alt="回调地狱"></p><p>除了嵌套的问题，异步回调还存在一些信任问题。</p><ul><li><p>回调性质的不确定</p></li><li><p>调用回调方式不确定（没调用，重复调用等）</p></li><li><p>……</p></li></ul><p>针对第一点的建议是：永远异步调用回调，即使就在事件循环的下一轮，这样，所有回调都是可预测的异步调用了。<br>在理解这个建议之前，我们首先了解下控制反转，控制反转就是把自己程序一部分的执行控制交个某个第三方。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>; <span class="comment">// A</span></span><br><span class="line">thirdparty(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>, a);    <span class="comment">// B</span></span><br><span class="line">&#125;)</span><br><span class="line">a++;    <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>A 和 C 是现在运行的，B 虽然代码是我们的，但是却受制于第三方，因为我们无法确定它是现在运行还是将来运行的。这里的回调函数可能是同步回调也可能是异步回调。a 是 0 还是 1，都有可能。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步回调</span></span><br><span class="line"><span class="keyword">const</span> thirdparty = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步回调</span></span><br><span class="line"><span class="keyword">const</span> thirdparty = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> cb(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，永远异步调用回调，可预测。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> func = fn;</span><br><span class="line">    <span class="keyword">let</span> t = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (fn) fn();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    fn = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            fn = func.bind(<span class="keyword">this</span>, ...arguments);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">thirdparty(asyncify(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>, a);</span><br><span class="line">&#125;))</span><br><span class="line">a++;</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>事件循环</tag>
        <tag>任务队列</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序云开发之始末</title>
    <url>/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E4%B9%8B%E5%A7%8B%E6%9C%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直都不喜欢微信，所以关于小程序的开发也是没怎么上心。只是在浏览招聘网站时，发现小程序已经成为前端开发人员的一个基本技能了。所以，只能硬着头皮尝试着学习开发小程序。</p><p>在学习小程序开发时，倒是没觉得有什么阻碍，毕竟前端的最流行的框架已经流行了那么多年了，从某些方面，它们是相似的。本次所开发的功能很简单，但是就整个流程来说却是很漫长的，由于是从零开始开发，所以大部分时间还是花在了产品的构思上和小程序一些奇奇怪怪的问题上。而且，这次的开发只完成了产品预想的 50% 左右，核心的部分基本没有去做。最大的原因可能就是开发体验不好，浪费时间。</p><h2 id="小程序云开发"><a href="#小程序云开发" class="headerlink" title="小程序云开发"></a>小程序云开发</h2><p>对于个人开发人员来说，小程序云开发降低了开发门槛，尤其是前端人员的门槛。基于云开发，前端人员可以完成从前端到后台的所有任务。小程序云平台有着 Node环境，所以我们可以把它想象成基于 node 的后台环境。<br>以爬虫为例，首先在 cloudfunctions 文件夹下创建文件夹 crawler，在该文件夹下面在创建创建相应 <code>crawler.js</code> 、<code>package.json</code> 文件，剩下就可以写些逻辑了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 云函数入口文件</span></span><br><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">'wx-server-sdk'</span>)</span><br><span class="line"><span class="keyword">const</span> Crawler = <span class="built_in">require</span>(<span class="string">"crawler"</span>);</span><br><span class="line">cloud.init()</span><br><span class="line"><span class="keyword">const</span> uriArray = [&#123; <span class="attr">uri</span>: <span class="string">'http://www.nows.fun/'</span>, <span class="attr">selector</span>: <span class="string">'#sentence'</span> &#125;, </span><br><span class="line">&#123; <span class="attr">uri</span>: <span class="string">'https://www.nihaowua.com/'</span>, <span class="attr">selector</span>: <span class="string">'body &gt; div &gt; section &gt; div'</span> &#125;, </span><br><span class="line">&#123; <span class="attr">uri</span>: <span class="string">'https://www.nihaowua.com/home.html'</span>, <span class="attr">selector</span>: <span class="string">'body &gt; div &gt; section &gt; div'</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> crawler = <span class="keyword">new</span> Crawler();</span><br><span class="line"><span class="keyword">let</span> canClick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crawlerWebPage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!canClick) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  canClick = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">let</span> &#123; uri, selector &#125; = uriArray[index];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    crawler.direct(&#123;</span><br><span class="line">      uri: uri,</span><br><span class="line">      retries: <span class="number">0</span>,</span><br><span class="line">      timeout: <span class="number">5000</span>,</span><br><span class="line">      skipEventRequest: <span class="literal">false</span>,</span><br><span class="line">      callback: <span class="function"><span class="keyword">function</span> (<span class="params">error, response</span>) </span>&#123;</span><br><span class="line">        canClick = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> $ = response.$;</span><br><span class="line">          <span class="keyword">var</span> content = $(selector).text();</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'index'</span>, index)</span><br><span class="line">          resolve(content);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.main = <span class="keyword">async</span> (event, content) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> crawlerWebPage();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>云函数创建好了，剩下的就是在小程序中去调用了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">refresh: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.data.canClick) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">    canClick: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  wx.showLoading(&#123;</span><br><span class="line">    title: <span class="string">'加载中'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  wx.cloud.callFunction(&#123;</span><br><span class="line">    name: <span class="string">"crawler"</span>,</span><br><span class="line">    success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      wx.hideLoading();</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        soup: res.result,</span><br><span class="line">        canClick: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      wx.hideLoading();</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        soup: <span class="string">"鸡汤要一口一口喝，你太急啦"</span>,</span><br><span class="line">        canClick: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'[云函数] [crawler] templateMessage.send 调用失败：'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小程序中的组件"><a href="#小程序中的组件" class="headerlink" title="小程序中的组件"></a>小程序中的组件</h2><p>刚开始接触小程序时，给我的感觉像是在开发一个多页面应用。在开发构思的过程中，需要写的逻辑越来越多。于是就想着把这么多的东西拆开，翻了下文档，发现小程序提到自定义组件比较适合。<br>首先在父组件中配置文件中配置子组件路径，然后自组件也要配置。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// father.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"type-year"</span>: <span class="string">"../../component/type-year/type-year"</span>,</span><br><span class="line">    <span class="attr">"type-month"</span>: <span class="string">"../../component/type-month/type-month"</span>,</span><br><span class="line">    <span class="attr">"type-date"</span>: <span class="string">"../../component/type-date/type-date"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// children.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就和 React、Vue 中的自定义组件差不多。</p><p>以上也只是自定义组件，平时还会接触到第三方的组件，比如常用的 UI 组件。通常第三方组件都是使用 npm 包，但是小程序的环境比较特殊，它不是 Node 环境，所以基于 Node 环境的 npm 包也要特殊处理才能够在小程序只能够使用。尽管小程序官方提供了 npm 包转换的方案，但是依然会有很多包不能在小程序中使用，具体可见官方小程序开发文档。</p><h2 id="小程序中操作节点"><a href="#小程序中操作节点" class="headerlink" title="小程序中操作节点"></a>小程序中操作节点</h2><p>小程序的渲染层和逻辑层分别由2个线程管理，这和浏览器的环境是不一样的，所以要想操作节点需要使用小程序提供的API，不过在跨组件获取节点时，需要注意一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onLoad: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> height = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> yearChartHeight,monthChartHeight,componentHeight;</span><br><span class="line">  <span class="keyword">let</span> query = wx.createSelectorQuery().in(<span class="keyword">this</span>); <span class="comment">// Note: 操作节点</span></span><br><span class="line">  query.selectAll(<span class="string">'#little_target, #target_type, #target_content'</span>).boundingClientRect(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      res.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        height[<span class="string">`<span class="subst">$&#123;item.id&#125;</span>_height`</span>] = item.height;</span><br><span class="line">      &#125;)</span><br><span class="line">      yearChartHeight = height.little_target_height - height.target_content_height - height.target_type_height;</span><br><span class="line"></span><br><span class="line">      componentHeight = monthChartHeight = height.little_target_height - height.target_type_height - <span class="number">48</span>;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">        yearHeight: yearChartHeight,</span><br><span class="line">        monthHeight: monthChartHeight</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ).exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是通过相关的 API 获取三个节点的数据。</p><h2 id="小程序中使用-echarts"><a href="#小程序中使用-echarts" class="headerlink" title="小程序中使用 echarts"></a>小程序中使用 echarts</h2><p>对比了 F2 和 echarts， 发现 echarts 提供的图表更多一些。这两个图表库的使用的方式也不同，F2 是 npm 包，需要转换导入使用。echarts 使用起来就相对简单一些，和上面提到的自定义组件一样，而且 echarts 还可以自定义选择需要图表导出，这样就减小包的体积。<br>在使用这些图表库时，才明白什么叫做调參工程师，在开发的过程中真的是边看文档边调整参数。在使用 echarts 的过程中，本以为canvas 可以撑开盒子，结果发现需要父元素需要有高度，这也是为什么上面动态计算盒子高度。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- init 1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"chart_wrap"</span> <span class="attr">style</span>=<span class="string">"height:&#123;&#123;chartHeight&#125;&#125;px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ec-canvas</span> <span class="attr">id</span>=<span class="string">"mychart-dom-bar"</span> <span class="attr">canvas-id</span>=<span class="string">"mychart-bar"</span> <span class="attr">ec</span>=<span class="string">"&#123;&#123; ec &#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">ec-canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">data: &#123;</span></span><br><span class="line"><span class="comment">    ec: &#123; onInit: initChart &#125;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- init 2--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"chart_wrap"</span> <span class="attr">style</span>=<span class="string">"height:&#123;&#123;chartHeight&#125;&#125;px"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ec-canvas</span> <span class="attr">id</span>=<span class="string">"mychart-dom-bar"</span> <span class="attr">canvas-id</span>=<span class="string">"mychart-bar"</span> <span class="attr">ec</span>=<span class="string">"&#123;&#123; ec &#125;&#125;"</span> <span class="attr">bind:init</span>=<span class="string">"echartInit"</span>&gt;</span><span class="tag">&lt;/<span class="name">ec-canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用的过程中发现，初始化的方式并不惟一，结果也是不一样，这个需要注意一下。</p><h2 id="小程序的开发体验"><a href="#小程序的开发体验" class="headerlink" title="小程序的开发体验"></a>小程序的开发体验</h2><p>小程序的开发工具真心不怎么样，从日常 chrome 开发者工具再到小程序的开发者工具，这其中的差距还是很大。而且，我们不能方便随意地使用 npm 包，这在小程序中限制很明显。<br>反正问题很多。</p><center><br><br><img src="../images/miniprograming.jpg" alt="miniprograming"><br><br></center><p>over！</p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>小程序</tag>
        <tag>云开发</tag>
      </tags>
  </entry>
  <entry>
    <title>异步的JavaScript(Promise篇)</title>
    <url>/%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%E2%80%94%E2%80%94Promise%E7%AF%87/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>错误理解精心组织起来的异步代码还不如使用一团乱麻的回调函数。</p></blockquote><p>在处理异步的问题上，回调基本上能够胜任，不过这都是建立在一切正常运转的基础上。</p><p>然而事与愿违，回调受到控制反转的影响，把控制权交给了第三方，这种控制转移导致了一系列的信任问题（回调调用过早、回调调用过晚、回调不被调用、回调调用次数过少或过多等问题）。同时，基于回调的异步表达又是无序性的，回调地狱的使用，让我们正确理解代码的难度加大。</p><p>函数的确可以规避以上的问题，但是，毋庸置疑，这会再次加大代码的理解难度。<br>与其交给不信任的第三方，倒不如转交给一个位于我们和第三方间的可信任的中介机制，这里就是我们要说的 <strong>Promise</strong>。</p><h2 id="回调的转变"><a href="#回调的转变" class="headerlink" title="回调的转变"></a>回调的转变</h2><p>如何把回调交给 <strong>Promise</strong>， 其实很简单。<br>使用 <strong>Promise</strong> 后我们就无需再关心大部分的信任问题和无序性。因为 <strong>Promise</strong> 机制已经为我们处理好了，我们不需要写些特定逻辑来解决一些信任问题和并发带来的竞态问题，只要我们按照 <strong>Promise</strong> 规范正确执行即可。现在，以 <code>setTimeout</code> 代表异步操作来进行 <strong>Promise</strong> 改造。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback async</span></span><br><span class="line"><span class="keyword">const</span> callback_async = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>), <span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something now</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback_async:初始时间戳'</span>, x)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something in the future</span></span><br><span class="line">        <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x</span><br><span class="line">        callback &amp;&amp; callback(<span class="string">`callback_async:在<span class="subst">$&#123;interval&#125;</span>毫秒后异步完成`</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">callback_async(<span class="literal">undefined</span>, res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'callback_async:'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <strong>Promise</strong> 中我们依然能够看到回调的身影，只是回调作为参数传递的位置发生了变化。我们不再把回调交给第三方，而是让 <strong>Promise</strong> 从第三方获取某些数据，然后回调作为参数传递进去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise_async = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something now</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise_async:初始时间戳'</span>, x)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// do something in the future</span></span><br><span class="line">            <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x</span><br><span class="line">            resolve(<span class="string">`promise_async:在<span class="subst">$&#123;interval&#125;</span>毫秒后异步完成`</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise_async(<span class="literal">undefined</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不同之前的把回调直接传给第三方的做法，这次是靠着 <strong>Promise</strong> 这个中间机制来替异步任务管理着回调。</p><h2 id="错误的处理"><a href="#错误的处理" class="headerlink" title="错误的处理"></a>错误的处理</h2><p>使用 <strong>Promise</strong> 后，怎么就会好了很多呢？首先说说在错误的处理上。<br>JavaScript 代码在执行的过程中若遇到错误就不会执行下去的。作为传入第三方的回调（同步回调或异步回调），如果在此之前就已经报错了，回调压根不会执行。在这种情况下，能通过回调捕获错误，也是很有意义的。我们很自然地想到了 <code>try...catch</code> , 不过在异步回调中，回调函数的执行栈与原函数分离开，导致外部是无法抓住异常。不过没关系，我们就多捕捉一遍。</p><p>在此，我们就用“error-first风格”模拟一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback async</span></span><br><span class="line"><span class="keyword">const</span> callback_async = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>), <span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'callback_async:初始时间戳'</span>, x)</span><br><span class="line">        <span class="comment">// do something now</span></span><br><span class="line">        <span class="comment">// throw 'callback-outer: error'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// do something in the future</span></span><br><span class="line">                <span class="comment">// throw 'callback-inner: error'</span></span><br><span class="line">                <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x</span><br><span class="line">                callback &amp;&amp; callback(<span class="literal">null</span>, <span class="string">`callback_async:在<span class="subst">$&#123;interval&#125;</span>毫秒后异步完成`</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                callback(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        callback(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">callback_async(<span class="literal">undefined</span>, (error, res) =&gt; &#123;</span><br><span class="line">    error?<span class="built_in">console</span>.log(<span class="string">'asyncError:'</span>, error):<span class="built_in">console</span>.log(<span class="string">'async:'</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>依次解开注释 <code>throw...</code> ，我们就可以成功地捕获到错误或异常。但同时也发现，对于一个不断嵌套的异步回调，就回调地狱那样，我们会为每一个异步回调做 <code>try...catch</code> 的错误处理，这会使原有的代码更加混乱。</p><p>“幸运”的是，<strong>Promise</strong> 已经为我们处理好了这个问题。对于错误或异常，我们只需要注册 <code>rejected</code> 或 <code>catch</code> 的回调即可。不过 <strong>Promise</strong> 也存在着和上面相同的问题，无法捕获脱离上下文环境的错误或异常，我们只能收到手动 <code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise_async = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something now</span></span><br><span class="line">        <span class="comment">// throw 'promise-outer: error'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise_async:初始时间戳'</span>, x)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// do something in the future</span></span><br><span class="line">                <span class="comment">// throw 'promise-inner: error'</span></span><br><span class="line">                <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x</span><br><span class="line">                resolve(<span class="string">`promise_async:在<span class="subst">$&#123;interval&#125;</span>毫秒后异步完成`</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">promise_async(<span class="literal">undefined</span>).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于多个异步任务，<strong>Promise</strong> 仍然能够很好的处理错误，因为 <strong>Promise</strong> 使用的 <code>this-then-that</code> 的流程控制，默认处理函数只是把错误重新抛出，这使得错误可以继续沿着Promise链传播下去，直到显式的 <code>rejected</code> 或 <code>catch</code> 捕获错误。</p><h2 id="Promise化"><a href="#Promise化" class="headerlink" title="Promise化"></a>Promise化</h2><p><strong>Promise</strong> 带来的好处远远不止这些。一旦 <strong>Promise</strong> 决议， 它就永远保持这个状态，这个 <strong>Promise</strong> 的 <code>then(...)</code> 注册的回调就会被自动调用，且只会被调用一次。这也算解决了回调调用过少、过多及不被调用的问题。即使不能解决，但也可以在此基础上再做处理。你要是问为什么，我只能说人家就是干这个的，作为一个可信任的中间协商机制。</p><p>说到一旦决议就不能改变，这个很重要么，是的，真的很重要。<br>在基于回调模式的异步处理中，JavaScript 代码执行后会一直走下去，遇到回调就直接执行了。但是 <strong>Promise</strong> 决议后，可以一直保留着这个结果，通过 <code>.then(..)</code> 形式添加的回调函数，甚至在异步操作完成之后才添加的回调函数，都会被执行调用。这也是上一个 <strong>Promise</strong> 里的错误只能在 <strong>Promise</strong> 链的下一个回调里捕获的原因。</p><p>知道了 <strong>Promise</strong> 的好处，也知道了基于回调模式的异步处理方式，我们就可以尝试把“error-first风格”的回调 <strong>Promise</strong> 化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise Wrap</span></span><br><span class="line"><span class="keyword">var</span> promise_wrap = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="literal">null</span>, args.concat(<span class="function">(<span class="params">error, value</span>) =&gt;</span> &#123;</span><br><span class="line">                error ? reject(error): resolve(value)</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到，为了统一处理现在和将来，我们把它们都变成了将来，即所有的操作都成了异步，同步回调也变成了异步回调。<br>JavaScript 异常错误也是如此，在 <strong>Promise</strong> 创建过程中或查看决议结果过程中出现的异常错误，这个异常错误被捕捉都会变成异步行为。这样做减少了由函数顺序不确定性（竞态条件）带来的诸多问题。</p><h2 id="保持扁平化"><a href="#保持扁平化" class="headerlink" title="保持扁平化"></a>保持扁平化</h2><p>从回调模式跨到 <strong>Promise</strong>，总会不小心保留着原来的风格，比如嵌套。<br>Promise 链式编程最好保持扁平化，不然不就变成另一个回调地狱了？关键是还没有返回或终止 <strong>Promise</strong> 链。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parallel Promise</span></span><br><span class="line"><span class="keyword">var</span> parallel_promise = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x;</span><br><span class="line">                resolve(<span class="string">`parallel-inner:在<span class="subst">$&#123;interval&#125;</span>毫秒后完成`</span>)</span><br><span class="line">            &#125;, <span class="number">3000</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`parallel-outer:在<span class="subst">$&#123;interval&#125;</span>毫秒后完成; res: <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">parallel_promise(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><p>从上面的执行结果可以看出，<code>parallel-outer</code> 并非在 <code>parallel-inner</code> 后执行。这是没有正确将 <strong>Promise</strong> 相连接的结果。</p><p>实际上，这里就是两个独立竞争的 <strong>Promise</strong>（同时在执行异步任务而不是一个接着一个）。同时我们也会注意到外层 <code>then(...)</code> 注册回调中 <code>res</code> 为 <strong>undefined</strong>，因为对于没有任何显式的决议，这个值就是 <strong>undefined</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serial Promise</span></span><br><span class="line"><span class="keyword">var</span> serial_promise = <span class="function">(<span class="params">x = <span class="built_in">Date</span>.now(</span>)) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x;</span><br><span class="line">                resolve(<span class="string">`serial-1:在<span class="subst">$&#123;interval&#125;</span>毫秒后完成`</span>)</span><br><span class="line">            &#125;, <span class="number">3000</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> interval = <span class="built_in">Date</span>.now() - x;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`serial-2:在<span class="subst">$&#123;interval&#125;</span>毫秒后完成; res: <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">serial_promise(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><p>所以说，</p><blockquote><p>一个好的经验法则是总是返回或终止 <strong>Promise</strong> 链，并且一旦得到一个新的 <strong>Promise</strong>，返回它。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>用 <strong>Promise</strong> 来表达异步和管理并发无疑是种进步，它在程序的顺序性和可信任性上提供了自己的解决方案。它不是回调的替代品，只是帮着异步任务管理回调的可信任的中间机制。</p><p>相对于直接粗暴的回调，<strong>Promise</strong> 并不会带来性能上的提升，但是它会让我们的程序更加健壮，也使得代码更加简洁，更加符合我们有序的思维方式。</p><p>当然，<strong>Promise</strong> 也有自己的局限性。在并发 <code>Promise.race(...)</code> 上，我们只要第一个决议即可。当出现第一个决议的 <strong>Promise</strong> 时，其它的 <strong>Promise</strong> 就没有必要进行下去了。然而，我们没把法终止。</p><p>在错误处理上，<strong>Promise</strong> 链中错误总是由下一个 <strong>Promise</strong> 捕获。如果错误发生在最后一个 <strong>Promise</strong> 呢？还有，对于嵌套的 <strong>Promise</strong>，内部 <strong>Promise</strong> 已经进行了错误处理，但是外部 <strong>Promise</strong> 却捕获不到，这样真的好么？</p><p><strong>Promise</strong> 恢复了可信任性，但我们还想让异步流程的表达风格更贴近同步的形式，链式调用不说不好，只是我们带着同步操作的惯性。还好，ES6、ES7已经给出了方案。</p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>then</tag>
      </tags>
  </entry>
  <entry>
    <title>异步的JavaScript（生成器篇）</title>
    <url>/%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%EF%BC%88%E7%BB%88%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>所谓的异步，就是程序的一部分现在进行，而另一部分则在将来运行。异步处理的重点就是如何处理将来运行的那一部分。</p><p>回调是 <strong>JavaScript</strong> 中最基本的异步模式，就是事先约定好将来要做的事然后回头调用。简单直接，但也存在不信任、调用嵌套过深等问题。对于编写代码、维护代码的我们而言，人类的大脑还是习惯于线性的处理方式。</p><p>基于回调的异步模式所存在的问题促使着我们寻求一种机制来保证回调的可信任，同时能更好的表达异步。这时候 <strong>Promise</strong> 出现了，<strong>Promise</strong> 的出现，并非要取代回调。而是把回调转交给了一个位于我们和其它工具之间的可信任的中介机制。<strong>Promise</strong> 链也提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 <strong>JavaScript</strong> 代码。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote><p><strong>Promise</strong> 虽然有序、可靠地管理回调，但是我们还是希望如同步般表达异步。</p></blockquote><p>我们已经知道生成器是作为生产迭代器的工厂函数，同时我们还要知道生成器也是一个消息传递系统。</p><h3 id="为什么是生成器"><a href="#为什么是生成器" class="headerlink" title="为什么是生成器"></a>为什么是生成器</h3><p>在生成器出现之前，程序代码一旦执行，就没有停下来的时候，直到程序结束🔚。然而在生成器里代码是可以暂停的，而且还可以和生成器之外通信☎️，通信结束后又可以恢复执行。回想一下之前的异步流程控制，我们一直在想方设法使得异步任务能够同步表达。现在，我们可以借助生成器来实现这一想法💡。</p><p>了解了生成器的特性之后，我们就应该知道，当生成器在执行一个异步任务时，完全可以把异步任务放在生成器外部执行，待异步任务执行结束后再返回🔙生成器恢复执行。要知道，生成器暂停的只是内部的状态，程序的其余部分还是正常运行的。这样的话，生成器内部的所有代码看起来都是同步表达了。</p><p>同时我们也要注意到，生成器不过是一种新🆕的表达方式，和异步还是同步没有半毛钱💰关系。既然没有关系，那在异步模式选择上就更无所谓了。考虑到异步系列文章是渐进式的，所以我们就用 <code>Promise + 生成器</code> 模式来表达异步。</p><h3 id="生成器与Promise的结合"><a href="#生成器与Promise的结合" class="headerlink" title="生成器与Promise的结合"></a>生成器与Promise的结合</h3><p>在异步流程控制方面，生成器是由两部分组成的。一部分是生成器内部代码以同步的方式表达任务，另一部分是由生成器生成的迭代器处理异步。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">async</span> = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">`第<span class="subst">$&#123;n&#125;</span>个异步任务`</span>)</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response_1 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> response_2 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> response_3 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response_1: %s;response_2: %s;response_3: %s;'</span>,response_1,response_2,response_3);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator();</span><br><span class="line"><span class="keyword">const</span> gen_1 = generator();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'gen_next_1: %s; gen_next_2: %s; gen_next_3: %s;'</span>, gen_1.next().value, gen_1.next().value, gen_1.next().value);</span><br><span class="line">gen.next().value.then(<span class="function"><span class="params">yield_1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yield_1: %s;'</span>, yield_1);</span><br><span class="line">    <span class="keyword">return</span> gen.next(yield_1).value.then(<span class="function"><span class="params">yield_2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'yield_2: %s;'</span>, yield_2)</span><br><span class="line">        <span class="keyword">return</span> gen.next(yield_2).value.then(<span class="function"><span class="params">yield_3</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'yield_3: %s'</span>, yield_3);</span><br><span class="line">            <span class="keyword">return</span> gen.next(yield_3);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// gen_next_1: [object Promise]; gen_next_2: [object Promise]; gen_next_3: [object Promise];</span></span><br><span class="line"><span class="comment">// yield_1: 第1个异步任务;</span></span><br><span class="line"><span class="comment">// yield_2: 第2个异步任务;</span></span><br><span class="line"><span class="comment">// yield_3: 第3个异步任务</span></span><br><span class="line"><span class="comment">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;</span></span><br></pre></td></tr></table></figure><p>如果只看 <strong>generator</strong> 函数这块，函数内部的写法和同步无异。<strong>gen</strong> 和 <strong>gen_1</strong> 都是同一生成器的实例。</p><p>如前文所述，理解这块代码还是要从两方面入手 ———— 迭代和消息传递。迭代属性在此不再赘述，现在重点是消息传递的属性。在生成器中，生成器函数被调用后并未立即执行，而是构造了一个迭代器。而生成器正是靠着 <code>yield/next</code> 来完成生成器内外部的双向通信。</p><p>在生成器内部，<strong>yield</strong> 是用来暂停（完全保持其状态）和向外部传递数据的关键字/表达式（初始时函数也是处于未执行状态）。在生成器外部，next 具有恢复生成器和向生成器内部传递数据的能力。</p><p>混沌初始（<code>gen</code> 造出来了），盘古开天辟地（第一个 <code>next()</code> 执行），天地初成，继女娲造人后，一切欣欣向荣。共工和祝融两个调皮蛋撞坏了不周山，给女娲出了一个难题（<code>yield</code>），华夏史驻此不前。女娲向上天求助（<code>yield async(1)</code>），上天回应了并送来了五彩石（<code>yield_1</code>）,女娲顺利补天，华夏史再次启程（<code>next(yield_1)</code>）。</p><p>然而好景不长，华夏部落经常受到蚩尤部落骚扰侵犯，蚩尤的存在再次阻碍了华夏史的前行（<code>yield</code>）。黄帝无奈向其师求助（<code>yield async(2)</code>），九天玄女授其兵法（<code>yield_2</code>）,黄帝顺利杀蚩尤，华夏史再次启程（<code>next(yield_2)</code>）。</p><p>然而好景不长，中原地带洪水泛滥，华夏史再次受阻（<code>yield</code>）。夏禹无奈向太上老君求助（<code>yield async(3)</code>）,太上老君赠其神铁（<code>yield_3</code>）,夏禹顺利治水，华夏史再次启程（<code>next (yield_3)</code>）。</p><p>实在编不下去了，还好结束了。😓 代码运行过程大抵如此。生成器内部生成一个数据，然后抛给迭代器消费，迭代器又把执行结果甩给了生成器。就是这么简单，别想的太复杂就行。</p><p>所谓的消息双向传递，指的不仅仅是正常情况下生成器内外部的数据。对于异常错误，生成器内外部也可以双向捕捉。因为生成器内部的暂停，是保留了其上下文的，所以 <code>try...catch</code> 又可以一展身手了。</p><h2 id="生成器自执行-amp-async-await"><a href="#生成器自执行-amp-async-await" class="headerlink" title="生成器自执行 &amp; async/await"></a>生成器自执行 &amp; async/await</h2><p><code>Promise + 生成器</code> 来表达异步算是实现了，然而我们也应该注意到在用迭代器控制生成器的那部分太过繁琐。<br>如果能够封装下就好了， 如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generator_wrap = <span class="function"><span class="keyword">function</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> gen = generator.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> handleNext = <span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">yield</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> next;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                next = gen.next(<span class="keyword">yield</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">                resolve(next.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="params">yield</span> =&gt;</span> &#123;</span><br><span class="line">                    handleNext(<span class="keyword">yield</span>);</span><br><span class="line">                &#125;, error =&gt; &#123;</span><br><span class="line">                    gen.throw(error);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        handleNext();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ———————————— 手动分割线 ————————————</span></span><br><span class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> response_1 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> response_2 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> response_3 = <span class="keyword">yield</span> <span class="keyword">async</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response_1: %s;response_2: %s;response_3: %s;'</span>,response_1,response_2,response_3);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">generator_wrap(generator);</span><br><span class="line"><span class="comment">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;</span></span><br></pre></td></tr></table></figure><p>不看 <strong>generator_wrap</strong> 函数，只看分割线以下的部分。至此，异步流程的表达越来越接近理想中的模样了。但 <strong>generator_wrap</strong> 函数还是需要自己手动封装，不过现在不用啦😄</p><p><strong>ES2017</strong> 推出了 <code>async/await</code> ，我们不用再自己去管理生成器，简单、强大、方便的 <code>async/await</code> 为我们处理了一切。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> awati_async = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response_1 = <span class="keyword">await</span> <span class="keyword">async</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> response_2 = <span class="keyword">await</span> <span class="keyword">async</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> response_3 = <span class="keyword">await</span> <span class="keyword">async</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'response_1: %s;response_2: %s;response_3: %s;'</span>, response_1, response_2, response_3);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">awati_async();</span><br><span class="line"><span class="comment">// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;</span></span><br></pre></td></tr></table></figure><p>至此，关于 JavaScript 的异步表达暂时告一段落了👋。</p>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>生成器</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>手写webpack脚手架的cli工具</title>
    <url>/%E6%89%8B%E5%86%99webpack%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84cli%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="日常吐槽"><a href="#日常吐槽" class="headerlink" title="日常吐槽"></a>日常吐槽</h2><p>本来想搭建一个webpack脚手架的，于是在搭建的过程中不断地搜集相关资料。可最终的结果是，webpack脚手架没有搭建成，却写出个 CLI 小工具。其实，这也并不是没有原因的。现在流行的框架都推出了自己的脚手架工具，比如，Vue CLI，Create React App 等。脚手架和CLI往往如影随形，这也导致了两者在概念上的混淆。标题为什么这么拗口，其实是为了区分这两个概念。</p><h2 id="我有一个想法"><a href="#我有一个想法" class="headerlink" title="我有一个想法"></a>我有一个想法</h2><p>既然被带跑偏了，就只能在跑偏的路上越跑越远吧。</p><blockquote><p>命令行界面（英语：Command-Line Interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（character user interface, CUI） ———— 维基百科</p></blockquote><p>使用过 Vue CLI 的同学应该都知道，我们只需要在终端敲几个的命令就可以搭建一个 Vue 的脚手架。如果不使用 CLI 的话，每次创建项目时，都需要配置文件（比如webpack配置文件）、设计结构、技术栈选型等。如果每次从零开始去搭建项目就会很麻烦，所以我们可以把相同的东西抽离成脚手架。以后创建项目时，就可以直接把脚手架复制过来，并以此为基础搭建项目。</p><p>回过头来再看看我们手动搭建项目的过程，从每次从零开始搭建项目到脚手架的复用，这中间有了很大的进步。可即使是复制黏贴，我们依然觉得很麻烦，如果用命令行的方式来取代图形操作，我们就可以更懒一些了。</p><p>回到主题，我本来打算写的webpack脚手架是基于这样的一个想法。➡️ 现在大部分的前端工程，webpack作为打包工具已经成了标配了。而 webpack 的配置是大同小异的，完全可以剥离出一个通用的webpack配置，然后针对个别配置进行修改。本次希望最终实现一个基于webpack适用于不同前端模板（React、Vue、ES+）的脚手架。</p><p>现在脚手架有了，如何<strong>自动化</strong>去搭建一个项目呢？</p><ol><li><p>复制或下载脚手架模板。（为了更灵活，上传到GitHub，或发布npm中）。</p></li><li><p>根据不同需求，在脚手架模板基础上重新配置webpack、package文件。</p></li><li><p>安装依赖。</p></li></ol><p>以下代码可见<a href="https://github.com/yexiaochen/multi-spa-webpack-cli" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>。</p><h2 id="CLI-中的预备工作"><a href="#CLI-中的预备工作" class="headerlink" title="CLI 中的预备工作"></a>CLI 中的预备工作</h2><p>首先了解一下 <code>#!</code>。文件开头要加上<code>#! /usr/bin/env node</code>。</p><blockquote><p>在计算领域中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。 ———— 维基百科<br>使用 #!/usr/bin/env 脚本解释器名称 是一种常见的在不同平台上都能正确找到解释器的办法。 ———— 维基百科</p></blockquote><p>然后看看都用到了哪些东西（部分）。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install commander chalk fs-extra shelljs inquirer ora ejs --save</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);  <span class="comment">// 解析命令;</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);  <span class="comment">// 命令行界面输出美颜</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);  <span class="comment">// fs的拓展;</span></span><br><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);  <span class="comment">// 重新包装了 child_process；</span></span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);  <span class="comment">// 交互式问答；</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>);  <span class="comment">// 输出样式美化；</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>);  <span class="comment">// 模版引擎；</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> currentPath = process.cwd();</span><br><span class="line"><span class="keyword">let</span> answersConfig = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="命令的解析"><a href="#命令的解析" class="headerlink" title="命令的解析"></a>命令的解析</h2><p>类似与 Vue 的 <code>vue init</code>，我们也希望自己的 CLI 也能拥有类似的功能。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  "bin": &#123;</span><br><span class="line">    "multi-spa-webpack": "./bin/multi-spa.js"</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样，我们就有了<code>multi-spa-webpack</code>的命令。如果我们想要全局使用，还需要执行下面命令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure><p>接下来就要初始化<code>multi-spa-webpack</code>相关的命令了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line">program</span><br><span class="line">  .command(<span class="string">'init &lt;项目路径&gt; [选项]'</span>)</span><br><span class="line">  .description(<span class="string">'指令说明：初始化项目'</span>)</span><br><span class="line">  .action(<span class="keyword">async</span> (appName) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> targetDir = path.resolve(currentPath, appName || <span class="string">'.'</span>);</span><br><span class="line">      <span class="keyword">if</span> (fs.pathExistsSync(targetDir)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (program.force) &#123;</span><br><span class="line">          GenarateProject(appName);  <span class="comment">// 创建项目；</span></span><br><span class="line">        &#125;</span><br><span class="line">        ora(chalk.red(<span class="string">`！当前目录下，<span class="subst">$&#123;appName&#125;</span>已存在，请修改名称后重试`</span>)).fail();</span><br><span class="line">        process.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      answersConfig = <span class="keyword">await</span> getAnswers(appName);</span><br><span class="line">      GenarateProject(appName);  <span class="comment">// 创建项目；</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      ora(chalk.red(<span class="string">`项目创建失败：<span class="subst">$&#123;error&#125;</span>`</span>)).fail();</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">program</span><br><span class="line">  .arguments(<span class="string">'&lt;command&gt;'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">cmd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.red(<span class="string">`！命令未能解析 &lt;<span class="subst">$&#123;chalk.green(cmd)&#125;</span>&gt;`</span>));</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    program.outputHelp();</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">  &#125;);</span><br><span class="line">program.parse(process.argv);</span><br><span class="line"><span class="keyword">if</span> (program.args.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="built_in">console</span>.log(chalk.red(<span class="string">'！输入的命令有误'</span>));</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  chalk.cyan(program.help());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制或下载模板"><a href="#复制或下载模板" class="headerlink" title="复制或下载模板"></a>复制或下载模板</h2><p>在执行<code>multi-spa-webpack init spa-project</code>后，就需要拷贝一份脚手架到本地了。至于脚手架从哪里来，可以放在 github 上（类似 Vue CLI）或 放在 CLI 对应的目录下（类似create-react-app）。<br>本文是采用的是从 github 获取脚手架模板的。但是常规的方式，只能下载整个项目，而对于不需要的文件夹或文件，也会同时下载，下载后，只能在本地中删除无关文件了。我这里是从源头上剔除无关文件的下载，这个方法可能会有一些局限性吧（sparse-checkout）。不过两者最终的目的是一样的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DownTemplate</span>(<span class="params">projectDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> remote = <span class="string">'https://github.com/yexiaochen/multi-spa-webpack-cli.git'</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; template &#125; = answersConfig;</span><br><span class="line">  <span class="keyword">let</span> downTemplateSpinner = ora(chalk.cyan(<span class="string">'模板下载中...'</span>)).start();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    shell.exec(<span class="string">`</span></span><br><span class="line"><span class="string">      mkdir <span class="subst">$&#123;projectDir&#125;</span></span></span><br><span class="line"><span class="string">      cd <span class="subst">$&#123;projectDir&#125;</span></span></span><br><span class="line"><span class="string">      git init</span></span><br><span class="line"><span class="string">      git remote add -f origin <span class="subst">$&#123;remote&#125;</span></span></span><br><span class="line"><span class="string">      git config core.sparsecheckout true</span></span><br><span class="line"><span class="string">      echo "template/common" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      echo "template/config" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      echo "template/services" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      echo "template/<span class="subst">$&#123;template&#125;</span>" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      echo ".gitignore" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      echo "package.json" &gt;&gt; .git/info/sparse-checkout</span></span><br><span class="line"><span class="string">      git pull origin master</span></span><br><span class="line"><span class="string">      rm -rf .git</span></span><br><span class="line"><span class="string">      mv template/* ./</span></span><br><span class="line"><span class="string">      rm -rf template</span></span><br><span class="line"><span class="string">      `</span>, (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          downTemplateSpinner.stop()</span><br><span class="line">          ora(chalk.red(<span class="string">`模板下载失败：<span class="subst">$&#123;error&#125;</span>`</span>)).fail()</span><br><span class="line">          reject()</span><br><span class="line">        &#125;</span><br><span class="line">        downTemplateSpinner.stop();</span><br><span class="line">        ora(chalk.cyan(<span class="string">'模板下载成功'</span>)).succeed();</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新生成配置文件"><a href="#重新生成配置文件" class="headerlink" title="重新生成配置文件"></a>重新生成配置文件</h2><p>像 webpack、package 等配置文件，也都是包含在脚手架里的，不过这些配置还不能直接拿来用。我们还需要通过交互式问答，来针对性得在现有的基础上重新生成配置文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnswers</span>(<span class="params">appName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = [</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'name'</span>,</span><br><span class="line">      message: <span class="string">'项目名称'</span>,</span><br><span class="line">      <span class="keyword">default</span>: appName,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'input'</span>,</span><br><span class="line">      name: <span class="string">'description'</span>,</span><br><span class="line">      message: <span class="string">'项目描述'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'单页面应用'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">'confirm'</span>,</span><br><span class="line">      name: <span class="string">'eslint'</span>,</span><br><span class="line">      message: <span class="string">'是否启用 eslint+pretty'</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'cssPreprocessor'</span>,</span><br><span class="line">      type: <span class="string">'list'</span>,</span><br><span class="line">      message: <span class="string">'CSS 预处理器'</span>,</span><br><span class="line">      choices: [</span><br><span class="line">        <span class="string">"less"</span>,</span><br><span class="line">        <span class="string">"sass"</span>,</span><br><span class="line">        <span class="string">"none"</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'template'</span>,</span><br><span class="line">      type: <span class="string">'list'</span>,</span><br><span class="line">      message: <span class="string">'选取模板'</span>,</span><br><span class="line">      choices: [</span><br><span class="line">        <span class="string">"react"</span>,</span><br><span class="line">        <span class="string">"vue"</span>,</span><br><span class="line">        <span class="string">"es"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">return</span> inquirer.prompt(options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获得特定的需求后，还要把这些数据注入到配置文件中。就是通过模板引擎把数据塞到模板里。这里使用的是 ejs 模版引擎。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- webpack.common.ejs --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">answers.cssPreprocessor</span> == <span class="string">'none'</span></span></span><br><span class="line"><span class="tag">    ? /\<span class="attr">.css</span>$/ <span class="attr">:</span> (<span class="attr">answers.cssPreprocessor</span> == <span class="string">'less'</span> ? /\<span class="attr">.less</span>$/ <span class="attr">:</span> /\<span class="attr">.scss</span>$/) %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">answers.cssPreprocessor</span> == <span class="string">'none'</span></span></span><br><span class="line"><span class="tag">    ? '' <span class="attr">:</span> (<span class="attr">answers.cssPreprocessor</span> == <span class="string">'less'</span> ? '<span class="attr">less-loader</span>' <span class="attr">:</span> '<span class="attr">sass-loader</span>') %&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GenarateWebpackConfig</span>(<span class="params">targetDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> webpackConfigPath = path.resolve(<span class="string">`<span class="subst">$&#123;currentPath&#125;</span>/<span class="subst">$&#123;targetDir&#125;</span>/config`</span>, <span class="string">'webpack.common.ejs'</span>);</span><br><span class="line">    <span class="keyword">const</span> webpackConfigTargetPath = path.resolve(<span class="string">`<span class="subst">$&#123;currentPath&#125;</span>/<span class="subst">$&#123;targetDir&#125;</span>/config`</span>, <span class="string">'webpack.common.js'</span>);</span><br><span class="line">    <span class="keyword">const</span> webpackConfigSpinner = ora(chalk.cyan(<span class="string">`配置 webpack 文件...`</span>)).start();</span><br><span class="line">    <span class="keyword">let</span> webpackConfig = <span class="keyword">await</span> fs.readFile(webpackConfigPath, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">let</span> generatedWebpackConfig = ejs.render(webpackConfig, &#123; <span class="attr">answers</span>: answersConfig &#125;);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      fs.writeFile(webpackConfigTargetPath, generatedWebpackConfig),</span><br><span class="line">      fs.remove(webpackConfigPath)</span><br><span class="line">    ])</span><br><span class="line">    webpackConfigSpinner.stop();</span><br><span class="line">    ora(chalk.cyan(<span class="string">`配置 webpack 完成`</span>)).succeed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    ora(chalk.red(<span class="string">`配置文件失败：<span class="subst">$&#123;error&#125;</span>`</span>)).fail();</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GenaratePackageJson</span>(<span class="params">projectDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, description, cssPreprocessor &#125; = answersConfig;</span><br><span class="line">    <span class="keyword">const</span> packageJsonPath = path.resolve(<span class="string">`<span class="subst">$&#123;currentPath&#125;</span>/<span class="subst">$&#123;projectDir&#125;</span>`</span>, <span class="string">'package.json'</span>);</span><br><span class="line">    <span class="keyword">const</span> packageJsonSpinner = ora(chalk.cyan(<span class="string">'配置 package.json 文件...'</span>)).start();</span><br><span class="line">    <span class="keyword">let</span> package = <span class="keyword">await</span> fs.readJson(packageJsonPath);</span><br><span class="line">    package.name = name;</span><br><span class="line">    package.description = description;</span><br><span class="line">    <span class="keyword">if</span> (cssPreprocessor == <span class="string">'less'</span>) &#123;</span><br><span class="line">      package.devDependencies = &#123;</span><br><span class="line">        ...package.devDependencies,</span><br><span class="line">        <span class="string">"less-loader"</span>: <span class="string">"^5.0.0"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cssPreprocessor == <span class="string">'sass'</span>) &#123;</span><br><span class="line">      package.devDependencies = &#123;</span><br><span class="line">        ...package.devDependencies,</span><br><span class="line">        <span class="string">"node-sass"</span>: <span class="string">"^4.12.0"</span>,</span><br><span class="line">        <span class="string">"sass-loader"</span>: <span class="string">"^7.1.0"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> fs.writeJson(packageJsonPath, package, &#123; <span class="attr">spaces</span>: <span class="string">'\t'</span> &#125;);</span><br><span class="line">    packageJsonSpinner.stop();</span><br><span class="line">    ora(chalk.cyan(<span class="string">'package.json 配置完成'</span>)).succeed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      ora(chalk.red(<span class="string">`配置文件失败：<span class="subst">$&#123;error&#125;</span>`</span>)).fail();</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>其实配置文件生成后，CLI 就快接近尾声了。剩下就是安装依赖。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi-spa.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InstallDependencies</span>(<span class="params">targetDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> installDependenciesSpinner = ora(chalk.cyan(<span class="string">`安装依赖中...`</span>)).start();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    shell.exec(<span class="string">`</span></span><br><span class="line"><span class="string">    cd <span class="subst">$&#123;targetDir&#125;</span></span></span><br><span class="line"><span class="string">    npm i</span></span><br><span class="line"><span class="string">    `</span>, (error) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          installDependenciesSpinner.stop()</span><br><span class="line">          ora(chalk.red(<span class="string">`依赖安装失败：<span class="subst">$&#123;error&#125;</span>`</span>)).fail()</span><br><span class="line">          reject()</span><br><span class="line">        &#125;</span><br><span class="line">        installDependenciesSpinner.stop();</span><br><span class="line">        ora(chalk.cyan(<span class="string">'依赖安装完成'</span>)).succeed();</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个粗糙的CLI，就这么完成了。把以上几个方法包装一下，就是本次 CLI 的全部内容了。</p><ol><li>拷贝脚手架。2. 重新生成配置文件。3安装依赖。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">GenarateProject</span>(<span class="params">targetDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> DownTemplate(targetDir);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([GenaratePackageJson(targetDir).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> InstallDependencies(targetDir);</span><br><span class="line">  &#125;),</span><br><span class="line">  GenarateWebpackConfig(targetDir)</span><br><span class="line">  ]);</span><br><span class="line">  ora(chalk.cyan(<span class="string">'项目创建成功！'</span>)).succeed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要发布，需要登陆npm ，<code>npm publish</code>。</p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>CLI</tag>
        <tag>命令行界面</tag>
      </tags>
  </entry>
  <entry>
    <title>所谓的微前端</title>
    <url>/%E6%89%80%E8%B0%93%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="微前端实践"><a href="#微前端实践" class="headerlink" title="微前端实践"></a>微前端实践</h1><p>那时候的微前端还没今天这般火热，回过头来仔细琢磨才发现那是最早的一次微前端实践。当时，我们在做项目迁移，使用最新的前端技术重写了系统。可是规划中并没有给我们足够的时间去重写项目，而且二期的需求已经开始排期了。系统的升级没有完成，就只能用老系统。这也意味着新的需求，我们需要在新旧系统上都要做一遍，这段时间里，在人力安排上真是苦不堪言。</p><p>如果在新系统上完成的功能模块也可以运行在老系统上，这不就省下很多的时间和人力了么？这就是微前端的使用场景吧。而后来又不断有第三方的应用集成进来，现在想想，这种需求其实还是比较常见的。所以要说微前端都用在哪里，可以想到的是，新旧系统迁移和聚合应用。</p><p>我理解的微前端，就是把不同的前端项目聚在一起，最起码从视图的角度来看，它们是一体的，这些前端应用可以各自独立开发，互不干扰。而在当今的前端圈中，React、Vue 和 Angular 最为流行，这也使得应用聚合时变得麻烦起来，所以也有提出 React 和 Vue 互转的方案。</p><center><br><image src="../images/code-to-code.png" style="width:90%"><br></image></center><p>最简单的方式是通过路由分发，可以是在前端应用中配置也可以是反向代理配置。</p><center><br><image src="../images/route-jump.png" style="width:90%"><br></image></center><p>如果是前端路由分发，需要写个路由管理的组件。不过，还可以更省事，就拿上面提到的新旧系统的迁移，我们使用了以下方案。</p><center><br><image src="../images/mounted-point.png" style="width:90%"><br></image></center><p>B、C 挂载点就是需要挂载在 A 应用上的 DOM 节点。</p><p>而对于相同技术栈的前端应用，虽然以上的方法都以使用，但是，这么做就可能有些浪费。既然是相同技术栈，那么依赖就有可能是相同的，而对于共同的依赖没有必要多次去加载。这让人想起了 webpack 上 DLL 插件，就是把基础库剥离出来。</p><center><br><image src="../images/component-dependence.png" style="width:90%"><br></image></center><p>还有 iframe，这让人想到一个笑话，有个老板要做引擎，还要做成百度那样的，如果使用 iframe 应该是秒秒钟的事情，不过这东西对 SEO 不友好，而且限制条件比较多，像 MDN 这类网站就是不行的。Visual Studio Code 上展示 web 页面的插件就有用 iframe 实现的。</p><p>实现微前端的方案还有很多，而且并不是特别难的事情，可能是越花哨的词，让人越觉得调调高吧。</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>架构与协作</title>
    <url>/%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BE%B9%E7%95%8C/</url>
    <content><![CDATA[<h1 id="架构与边界"><a href="#架构与边界" class="headerlink" title="架构与边界"></a>架构与边界</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总算把《架构整洁之道》看完了，这种看还是走马观花的看法。这本书和前端没有什么直接的关联，看完之后，你甚至会想，前端有架构这个概念么？其实，从系统架构角度看，前端所做的工作只是可替代的实现细节而已。即使如此，也不妨碍从中学到有用的知识，毕竟道理都是相通的。</p><h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p>步入正题，如果只是一个简单的系统，倒是不用在乎架构设计。但系统越来越庞大，越来越复杂的时候，糟糕的设计只会使得投入与产出不成正比，甚至于入不敷出。而罪魁祸首就是人们经常用来自欺欺人的一句话，「技术债后期还上，产品先上线！」。但是，需求永远是做不完的，更何况，短期内技术升级是看不到任何产出的。</p><blockquote><p>稳即是快！</p></blockquote><p>稳，是要求软件架构的质量有保证，要求每一个实施的技术方案都经过调研和论证，而不能因业务的压力匆匆上线。虽然，「software」，soft 指的是软件的灵活性，但这和系统的「稳」并不冲突，而恰恰因为稳才使得系统更具灵活性。</p><blockquote><p>那么，回过头再看一看，导致生产效率持续降低的这个锅到底谁来背？</p></blockquote><p>系统的价值可以通过行为和架构两个维度来衡量。行为价值，是指将需求文档变为实际的代码，为使用者创造价值，同时修复任何 Bug。架构价值，体现在让功能实现起来更容易、修改起来更简单、扩展起来更轻松。我们将这两个维度对照着紧急/重要矩阵：</p><ul><li>系统行为：紧急</li><li>系统架构：重要</li></ul><p>再按优先级排序：</p><ol><li>重要且紧急</li><li>重要不紧急</li><li>不重要但紧急</li><li>不重要且不紧急</li></ol><p>系统架构占据第一、第二位，系统行为占据第一、第三位。而实际开发过程中，在业务部门和研发人员的“共同努力下”，错误地将第三优先级的事情当成第一优先级去做。</p><p>业务部门意识不到系统架构的重要性很正常，但是身为研发人员呢？这是研发人员的职责所在，有必要去抗争来自其它部门的压力，阐述问题的重要性。</p><blockquote><p>“这是你的问题！”</p><p>“不用说了，听我的！”</p><p>“这个事情不需要讨论。”</p></blockquote><p>研发人员出力不讨好，费神又费力，到底为了什么？</p><blockquote><p>软件架构的终结目标是，用最小的人力成本来满足构建和维护该系统的需求。</p></blockquote><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>开发中的最佳实践在团队协作中同样适用，管理团队也需要像架构师一样去协调团队及个体之间的关系。在开发过程中，沟通成本其实还是挺高的，这时候就可以学习学习系统中的数据是如何在组件间传递的。</p><blockquote><p>架构师所追求的目标是最大限度地降低构建和维护一个系统所需的人力资源。那么我们就需要了解一个系统最消耗人力资源的是什么？答案是系统中存在的耦合 —— 尤其是那些过早做出的、不成熟的决策所导致的耦合。</p></blockquote><p>以前端团队为背景：</p><p>「尤其是那些过早做出的、不成熟的决策所导致的耦合。」这些很好类比，比如高层拍屁股拍出的想法，产品不成熟的想法等，这些决策直接下发到代码的实现者，然后依据反馈不断纠正。</p><blockquote><p>边界线也应该沿着系统的变更轴来画。也就是说，位于边界线两侧的组件应该以不同原因、不同速率变化着。</p></blockquote><p>根据不同的职能划分不同的区域，左边偏业务，右边偏技术，尴尬的是处在边界上的这位仁兄。如果组长的话语权不够，那就成为谦卑对象的存在了。</p><p><img src="../images/Architecture.png" alt="管理架构图"></p><p>先忽略红线，根据单一职责，做好自己的本职工作，有输入有输出，依赖关系简单，沟通效率高。组长和组员的关系就如同展示器和视图的关系，组长需要将需求整理成最终的任务分配下去，工作内容包括参与需求评审，技术方案的制定，项目排期等，组员只需要执行任务并反馈即可。</p><p>再看一看红线部分，边界本来就是应对频繁变更的需求而建立的防火墙，此时红线绕过边界干预边界的另一头，面对这么多的输入，组员也会蒙圈，这任务谁在负责，我该向谁反馈，这个人提出的问题那个人确认了么，等等一系列的问题。</p><p>所以，私底下对于频繁变更需求并干预边界右侧的产品，我们称之为傻叉某某。对于经常拍屁股拍出想法并干预右侧的 leader，我们也称之为傻叉某某。</p><h2 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h2><p>要想稳，就得保证任务高效有质量地完成。任务派发给了蓝框里的研发人员，研发人员之间的指派总不能靠抓阄来决定。</p><blockquote><p>A：“这个开发难度为S级（困难）的任务就交给你了，我先走一步。”</p><p>B：“。。。”</p><p>某一天，</p><p>C: “之前的 A 水平有限，这代码已经没法维护了，重做吧。”</p><p>B：“。。。”</p><p>C：“抓紧点，我们要赶超对手，没错，就你一个人。”</p><p>B：“。。。”</p></blockquote><p>从以上对话，我们来思考几个问题。如果 B 的水平和 A 一样，最终的结果是项目还会因为无法维护而重做。如果 B 能够胜任，由于时间的问题，最终的结果可能比第一种情况好一些。如果 B 能够胜任，老板为了加快进度，又投入一个人，最终的结果就是个谜，因为这要取决于 B 的水平。</p><p>不过现在是一个团队了，团队就应该发挥团队应有的优势。</p><p><img src="../images/team.png" alt="任务分配"></p><p>所以，职责要明确，搭配要妥当。</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a><a href="https://segmentfault.com/a/1190000006672573" rel="external nofollow noopener noreferrer" target="_blank">浏览器缓存</a></h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a><strong>强缓存</strong></h2><p>释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，告诉客户端将这个资源保存在本地，并且在未来的某个时点之前如果还需要这个资源，直接从本地获取就行了，不用向服务器请求.这种方式缓存下来的资源称为强缓存.</p><h3 id="Expires-amp-Cache-Control-max-age"><a href="#Expires-amp-Cache-Control-max-age" class="headerlink" title="Expires &amp; Cache-Control:max-age"></a><code>Expires</code> &amp; <code>Cache-Control:max-age</code></h3><ul><li><em>Expires</em>:<br>该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.</li><li><p><em>Cache-Control</em>:<br>该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.<br>参数:<br><code>no-cache</code>: 如果请求头部包含no-cache指令，表示客户端不接收缓存过的响应.中间缓存服务器必须将请求转发给给源服务器. <em>浏览器强制刷新(window下ctrl+F5)就是这个原理，所以的请求都设置no-cache</em><br><code>no-store</code>: 暗示请求和响应包含机密信息，不能进行缓存.<br><strong>区分: no-store才是真正的不缓存</strong><br><code>max-age</code>: 该指令用来标识缓存资源的最大有效期. <em>如果max-age=0，就会向源服务器发送请求进行缓存资源新鲜度的验证.浏览器普通刷新F5</em></p><ul><li><p>“Cache-Control”:” cache-directive”*作为<strong>请求首部</strong>时，cache-directive 的可选值有:</p><p><img src="../images/请求首部.png" alt="请求首部"></p></li><li><p>“Cache-Control”:” cache-directive”*作为<strong>响应首部</strong>时，cache-directive 的可选值有:</p><p><img src="../images/响应首部.png" alt="响应首部"></p><blockquote><p>在请求头中max-age=0与no-cache的区别？</p><pre><code>返回的状态来看：no-cache都是200，而max-age可能是304（如果浏览器有缓存）.  
请求参数：max-age请求头一般会携带If-Modified-Since或If-None-Match字段进行新鲜度验证，而no-cache不会携带. F5刷新是max-age=0来实现，而强制刷新(Ctrl+F5)是通过no-cache实现.
</code></pre></blockquote></li></ul></li></ul><blockquote><p>异同: <code>Expires</code>是HTTP 1.0+的首部，用来指定一个绝对的过期日期，依赖客户端时间设置的准确性,缓存时间是相对服务器上的时间而言的.<br>而<code>max-age</code>是HTTP/1.1的Cache-Control的一个字段，用来指定文档的最大使用时间.</p></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h2><p>释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，将该资源的一些信息（文件摘要、或者最后修改时间）也返回给客户端，告诉客户端将这个资源缓存在本地.当客户端下一次需要这个资源时，将请求以及相关信息（文件摘要、或者最后修改时间）一并发送给服务器，由服务器来判断客户端缓存的资源是否需要更新：如不需要更新，就直接告诉客户端获取本地缓存资源；如需要更新，则将最新的资源连同相应的信息一并返回给客户端.</p><h3 id="Last-Modified-amp-If-Modified-Since-amp-Etag-amp-If-None-Match"><a href="#Last-Modified-amp-If-Modified-Since-amp-Etag-amp-If-None-Match" class="headerlink" title="Last-Modified &amp; If-Modified-Since &amp; Etag &amp; If-None-Match"></a><code>Last-Modified &amp; If-Modified-Since</code> &amp; <code>Etag &amp; If-None-Match</code></h3><ul><li><em>Last-Modidied &amp; If-Modified-Since</em>:<ul><li><code>Last-Modified</code>: 为实体首部字段，值为资源最后更新时间，随服务器response返回.</li><li><code>If-Modified-Since</code>: 为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间.</li></ul></li><li><em>Etag &amp; If-None-Match</em>:<ul><li><code>Etag</code>: 为相应头部字段，表示资源内容的唯一标识，随服务器response返回.</li><li><code>If-None-Match</code>: 为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag.</li></ul></li><li><strong>不能缓存的请求</strong><ol><li>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求. <strong>Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存.实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性</strong></li><li>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</li><li>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）</li><li>POST请求无法被缓存</li><li>HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</li></ol></li><li><strong>浏览器缓存机制示意图</strong><br><img src="../images/浏览器缓存机制.png" alt="浏览器缓存机制"></li></ul>]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="日常吐槽"><a href="#日常吐槽" class="headerlink" title="日常吐槽"></a>日常吐槽</h2><p>平时的项目中，很少会用到数据结构与算法的相关知识。作为学习进阶的一个环节，最终还是把数据结构与算法提上了日程。突然有种感觉，这次的学习可能是这一辈子最深入的一次吧😌</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： List：列表是一组有序的数据。</span></span><br><span class="line"><span class="comment"> * 列表中的数据项称为元素，元素可以是任意数据类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 当前元素位置；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 列表元素容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从列表中查找某个元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待查找的元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>元素位置；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  find(element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.indexOf(element);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 向列表中插入某个元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待插入的元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*=&#125;</span> </span>pre 待插入位置的前一元素，可选；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  insert(element, prev) &#123;</span><br><span class="line">    <span class="keyword">let</span> prevAt = <span class="keyword">this</span>.find(prev);</span><br><span class="line">    <span class="keyword">if</span> (prevAt &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.splice(prevAt, <span class="number">0</span>, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.push(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从列表中删除某个元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待删除的元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> elementAt = <span class="keyword">this</span>.find(element);</span><br><span class="line">    <span class="keyword">if</span> (elementAt &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.splice(elementAt, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空列表；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 第一个元素位置；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">this</span>.position = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 最后一个元素位置；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  end() &#123;</span><br><span class="line">    <span class="keyword">this</span>.position = <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 前一个元素位置；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  prev() &#123;</span><br><span class="line">    --<span class="keyword">this</span>.position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 后一个元素位置；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.position &lt; <span class="keyword">this</span>.dataStore.length) &#123;</span><br><span class="line">      ++<span class="keyword">this</span>.position;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将元素移到某个位置；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;number&#125;</span> </span>positon 位置索引；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  moveTo(position) &#123;</span><br><span class="line">    <span class="keyword">this</span>.position = position;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *当前元素是否存在前一个元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>是否存在；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  hasNext() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.position &lt; <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当前元素是否存在下一个元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>是否存在；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  hasPrev() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.position &gt;= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取当前元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>当前元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  getElement() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.position]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取当前列表元素数；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>当前列表长度；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  length() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> List();</span><br><span class="line">names.insert(<span class="string">'a'</span>);</span><br><span class="line">names.insert(<span class="string">'b'</span>);</span><br><span class="line">names.insert(<span class="string">'c'</span>);</span><br><span class="line">names.insert(<span class="string">'d'</span>);</span><br><span class="line">names.front();</span><br><span class="line">names.next();</span><br><span class="line">names.next();</span><br><span class="line">names.prev();</span><br><span class="line">names.hasNext();</span><br><span class="line">names.moveTo(<span class="number">0</span>);</span><br><span class="line">names.remove(<span class="string">'c'</span>);</span><br><span class="line"><span class="keyword">for</span> (names.front(); names.hasNext(); names.next()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(names.getElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： Stack：栈内的元素只能通过列表的一端访问，这一端称为栈顶。</span></span><br><span class="line"><span class="comment"> * 栈被称为一种后入先出的数据结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 栈元素容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查看栈顶元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>栈顶元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">let</span> topAt = <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[topAt];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将元素压入栈；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待压入栈的元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  push(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将元素弹出栈；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待弹出栈的元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>弹出栈的元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空栈；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取当前栈元素数；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>当前栈长度；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  length() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> Stack();</span><br><span class="line">names.push(<span class="string">'a'</span>);</span><br><span class="line">names.push(<span class="string">'b'</span>);</span><br><span class="line">names.push(<span class="string">'c'</span>);</span><br><span class="line">names.peek();</span><br><span class="line">names.clear();</span><br><span class="line">names.length();</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： Queue: 队列只能在队尾插入元素，队首删除元素。</span></span><br><span class="line"><span class="comment"> * 队列是一种先进先出的数据结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 队列元素容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查看队首元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>队首元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  head() &#123;</span><br><span class="line">    <span class="keyword">let</span> headAt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[headAt];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查看队尾元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>队尾元素；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  end() &#123;</span><br><span class="line">    <span class="keyword">let</span> endAt = <span class="keyword">this</span>.dataStore.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[endAt];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 入队；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  enqueue(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 出队；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  dequeue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.shift();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空队列；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取当前队列元素数；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>当前队列长度；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  length() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> Queue();</span><br><span class="line">names.enqueue(<span class="string">'a'</span>);</span><br><span class="line">names.enqueue(<span class="string">'b'</span>);</span><br><span class="line">names.enqueue(<span class="string">'c'</span>);</span><br><span class="line">names.head();</span><br><span class="line">names.end();</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： 链表节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="comment">/** 保存节点数据；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 保存指向下一个节点；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;null&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： LinkList: 链表是由一组节点组成的集合。</span></span><br><span class="line"><span class="comment"> * 每个节点使用一个对象的引用指向下一个节点。</span></span><br><span class="line"><span class="comment"> * 指向另一个节点的引用叫做链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 头节点；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Objec&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找节点；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; element 节点元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Objec&#125;</span> </span>节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  find(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.element != element) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找链表最后一个节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Objec&#125;</span> </span>节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  findLast() &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 插入节点；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; element 待插入节点元素；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; prevElement 上一个节点元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Objec&#125;</span> </span>节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  insert(element, prevElement) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.find(prevElement) || <span class="keyword">this</span>.findLast();</span><br><span class="line">    currentNode.next = prevNode.next;</span><br><span class="line">    prevNode.next = currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找上一个节点；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; element 当前节点元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Objec&#125;</span> </span>节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  findPrev(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next &amp;&amp; currentNode.next.element != element) &#123;</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除节点；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; element 节点元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.findPrev(element);</span><br><span class="line">    <span class="keyword">if</span> (prevNode.next) &#123;</span><br><span class="line">      prevNode.next = prevNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 展示链表；</span></span><br><span class="line"><span class="comment">  * params &#123;*&#125; element 当前节点元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentNode.next.element);</span><br><span class="line">      currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> LinkList();</span><br><span class="line">names.insert(<span class="string">'a'</span>);</span><br><span class="line">names.insert(<span class="string">'b'</span>);</span><br><span class="line">names.insert(<span class="string">'c'</span>);</span><br><span class="line">names.remove(<span class="string">'b'</span>);</span><br><span class="line">names.display();</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： Dictionary: 字典是一种以键-值对形式存储数据的数据结构。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 字典容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 向字典中添加键值对；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 字典的健；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>value 字典的值；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  add(key, value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找字典中元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 待查找的健；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>代查找的值；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  find(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除字典中元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 待删除的健；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(key) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.dataStore[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清空字典中元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.dataStore).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.dataStore[key];</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 展示字典中元素；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.dataStore).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;<span class="keyword">this</span>.dataStore[key]&#125;</span>`</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> Dictionary();</span><br><span class="line">names.add(<span class="string">'a'</span>, <span class="string">'1'</span>);</span><br><span class="line">names.add(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line">names.add(<span class="string">'c'</span>, <span class="string">'3'</span>);</span><br><span class="line">names.remove(<span class="string">'b'</span>);</span><br><span class="line">names.display();</span><br></pre></td></tr></table></figure><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： HashTable: 通过散列函数尽量将键均匀地映射到数组中。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 散列表容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 散列算法；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>str 待转换的字符，使用除留余数法；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>转换后的值；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  hashFunc(str) &#123;</span><br><span class="line">    <span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      total += H * total + str.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    total</span><br><span class="line">    total = total % <span class="keyword">this</span>.table.length;</span><br><span class="line">    <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      total += <span class="keyword">this</span>.table.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(total);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将数据存入散列表；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 待存入数据的键；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>data 待存入的数据；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  put(key, data) &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="keyword">this</span>.hashFunc(key);</span><br><span class="line">    <span class="keyword">this</span>.table[position] = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取对应键的值；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 待取数据的键；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;number&#125;</span> </span>对应键的值；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="keyword">this</span>.hashFunc(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.table[position];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除对应键的值；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;string&#125;</span> </span>key 待删除数据的键；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(key) &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="keyword">this</span>.hashFunc(key);</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.table[position]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 展示散列表；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="keyword">this</span>.table.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item, index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止碰撞常用方法。碰撞：将两个键映射成同一个值的现象。</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 开链法；将数组元素展开为二维数组。</span></span><br><span class="line"><span class="comment">    buildChains() &#123;</span></span><br><span class="line"><span class="comment">      for (let i = 0; i &lt; this.table.length; i++) &#123;</span></span><br><span class="line"><span class="comment">        this.table[i] = new Array();</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    put(key, data) &#123;</span></span><br><span class="line"><span class="comment">      let position = this.hashFunc(key);</span></span><br><span class="line"><span class="comment">      let index = 0;</span></span><br><span class="line"><span class="comment">      while (this.table[position][index] != undefined) &#123;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      this.table[position][index] = key;</span></span><br><span class="line"><span class="comment">      this.table[position][index + 1] = data;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    get(key) &#123;</span></span><br><span class="line"><span class="comment">      let position = this.hashFunc(key);</span></span><br><span class="line"><span class="comment">      let index = 0;</span></span><br><span class="line"><span class="comment">      while (this.table[position][index] != key) &#123;</span></span><br><span class="line"><span class="comment">        if (index &gt; this.table[position].length) return;</span></span><br><span class="line"><span class="comment">        index++;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      return this.table[position][index + 1];</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 线性探测法；在附近的空位塞入数据。</span></span><br><span class="line"><span class="comment">    values = [];</span></span><br><span class="line"><span class="comment">    put(key, data) &#123;</span></span><br><span class="line"><span class="comment">      let position = this.hashFunc(key);</span></span><br><span class="line"><span class="comment">      while (this.table[position] != undefined) &#123;</span></span><br><span class="line"><span class="comment">        position++;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      this.table[position] = key;</span></span><br><span class="line"><span class="comment">      this.values[position] = data</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    get(key) &#123;</span></span><br><span class="line"><span class="comment">      let position = this.hashFunc(key);</span></span><br><span class="line"><span class="comment">      while (this.table[position] != key) &#123;</span></span><br><span class="line"><span class="comment">        if (position &gt; this.table.length) return;</span></span><br><span class="line"><span class="comment">        position++;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      return this.values[position]</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> HashTable();</span><br><span class="line">names.put(<span class="string">'a'</span>, <span class="number">1</span>);</span><br><span class="line">names.put(<span class="string">'b'</span>, <span class="number">4</span>);</span><br><span class="line">names.put(<span class="string">'c'</span>, <span class="number">112</span>);</span><br><span class="line">names.put(<span class="string">'d'</span>, <span class="number">112</span>);</span><br><span class="line">names.remove(<span class="string">'b'</span>);</span><br><span class="line">names.display()</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： Set: 集合是由一组无序但彼此之间又有一定相关性的成员构成，每个成员在集合中只能出现一次。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 集合容器；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 添加成员；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待添加的成员；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>添加成功返回真否则返回假；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  add(element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.dataStore.includes(element)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.push(element);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除成员；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>element 待删除的成员；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>删除成功返回真否则返回假；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> position = <span class="keyword">this</span>.dataStore.indexOf(element);</span><br><span class="line">    <span class="keyword">if</span> (~position) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dataStore.splice(position, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 与其它集合的并集；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Set&#125;</span> </span>set 待合并的集合；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Set&#125;</span> </span>合并后的集合；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  union(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">this</span>.dataStore.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      tempSet.add(element);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">set</span>.dataStore.forEach(element =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!tempSet.dataStore.includes(element)) &#123;</span><br><span class="line">        tempSet.add(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 交集；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Set&#125;</span> </span>set 其它集合；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Set&#125;</span> </span>两集合共同存在成员组成的集合；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  intersect(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">this</span>.dataStore.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">set</span>.dataStore.includes(element)) &#123;</span><br><span class="line">        tempSet.add(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 补集</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Set&#125;</span> </span>set 其它集合；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Set&#125;</span> </span>属于该集合而不属于其它集合的成员组成的集合；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  difference(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> tempSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">this</span>.dataStore.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">set</span>.dataStore.includes(element)) &#123;</span><br><span class="line">        tempSet.add(element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> tempSet;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是其它集合子集；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Set&#125;</span> </span>set 其它集合；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>是其它集合子集返回真否则返回假；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  subset(<span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore.length &gt; <span class="keyword">set</span>.dataStore.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> !<span class="keyword">this</span>.dataStore.find(<span class="function"><span class="params">element</span> =&gt;</span> <span class="keyword">set</span>.dataStore.includes(element))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line"> * 展示散列表；</span><br><span class="line"> **/</span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.forEach(<span class="function">(<span class="params">element, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (element) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(element, index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">names.add(<span class="string">'a'</span>);</span><br><span class="line">names.add(<span class="string">'b'</span>);</span><br><span class="line">names.add(<span class="string">'c'</span>);</span><br><span class="line">names.remove(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">let</span> names_1 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">names_1.add(<span class="string">'a'</span>);</span><br><span class="line">names_1.add(<span class="string">'e'</span>);</span><br><span class="line">names.subset(names_1)</span><br></pre></td></tr></table></figure><h3 id="二叉树和二叉查找树"><a href="#二叉树和二叉查找树" class="headerlink" title="二叉树和二叉查找树"></a>二叉树和二叉查找树</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： 树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data, left, right) &#123;</span><br><span class="line">    <span class="comment">/** 节点保存的数据；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;*&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 左节点；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.left = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 右节点；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述：树是一种非线性的数据结构，以分层的方式存储数据。</span></span><br><span class="line"><span class="comment"> * 树由一组以边连接的节点组成。</span></span><br><span class="line"><span class="comment"> * 从一个节点到另一个节点的这一组边称为路径，以某种特定顺序访问树中所有的节点成为树的遍历。</span></span><br><span class="line"><span class="comment"> * 二叉树子节点不超过两个。</span></span><br><span class="line"><span class="comment"> * BST： 二叉查找树是一种特殊的二叉树，相对小的值保存在左节点中，较大的值保存在右节点中。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/** 根节点；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Node&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 向树中插入新节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>data 插入的数据；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  insert(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="keyword">new</span> Node(data, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.root = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">      <span class="keyword">let</span> parent;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line">        <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">          current = current.left;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.left = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          current = current.right;</span><br><span class="line">          <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">            parent.right = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 中序遍历；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Node&#125;</span> </span>node 遍历的根节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  inOrder(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      <span class="keyword">this</span>.inOrder(node.left);</span><br><span class="line">      <span class="built_in">console</span>.log(node.data);</span><br><span class="line">      <span class="keyword">this</span>.inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 先序遍历；</span></span><br><span class="line"><span class="comment">     preOrder(node) &#123;</span></span><br><span class="line"><span class="comment">      if (node) &#123;</span></span><br><span class="line"><span class="comment">        console.log(node.data);</span></span><br><span class="line"><span class="comment">        this.preOrder(node.left);</span></span><br><span class="line"><span class="comment">        this.preOrder(node.right);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // 后序遍历；</span></span><br><span class="line"><span class="comment">    postOrder(node) &#123;</span></span><br><span class="line"><span class="comment">      if (node) &#123;</span></span><br><span class="line"><span class="comment">        this.postOrder(node.left);</span></span><br><span class="line"><span class="comment">        this.postOrder(node.right);</span></span><br><span class="line"><span class="comment">        console.log(node.data);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取最小值节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Node&#125;</span> </span>node 待查找的节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Node&#125;</span> </span>拥有最小值的节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  getMin(node) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node || <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (current.left) &#123;</span><br><span class="line">      current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取最大值节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;Node&#125;</span> </span>node 待查找的节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Node&#125;</span> </span>拥有最大值的节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  getMax(node) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = node || <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (current.right) &#123;</span><br><span class="line">      current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 查找指定数据的节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>data 待查找的数据；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return <span class="type">&#123;Node&#125;</span> </span>拥有指定数据的节点；</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  find(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current.data == data) &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除指定数据的节点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;*&#125;</span> </span>data 待删除的数据；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  remove(data) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.root = removeNode(<span class="keyword">this</span>.root, data);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">node, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (data == node.data) &#123;</span><br><span class="line">        <span class="comment">// 没有子节点；</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有右节点；</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有左节点；</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有左、右子节点；</span></span><br><span class="line">        <span class="keyword">let</span> tempNode = self.getMin(node.right);</span><br><span class="line">        node.data = tempNode.data;</span><br><span class="line">        node.right = removeNode(node.right, tempNode.data);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 或者左节点最大值；</span></span><br><span class="line"><span class="comment">        let tempNode = self.getMax(node.left);</span></span><br><span class="line"><span class="comment">        node.data = tempNode.data;</span></span><br><span class="line"><span class="comment">        node.left = removeNode(node.left, tempNode.data); */</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; node.data) &#123;</span><br><span class="line">        node.left = removeNode(node.left, data);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = removeNode(node.right, data);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> BST();</span><br><span class="line">names.insert(<span class="number">12</span>);</span><br><span class="line">names.insert(<span class="number">6</span>);</span><br><span class="line">names.insert(<span class="number">18</span>);</span><br><span class="line">names.insert(<span class="number">3</span>);</span><br><span class="line">names.insert(<span class="number">9</span>);</span><br><span class="line">names.insert(<span class="number">15</span>);</span><br><span class="line">names.insert(<span class="number">21</span>);</span><br><span class="line">names.inOrder(names.root);</span><br><span class="line">names.remove(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="图和图算法"><a href="#图和图算法" class="headerlink" title="图和图算法"></a>图和图算法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  描述： Graph: 图由边的集合及顶点的集合组成。</span></span><br><span class="line"><span class="comment"> * 邻接表或邻接表数组：将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(v) &#123;</span><br><span class="line">    <span class="comment">/** 顶点数；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.vertices = v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 边数；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.edges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 邻接表数组；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.adj = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: v &#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> ([]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 顶点访问状态；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type <span class="type">&#123;Array&#125;</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="keyword">this</span>.marked = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: v &#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> (<span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 添加顶点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;&#125;</span> </span>v 顶点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;&#125;</span> </span>w 顶点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  addEdge(v, w) &#123;</span><br><span class="line">    <span class="keyword">this</span>.adj[v].push(w);</span><br><span class="line">    <span class="keyword">this</span>.adj[w].push(v);</span><br><span class="line">    <span class="keyword">this</span>.edges++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 深度优先搜索；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;&#125;</span> </span>v 顶点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  dfs(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 打印遍历路径；</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.adj[v] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'visted:'</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> vertex <span class="keyword">of</span> <span class="keyword">this</span>.adj[v]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[vertex]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dfs(vertex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 广度优先搜索；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@params <span class="type">&#123;&#125;</span> </span>v 顶点；</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@protected</span></span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  bfs(v) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [];</span><br><span class="line">    <span class="keyword">this</span>.marked[v] = <span class="literal">true</span>;</span><br><span class="line">    queue.push(v);</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = queue.shift();</span><br><span class="line">      <span class="comment">// 打印遍历路径；</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.adj[v] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'visted:'</span>, v);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> vertex <span class="keyword">of</span> <span class="keyword">this</span>.adj[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.marked[vertex]) &#123;</span><br><span class="line">          <span class="keyword">this</span>.marked[vertex] = <span class="literal">true</span>;</span><br><span class="line">          queue.push(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="keyword">new</span> Graph(<span class="number">5</span>);</span><br><span class="line">names.addEdge(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">names.addEdge(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">names.addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">names.addEdge(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// names.dfs(0);</span></span><br><span class="line">names.bfs(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝webpack</title>
    <url>/%E6%B5%85%E5%B0%9Dwebpack/</url>
    <content><![CDATA[<h2 id="吐槽一下"><a href="#吐槽一下" class="headerlink" title="吐槽一下"></a>吐槽一下</h2><p>webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。</p><p>纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中文版的官方文档，通俗易懂，很感谢翻译组的辛勤奉献。看完之后，虽然达不到炉火纯青的地步，但也不会捉襟见肘，疲于应付。</p><p>对于这种工具类的博文，依然沿袭 <a href="http://www.yexiaochen.com/%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript/">用Type驯化JavaScript</a> 的风格，串联各个概念。至于细节，就是官方文档的事了。</p><p>本文基于 <strong><em>webpack v4.31.0 </em></strong>版本。</p><h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><blockquote><p>Tapable 是一个小型的库，允许你对一个 javascript 模块添加和应用插件。它可以被继承或混入到其他模块中。类似于 NodeJS 的 EventEmitter 类，专注于自定义事件的触发和处理。除此之外，Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)”。</p></blockquote><p>tapable 是 webpack 的核心，webpack 中的很多对象（compile， compilation等）都扩展自tapable，包括 webpack 也是 tapable 的实例。扩展自 tapable 的对象内部会有很多钩子，它们贯穿了 webpack 构建的整个过程。我们可以利用这些钩子，在其被触发时，做一些我们想做的事情。</p><p>抛开 webpack 不谈，先看看 tapable 的简单使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  SyncHook</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">"tapable"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">      init: <span class="keyword">new</span> SyncHook([<span class="string">'init'</span>])</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.plugins = options.plugins;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">this</span>.beforeInit();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">        plugin.apply(<span class="keyword">this</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hooks.init.call(<span class="string">'初始化中。。。'</span>);</span><br><span class="line">    <span class="keyword">this</span>.afterInit();</span><br><span class="line">  &#125;</span><br><span class="line">  beforeInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'初始化前。。。'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  afterInit() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'初始化后。。。'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Main;</span><br><span class="line"><span class="comment">// MyPlugin.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> </span>&#123;</span><br><span class="line">  apply(main) &#123;</span><br><span class="line">    main.hooks.init.tap(<span class="string">'MyPlugin'</span>, param =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'init 钩子，做些啥；'</span>, param);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> Main = <span class="built_in">require</span>(<span class="string">'./Main'</span>);</span><br><span class="line"><span class="keyword">const</span> MyPlugin = <span class="built_in">require</span>(<span class="string">'./MyPlugin'</span>);</span><br><span class="line"><span class="keyword">let</span> myPlugin = <span class="keyword">new</span> MyPlugin();</span><br><span class="line"><span class="keyword">new</span> Main(&#123; <span class="attr">plugins</span>: [myPlugin] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化前。。。</span></span><br><span class="line"><span class="comment">// init 钩子，做些啥; 初始化中。。。</span></span><br><span class="line"><span class="comment">// 初始化后。。。</span></span><br></pre></td></tr></table></figure><p>理解起来很简单，就是在 <code>init</code> 处触发钩子，<code>this.hooks.init.call(params)</code> 类似于我们熟悉的 <code>EventEmitter.emit(&#39;init&#39;, params)</code>。<code>main.hooks.init.tap</code> 类似于 <code>EventEmitter.on(&#39;init&#39;, callback)</code>，在 <code>init</code>钩子上绑定一些我们想做的事情。在后面将要说的 webpack 自定义插件，就是在 webpack 中的某个钩子处，插入自定义的事。</p><h2 id="理清概念"><a href="#理清概念" class="headerlink" title="理清概念"></a>理清概念</h2><ul><li><strong>依赖图</strong><br>在单页面应用中，只要有一个入口文件，就可以把散落在项目下的各个文件整合到一起。何谓依赖，当前文件需要什么，什么就是当前文件的依赖。依赖引入的形式有如下：<ul><li>ES2015 <code>import</code> 语句</li><li>CommonJS <code>require()</code> 语句</li><li>AMD <code>define</code> 和 <code>require</code> 语句</li><li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接</li></ul></li></ul><ul><li><p><strong>入口(entry)</strong><br>入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始。</p></li><li><p><strong>输出(output)</strong><br>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</p></li><li><p><strong>模块(module)</strong><br>决定了如何处理项目中的不同类型的模块。比如设置 loader，处理各种模块。设置 noParse，忽略无需 webpack 解析的模块。</p></li><li><p><strong>解析(resolve)</strong><br>设置模块如何被解析。引用依赖时，需要知道依赖间的路径关系，应遵循何种解析规则。比如给路径设置别名（alias），解析模块的搜索目录（modules），解析 loader 包路径（resolveLoader）等。</p></li><li><p><strong>外部扩展(externals)</strong><br>防止将某些 import 的包（package）打包到 bundle 中，而是在运行时（runtime）再去从外部获取这些扩展依赖。比如说，项目中引用了 jQuery 的CDN资源，在使用 <code>import $ from &#39;jquery&#39;;</code>时，webpack 会把 jQuery 打包进 bundle，其实这是没有必要的，此时需要配置 <code>externals: {jquery: &#39;jQuery&#39;}</code>，将其剔除 bundle。</p></li><li><p><strong>插件(plugins)</strong><br>用于以各种方式自定义 webpack 构建过程。可以利用 webpack 中的钩子，做些优化或者搞些小动作。</p></li><li><p><strong>开发设置(devServer)</strong><br>顾名思义，就是开发时用到的选项。比如，开发服务根路径（contentBase），模块热替换（hot，需配合 <code>HotModuleReplacementPlugin</code> 使用），代理（proxy）等。</p></li><li><p><strong>模式(mode)</strong><br>提供 mode 配置选项，告知 webpack 使用相应环境的内置优化。具体可见 <a href="https://webpack.docschina.org/concepts/mode/" rel="external nofollow noopener noreferrer" target="_blank">模式(mode)</a></p></li><li><p><strong>优化(optimization)</strong><br>从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化，不过所有的优化还是可以手动配置和重写。比如，<code>CommonsChunkPlugin</code>被 <code>optimization.splitChunks</code> 取代。</p></li></ul><p>webpack 差不多就是这几个配置项，搞清楚这几个概念，上手还是比较容易的。</p><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p>现在的前端项目越来越复杂，如果最终导出为一个 bundle，会极大地影响加载速度。切割 bundle，控制资源加载优先级，按需加载或并行加载，合理应用就会大大缩短加载时间。官方文档提供了三种常见的代码分离方法：</p><ul><li><p><strong>入口起点</strong><br>配置多个入口文件，然后将最终生成的过个 bundle 出入到 HTML 中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    vendor: <span class="string">'./src/vendor.js'</span></span><br><span class="line">&#125;</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    chunks: [<span class="string">'vendor'</span>, <span class="string">'index'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>不过如果这两个文件中存在相同的模块，这就意味着相同的模块被加载了两次。此时，我们就需要提取出重复的模块。</p></li><li><p><strong>防止重复</strong><br>在 webpack 老的版本中，<code>CommonsChunkPlugin</code> 常用来提取公共的模块。新版本中 <code>SplitChunksPlugin</code> 取而代之，可以通过 <code>optimization.splitChunks</code> 设置，多见于多页面应用。</p></li><li><p><strong>动态导入</strong><br>就是在需要时再去加载模块，而不是一股脑的全部加载。webpack 还提供了预取和预加载的方式。非入口 chunk，我们可以通过 chunkFilename 为其命名。常见的如，vue 路由动态导入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">output: &#123;</span><br><span class="line">  chunkFilename: <span class="string">'[name].bundle.js'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "someJs" */</span> <span class="string">'someJs'</span>);</span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">'someJs'</span>);</span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPreload: true */</span> <span class="string">'someJs'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>基于浏览器的缓存策略，我们知道如果本地缓存命中，则无需再次请求资源。对于改动不频繁或基本不会再做改动的模块，可以剥离出来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们的想法，只要模块的内容没有变化，对应的名字也就不会发生变化，这样缓存就会起作用了。事实上并非如此，webpack 打包后的文件，并非只有用户自己的代码，还包括管理用户代码的代码，如 runtime 和 manifest。</p><p>模块依赖间的整合并不是简单的代码拼接，其中包括模块的加载和解析逻辑。注入的 runtime 和 manifest 在每次构建后都会发生变化。这就导致了即使用户代码没有变化，某些 hash 还是发生了改变。通过 <code>optimization.runtimeChunk</code> 提取 runtime 代码。通过 <code>optimization.splitChunks</code> 剥离第三方库。比如， react，react-dom。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: <span class="string">'single'</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom)[\\/]/</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          chunks: <span class="string">'all'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后使用 <code>HashedModuleIdsPlugin</code> 来消除因模块 ID 变动带来的影响。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loader API;</span></span><br><span class="line"><span class="keyword">this</span>.callback(</span><br><span class="line">  err: <span class="built_in">Error</span> | <span class="literal">null</span>,</span><br><span class="line">  content: string | Buffer,</span><br><span class="line">  sourceMap?: SourceMap,</span><br><span class="line">  meta?: any</span><br><span class="line">);</span><br><span class="line"><span class="comment">// sync loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, syncOperation(content, map, meta));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// async loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  asyncOperation(content, (error, result) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error) callback(error);</span><br><span class="line">    callback(<span class="literal">null</span>, result, map, meta);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 loader 串行时，在从右向左执行 loader 之前，会向从左到右调用 loader 上的 pitch 方法。如果在 pitch 中返回了结果，则会跳过后续 loader。</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|- a-loader <span class="code">`pitch`</span></span><br><span class="line">  |- b-loader <span class="code">`pitch`</span></span><br><span class="line"><span class="code">    |- c-loader `pitch`</span></span><br><span class="line"><span class="code">      |- requested module is picked up as a dependency</span></span><br><span class="line"><span class="code">    |- c-loader normal execution</span></span><br><span class="line">  |- b-loader normal execution</span><br><span class="line">|- a-loader normal execution</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- pitch 中返回结果 --&gt;</span></span></span><br><span class="line"></span><br><span class="line">|- a-loader <span class="code">`pitch`</span></span><br><span class="line">  |- b-loader <span class="code">`pitch`</span> returns a module</span><br><span class="line">|- a-loader normal execution</span><br></pre></td></tr></table></figure><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>webpack 的自定义插件和本文开头 Tapable 中的差不多。webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。钩子有同步的，也有异步的，这需要根据 webpack 提供的 API 文档。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileListPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步)</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'FileListPlugin'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 在生成文件中，创建一个头部字符串：</span></span><br><span class="line">      <span class="keyword">var</span> filelist = <span class="string">'In this build:\n\n'</span>;</span><br><span class="line">      <span class="comment">// 遍历所有编译过的资源文件，</span></span><br><span class="line">      <span class="comment">// 对于每个文件名称，都添加一行内容。</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> filename <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        filelist += <span class="string">'- '</span> + filename + <span class="string">'\n'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将这个列表作为一个新的文件资源，插入到 webpack 构建中：</span></span><br><span class="line">      compilation.assets[<span class="string">'filelist.md'</span>] = &#123;</span><br><span class="line">        source: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> filelist;</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> filelist.length;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = FileListPlugin;</span><br></pre></td></tr></table></figure><ul><li><p>ProvidePlugin<br>自动加载模块，无需处处引用。有点类似 <code>expose-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// some.js</span></span><br><span class="line">$(<span class="string">'#item'</span>);</span><br></pre></td></tr></table></figure></li><li><p>DllPlugin<br>将基础模块打包进动态链接库，当依赖的模块存在于动态链接库中时，无需再次打包，而是直接从动态链接库中获取。DLLPlugin 负责打包出动态链接库，DllReferencePlugin 负责从主要配置文件中引入 DllPlugin 插件打包好的动态链接库文件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack-dll-config.js</span></span><br><span class="line"><span class="comment">// 先执行该配置文件</span></span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">  filename: <span class="string">"MyDll.[name].js"</span>,</span><br><span class="line">  library: <span class="string">"[name]_[hash]"</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">"dist"</span>, <span class="string">"[name]-manifest.json"</span>),</span><br><span class="line">    name: <span class="string">"[name]_[hash]"</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// webpack-config.js</span></span><br><span class="line"><span class="comment">// 后执行该配置文件</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">    manifest: <span class="built_in">require</span>(<span class="string">"../dll/dist/alpha-manifest.json"</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>HappyPack<br>启动子进程处理任务，充分利用资源。不过进程间的通讯比较耗资源，要酌情处理。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="comment">// loader</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">  exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// plugins</span></span><br><span class="line"><span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">  id: <span class="string">'babel'</span>,</span><br><span class="line">  loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>webpack-bundle-analyzer<br>webpack 打包后的分析工具。</p></li></ul><p>webpack 告一段落，浅尝辄止。</p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>用DevTools提高你的工作效率</title>
    <url>/%E7%94%A8DevTools%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<blockquote><p>Chrome DevTools 调试使用 <a href="https://github.com/yexiaochen/DevTools" rel="external nofollow noopener noreferrer" target="_blank">demo地址</a></p></blockquote><p>作为前端开发者，免不了要和 DevTools 打交道,熟练的使用 DevTools 能够大大提高我们的工作效率。然而，开发者工具的使用并没有得到足够的重视。</p><p>工欲善其事必先利其器，更何况，工具的学习成本比专业技能的学习成本小的多。</p><p>Chrome 有不同版本，如果想第一时间体验一些新的功能可以使用除稳定版本的其它版本。<br><img src="../images/Chrome.png" alt="Chrome"></p><p>本次主要围绕着 Workspace 和 Blackbox script 这两点来感受它们带来的便利。</p><h2 id="Workspace"><a href="#Workspace" class="headerlink" title="Workspace"></a>Workspace</h2><p>Workspace 主要还是将浏览器关联本地文件，使得浏览器拥有读写本地文件的权利。</p><p>随着前端的发展，业务和逻辑也越来越复杂。还好打包压缩工具应运而生，还有 sourceMap 的使用，又让我们从压缩混淆的代码中有了看源码的体验。</p><p>此时我们依然可以 DevTools 里 <code>Sources</code> 页签里的 <code>Filesystem</code> 页签添加本地文件夹，从浏览器里修改本地文件。</p><p><img src="../images/Filesystem.gif" alt="Filesystem"></p><p>这个功能或许还有点用，但是还是不如人意。因为修改后的文件需要刷新后才能显示变动，而文件被更改后，打包工具需要重新编译，编译时间或许很长或许很短，而且页面被被整体刷新了，给人一种很生硬的感觉。</p><p>不过，还好有 <code>热组件替换</code> 这么一说。给我们的应用程序加上这货之后，我们的开发将会更加丝滑😉。</p><h2 id="热组件替换"><a href="#热组件替换" class="headerlink" title="热组件替换"></a>热组件替换</h2><p>以 <code>create-react-app</code> 为例🌰（最新版本），步骤如下。也可以看看👀官方怎么说<a href="https://github.com/gaearon/react-hot-loader/blob/master/docs/Troubleshooting.md" rel="external nofollow noopener noreferrer" target="_blank">react-hot-loader</a>.<br>1⃣️：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react-hot-loader --save-dev</span><br></pre></td></tr></table></figure><p>2⃣️：在 <code>entry</code> 中添加 <code>isEnvDevelopment &amp;&amp; &#39;react-hot-loader/patch&#39;,</code><br>3⃣️：在 oneOf 中 <code>babel-loader</code> 的 plugins 中添加 <code>[&#39;react-hot-loader/babel&#39;],</code><br>4⃣️：在入口文件添加以下内容</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">const</span> render = <span class="function">(<span class="params">Component</span>) =&gt;</span> &#123;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;AppContainer&gt;</span><br><span class="line">        &lt;Component /&gt;</span><br><span class="line">        &lt;<span class="regexp">/AppContainer&gt;,</span></span><br><span class="line"><span class="regexp">        root</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">render(App)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">if (module.hot) &#123;</span></span><br><span class="line"><span class="regexp">    module.hot.accept('./</span>App<span class="string">', () =&gt; &#123;</span></span><br><span class="line"><span class="string">        const NextApp = require('</span>./App<span class="string">').default</span></span><br><span class="line"><span class="string">        render(NextApp)</span></span><br><span class="line"><span class="string">    &#125;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>至此，热组件替换改造完成，让我们再次感受下。</p><p><img src="../images/HMR.gif" alt="HMR"></p><p>通过以上展示，我们可以发现，整个界面只是局部被替换了，过渡得很自然。这应该才是我们想要的效果✨。插一句，在 <code>Network</code> 页签中，Preserve log 一定要勾选上☑️。这样的话，即使页面刷新了，也是有记录📝的，非常方便在页面跳转刷新时使用。</p><h2 id="Blackbox-script"><a href="#Blackbox-script" class="headerlink" title="Blackbox script"></a>Blackbox script</h2><p>如果说以上是提高了开发上的效率，那么这个 <code>Blackbox script</code> 功能将会在定位上省下不少时间。</p><p>在断点排查问题时，代码总会在不同的位置切换。但是，经常会遇到各种不是我们程序里的代码跳出来。不过，只要我们把该文件标记为 <code>Blackbox script</code> 时，下次就不会再出现了。当然这只是最基本的操作，要想充分利用这个功能，还是要配合其它功能的使用。</p><h3 id="Call-Stack"><a href="#Call-Stack" class="headerlink" title="Call Stack"></a>Call Stack</h3><p>调用栈在排查问题是很有用的，我们知道，函数的执行是有执行上下文的，函数由最外层到最内层依次压入栈中，在执行的时候，依次从栈中弹出。这样我们就可以从最内层沿着链找到最外层。</p><p>排查错误时也是这个道理，我们经常遇到不知名的错误❌，可能是调用第三方的，也可能是底层，总之不是我们写的代码（我信你个鬼😏）。</p><p>遇到这种情况就可以尝试用调用栈的方法，既然执行了，肯定是有调用的地方，我们可以沿着链去找源头（十有八九是我们自己写的代码😏）。不过调用栈中可能混杂了不是我们自己写的函数，这时候 <code>Blackbox script</code> 就派上用场了。</p><p><img src="../images/callStack.gif" alt="callStack"></p><h3 id="Event-Listener-Breakpoints"><a href="#Event-Listener-Breakpoints" class="headerlink" title="Event Listener Breakpoints"></a>Event Listener Breakpoints</h3><p>可能在熟悉一个新的项目时，想知道某个 dom 绑定的处理事件。<code>Sources</code> 页签下的 <code>Event Listener Breakpoints</code> 可以定位到代码具体的位置，不过和上次一样，好多其它代码混淆视听，我们需要把它们标记为 <code>Blackbox script</code>。标记完后，下次就会直接在自己的代码里停住了。</p><p><img src="../images/eventListener.gif" alt="eventListener"></p><h3 id="Initiator"><a href="#Initiator" class="headerlink" title="Initiator"></a>Initiator</h3><p>其实和 <code>Event Listener Breakpoints</code> 并排的 <code>XHR/fetch Breakpoints</code> 也很有用，不过和接下来要讲的功能比，就显得鸡肋了。</p><p>在 Network 页签中，记录的都是请求的数据。在开发的时候常遇到这两种情况，<br>1⃣️：接口报错，在 <code>Network</code> 页签中可以看到整个URL被标红了，要快速定位到调用接口的地方。<br>2⃣️：请求出去了，请看看响应时，如何处理数据。</p><p>其实，两个实质上都是一样，就是快速定位代码。快速定位在大型项目中还是挺麻烦的，除非业务比较熟，剩下只能全局搜索了。</p><p>还好，<code>Network</code> 页签下的 <code>Initiator</code> 也有类似调用栈的东西，我们可以在其列表中找到，<code>Blackbox script</code> 的功能依然时屏蔽无关的代码。</p><p><img src="../images/initiator.gif" alt="Initiator"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了以上还有很多调试技巧，</p><p>1⃣️：有时候我们看见了控制有错误❌输出，却不知道是哪里的问题。或者是控制有报错❌，但一闪而过，无法捕捉。这时候可以尝试使用异常断点的功能(最右➡️的那个)。倒数第二个，是用来恢复函数执行的，使断点不起作用。</p><p><img src="../images/exceptions.png" alt="exceptions"></p><p>2⃣️：数据量过大时，可能由于某一条数据的问题导致了页面渲染问题。如果打断点的话，数据量太大了，每一次都跳到循环的处理逻辑中会很麻烦。不过断点是支持条件断点的，还可以打印我们想要的变量（在最新的 Chrome dev版本中，已单独拎出来了）。</p><p><img src="../images/loop.gif" alt="loop"></p><p>3⃣️：有时候页面加载过快，都来不及看明白页面是怎么展示的。比如跳转问题，比如模拟网速慢、电脑性能卡慢问题。（这里十有八九是并发引起的竞态问题😏）右下角 Oneline 可自选模式。</p><p><img src="../images/netSpeed.png" alt="netSpeed"></p><p>4⃣️：……</p>]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title>用Type驯化JavaScript</title>
    <url>/%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript/</url>
    <content><![CDATA[<blockquote><p>TypeScript 具有类型系统，且是 JavaScript 的超集。它可以编译成普通的 JavaScript 代码。TypeScript 支持任意浏览器，任意环境，任意系统并且是开源的。</p></blockquote><p>作为弱类型、动态型语言，JavaScript 就像未驯化的野马一样。每个人都能上去坐两下，但是真正能够驾驭的只能是个中好手。<br>近几年，前端经历了快速的发展已经不再是以前随便玩玩的小玩意了。面对越来越大型、越来越持久的项目来说，这种宽松的方式反而成了阻碍。</p><blockquote><p>东西做大了，随之而来的就是各种规矩</p></blockquote><p>规矩是从经验中总结，同时也是为了朝更好的方向发展，就比如编程里的设计原则和设计模式。「Man maketh manners」，记得王牌特工里，主角们在教育别人的时候总喜欢说这么一句话，「不知礼，无以立也」。在 TypeScript 里，「礼」就是 Type，Type 就是规矩。Typescript 通过类型注解提供编译时的静态类型检查，提前发现错误，同时也提高了代码的可读性和可维护性。</p><blockquote><p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式</p></blockquote><p>在 JavaScript 里，变量用于在特定时间存储特定值，其值及数据类型可以在脚本的生命周期内改变。而在 TypeScript 中，标识符（变量、函数、类、属性的名字，或者函数参数）在其定义时就指定了类型（或类型推论出）。在编译阶段，若出现了期望之外的类型，TypeScript 将会提示抛错（虽然有时候并不会影响程序的正常运行）。</p><p>在 TypeScript 中，通过 <code>: 类型</code> 的方式为标识符添加类型注解。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span>;    <span class="comment">// boolean；</span></span><br><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span>;    <span class="comment">// number；</span></span><br><span class="line"><span class="keyword">let</span> name: string = <span class="string">"bob"</span>;    <span class="comment">// string；</span></span><br><span class="line"><span class="keyword">let</span> list: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// Array&lt;number&gt;;</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];    <span class="comment">// Array&lt;number&gt;;</span></span><br><span class="line"><span class="keyword">let</span> x: [string, number];    <span class="comment">// tuple;</span></span><br><span class="line">enum Color &#123;Red, Green, Blue&#125;    <span class="comment">// enum;</span></span><br><span class="line"><span class="keyword">let</span> notSure: any = <span class="number">4</span>;    <span class="comment">// any;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;    <span class="comment">// void;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;    <span class="comment">// undefined;</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;    <span class="comment">// null;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;    <span class="comment">// never;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj: object = &#123;&#125;;    <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在 TypeScript 中，数组（Array）是合并了相同类型的对象，而元组（tuple）合并了不同类型的对象。（<code>Array&lt;any&gt;</code>,也可以合并不同类型的数据）</p><blockquote><p>类型注解中的类型就是以上的那些类型么？</p></blockquote><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查，它有时被称做「鸭式辨型法」或「结构性子类型化」。上面的只是基础类型，它们是填充结构的基本单位而已。在 TypeScript 里，类型不应该还停留在 JavaScript 数据类型的层面上，还应包括基础类型的组合结构化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="string">'Hello'</span>;    <span class="comment">// 字符串字面量类型；</span></span><br><span class="line">str = <span class="string">'Hi'</span>    <span class="comment">// error；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> something: <span class="string">'Hello'</span> | <span class="number">1</span>;    <span class="comment">// 联合类型；</span></span><br><span class="line">something = <span class="number">1</span>    <span class="comment">// ok；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string, <span class="attr">age</span>: number&#125;;    <span class="comment">// 对象字面量</span></span><br><span class="line">obj = &#123;</span><br><span class="line">    name: <span class="string">"夜曉宸"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换句话说，在定义标识符的时候，用一个类型模板来描述标识符的结构和内部类型组成。即类型模板就是标识符期望的样子。</p><blockquote><p>代码是给人看的，顺便是给机器运行的</p></blockquote><p>都说好的代码就该这样。但是在 TypeScript 里，这两句话可以颠倒下顺序。代码是给机器运行的，顺便是给人看的。<br>在谈到 TypeScript 的好处时，有一条很重要，增强了编译器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。而这些也得益于标识符的类型的精确划分或表述，所以想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 <code>any</code>。</p><blockquote><p>表述复杂结构最常用的方式 ———— 接口</p></blockquote><p>接口是 JavaScript 中没有的东西，是一个非常灵活的概念，可以抽象行为，也可以描述「对象的形状」。<br>对于需要复用的结构类型，就可以使用接口的方式，而不是对象字面量内联式注解。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface Iperson &#123;    <span class="comment">// 对象</span></span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    sayHi(): <span class="keyword">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj: Iperson = &#123;</span><br><span class="line">    name: <span class="string">"夜曉宸"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="params">()</span>=&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————人工分割线—————— */</span></span><br><span class="line"></span><br><span class="line">interface Iperson &#123;    <span class="comment">// 函数类型</span></span><br><span class="line">    (name: string, <span class="attr">age</span>: number): string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Iperson = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span>,<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">person(<span class="string">'夜曉宸'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————人工分割线—————— */</span></span><br><span class="line"></span><br><span class="line">interface Iperson &#123;    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">new</span> (name: string, <span class="attr">age</span>: number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Iperson = <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> person(<span class="string">'夜曉宸'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————人工分割线—————— */</span></span><br><span class="line"></span><br><span class="line">interface Iperson &#123;    <span class="comment">// 类实现接口</span></span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">Iperson</span></span>&#123;</span><br><span class="line">    name = <span class="string">'夜曉宸'</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————人工分割线—————— */</span></span><br><span class="line"></span><br><span class="line">interface Iperson &#123;    <span class="comment">// 混合类型</span></span><br><span class="line">    (name, age): string,</span><br><span class="line">    age: number,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>): <span class="title">Iperson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> me = <span class="xml"><span class="tag">&lt;<span class="name">Iperson</span>&gt;</span>function (name, age): string &#123;</span></span><br><span class="line"><span class="xml">        return `$&#123;name&#125;, $&#123;age&#125;`</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    me.age = 18;</span></span><br><span class="line"><span class="xml">    return me;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">let person = Person();</span></span><br><span class="line"><span class="xml">person('夜曉宸', 18)</span></span><br><span class="line"><span class="xml">person.age</span></span><br></pre></td></tr></table></figure><p>以上是接口在对象、普通函数、构造函数、类上的表现。对于接口的属性，还可以做到精确控制，如可选属性、任意属性、只读属性等。<br>最后，接口间可以继承，接口还可以继承类。当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了，这个和类的访问修饰符的特点有关系。</p><p>说完接口，就要说说类了，因为它们有多相似的地方，比如充当对象的类型模板，继承成员等。</p><blockquote><p>类到底是什么呢？</p></blockquote><p>ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> age: number = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(public name: string, public age: number) &#123; &#125;</span><br><span class="line">    sayHi(name: string): string&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hi,<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* —————— 人工分割线 —————— */</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi,"</span> + name;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.age = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>TypeScript 编译后，可以看出来，类其实就是一个函数而已。</p><p>在 ES6 之前，通过构造函数的方式 <code>new</code> 出对象，造出的对象拥有和共享了构造函数内部绑定的属性方法及原型上的属性方法。TypeScript 里的接口描述的类类型就是类的实例部分应该遵循的类型模板。作为类的静态部分 ———— 构造函数，函数也应该有自己的属性特征。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface static_person &#123;</span><br><span class="line">    age: number,</span><br><span class="line">    <span class="keyword">new</span> (name: string, <span class="attr">age</span>: number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface instance_person &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number,</span><br><span class="line">    say(name: string): string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: static_person = <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">instance_person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> age: number = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(public name: string, public age: number) &#123; &#125;</span><br><span class="line">    say(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hi,<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> person(<span class="string">'夜曉宸'</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>由以上代码可以看出，类的静态部分和动态部分都有各自的类型模板。若是想要将类自身作为类型模板又该如何做呢？最简单的方法就是 <code>typeof 类</code> 的方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> age: number = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(public name: string, public age: number) &#123;&#125;</span><br><span class="line">    say(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hi,<span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> age: number;</span><br><span class="line">    <span class="keyword">constructor</span>(public name: string, public age: number) &#123;&#125;</span><br><span class="line">    public sex = <span class="string">'man'</span>;</span><br><span class="line">    say(name)&#123;<span class="keyword">return</span> <span class="string">`Hi, <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>,<span class="subst">$&#123;name&#125;</span>`</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> man: <span class="keyword">typeof</span> Person = Man;</span><br><span class="line"><span class="keyword">new</span> man(<span class="string">'夜曉宸'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>类静态部分、类实例部分和类自身，它们都有自己需要遵循的类型模板。知道了其中的区别，也就能更好得理解类作为接口使用、接口继承类等用法了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Man extends Person &#123;</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> man: Man = &#123;</span><br><span class="line">    name: <span class="string">'夜曉宸'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了结构上的约束，类也通过访问修饰符对其成员做了约束，包括 public，private，protected，readonly等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  private name: string;</span><br><span class="line">  protected age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SayPerson extends Person &#123;</span><br><span class="line">  sayHi(): string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">SayPerson</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi, <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了访问修饰符的特点，也就明白之前说过的「当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了」。</p><blockquote><p>如果一个标识符的类型不确定，该如何？</p></blockquote><p>对于一个内部逻辑相差不大，入參类型不同的函数来说，没必要因为参数类型不同而重复大部分代码，这时就需要一个类型变量来代替。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 范型函数 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    className = <span class="string">'person'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    classname = <span class="string">'human'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">Class: new (</span>) =&gt; <span class="title">T</span>) : <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Class();</span><br><span class="line">&#125;</span><br><span class="line">create(Person).className</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 范型接口 */</span></span><br><span class="line">interface Creat&lt;T&gt;&#123;</span><br><span class="line">    (Class: <span class="keyword">new</span> () =&gt; T):T</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    className = <span class="string">'person'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    classname = <span class="string">'human'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">Class: new (</span>) =&gt; <span class="title">T</span>) : <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Class();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Creat&lt;Person&gt; = create;</span><br><span class="line"></span><br><span class="line">person(Person)    <span class="comment">// OK</span></span><br><span class="line">person(Human)    <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>注意了，类型变量表示的是类型，而不是值。类型变量里塞的可能是任意一个类型，但根据场景，我们最好能够更加精确的描述标识符的类型。应了上面的一句话，「想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 <code>any</code>」。所以对于泛型，我们也可以做些约束，即，泛型约束。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Man extends Person &#123;</span><br><span class="line">  sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> man: Man = &#123;</span><br><span class="line">    name: <span class="string">'夜曉宸'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'man'</span></span><br><span class="line">&#125;</span><br><span class="line">getProperty(man, <span class="string">'sex'</span>)</span><br></pre></td></tr></table></figure><p>用类型变量来注释标识符的类型有时会觉得还是不够精确。</p><blockquote><p>知道标识符的可能类型，然后组合起来</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    study():string &#123;<span class="keyword">return</span> <span class="string">''</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span> </span>&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    sing():string&#123;<span class="keyword">return</span> <span class="string">''</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">Class: Man | Women</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="xml"><span class="tag">&lt;<span class="name">Man</span>&gt;</span>Class).study) &#123;</span></span><br><span class="line">        return (&lt;Man&gt;Class).study()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (&lt;Women&gt;Class).sing()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let man:Man = &#123;</span><br><span class="line">    name: '夜曉宸',</span><br><span class="line">    age: 18,</span><br><span class="line">    study() &#123;</span><br><span class="line">        return '我爱学习';</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let women: Women = &#123;</span><br><span class="line">    name: 'godness',</span><br><span class="line">    age: 17,</span><br><span class="line">    sing() &#123;</span><br><span class="line">        return '我爱唱歌'</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">instance(man)    // 我爱学习</span><br><span class="line">instance(women)    // 我爱唱歌</span><br></pre></td></tr></table></figure><p>有交叉类型、联合类型等，而类型命名则是更灵活的类型组织方式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官网🌰</span></span><br><span class="line">type Name = string;</span><br><span class="line">type NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型多了之后，有时候需要对某一类型做特别处理，于是有类型断言 （<code>&lt;类型&gt;</code>） 和类型守卫（<code>typeof</code>, <code>instanceof</code>, <code>in</code>等）。</p><p>还可以通过条件判断来选择哪种类型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官网🌰</span></span><br><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">f</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">boolean</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> <span class="title">extends</span> <span class="title">true</span> ? <span class="title">string</span> : <span class="title">number</span>;</span></span><br><span class="line"><span class="function">// <span class="title">Type</span> <span class="title">is</span> '<span class="title">string</span> | <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="title">let</span> <span class="title">x</span> = <span class="title">f</span>(<span class="params">Math.random(</span>) &lt; 0.5)</span></span><br></pre></td></tr></table></figure><p>当然了，以上代码好多的标识符是没有必要添加类型注解的。</p><blockquote><p>类型推断，即，类型是在哪里如何被推断的</p></blockquote><p>类型注解也不是越多越好，即使有些地方你不添加类型注解，TypeScript 也会通过上下文归类等方式找到最佳通用类型。</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式再次进阶</title>
    <url>/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="发布-订阅者模式"><a href="#发布-订阅者模式" class="headerlink" title="发布/订阅者模式"></a>发布/订阅者模式</h1><h2 id="发布-订阅模式概念"><a href="#发布-订阅模式概念" class="headerlink" title="发布/订阅模式概念"></a>发布/订阅模式概念</h2><p>说起观察者模式, 往往会牵扯到发布/订阅模式. 两者存在着很多的相似之处, 它们都是维护着一个列表, 然后都可以对列表的对象进行增删和通知. 不同的地方可能就在于处理添加和通知的方式上吧.</p><blockquote><p>发布/订阅模式使用了一个主题/事件通道, 这个通道介于希望接到通知的对象(订阅者)和激活事件的对象(发布者)之间. 该事件系统允许代码定义应用程序的特定事件, 这些事件可以传达自定义参数, 自定义参数包含订阅者所需的值. 其目的是避免订阅者和发布者之间产生依赖关系. ———《设计模式: 可复用面向对象软件基础》</p></blockquote><h2 id="戏说发布-订阅模式模式"><a href="#戏说发布-订阅模式模式" class="headerlink" title="戏说发布/订阅模式模式"></a>戏说发布/订阅模式模式</h2><p><em>以下所有代码参见<a href="https://codepen.io/yexiaochen/pen/xQPMqQ" rel="external nofollow noopener noreferrer" target="_blank">publish/subscribe</a>.</em><br>既然和观察者模式类似, 那么在<a href="https://yexiaochen.github.io/从观察者模式说起/" rel="external nofollow noopener noreferrer" target="_blank">从观察者模式说起</a>提到的小故事, 就可以接着往下续了.<br>subject1带着那么一拨人回去复命, 经过一段时间的磨合实践, 效果也是很明显. 附近的公司听到风声后, 也纷纷组织派遣员工前来学习. 人多了, 需求也变多了, 这么多人肯定不能再呆在一起学习了. 原来只是一个公司的人呆在一间屋子里学习, 得到命令后大家开始各司其职. 现在, 各个公司的学习内容不同, 它们理应独立开来. 因为各个公司动作可以不同步, 但公司内部一定要同步起来. 为了区别对待, 每个公司都有能和别人区分的令牌, 有了令牌同一个公司的人就可以进入与令牌相对应的房间了(当然一个人也可以有很多令牌, 商业间谍吧😂).</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我是Pubsub, 我负责管理这拨人.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 维护事件列表, 这里将以对象的形式出现, key: value, key: 令牌, value: 同一公司员工列表.</span></span><br><span class="line">        <span class="keyword">this</span>. handles = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在, 不同公司的人前来学习的时候, 需要告诉Pubsub他们公司的令牌号, 进而引领到令牌对应的房间.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 注册事件. 如果是公司第一次派人过来, 那就新开一间.</span></span><br><span class="line">    subscribe(type, handle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.handles[type]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handles[type] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handles[type].push(handle)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果某个房间的某个人, 或整个房间的人都不打算来了, 也需要Pubsub将其注销.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 注销事件. 公司个人或整体注销.</span></span><br><span class="line">    unsubscribe(type, handle) &#123;</span><br><span class="line">        <span class="keyword">let</span> pos = <span class="keyword">this</span>.handles[type].indexOf(handle)</span><br><span class="line">        <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="comment">// 不传handle, 则默认注销所有和type事件相关的事件处理函数.</span></span><br><span class="line">        <span class="keyword">this</span>.handles.length = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ~pos &amp;&amp; <span class="keyword">this</span>.handles[type].splice(pos, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的团体做出了区分, 算是万事具备. 想要哪个房间里的人动起来, 有了令牌号, 只要对着吼一嗓子即可.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 通知事件</span></span><br><span class="line">    publish() &#123;</span><br><span class="line">        <span class="comment">// 执行所有和type事件相关的处理函数.</span></span><br><span class="line">        <span class="keyword">let</span> type = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">this</span>.handles[type].forEach(<span class="function"><span class="params">handle</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 箭头函数不绑定Arguments对象</span></span><br><span class="line">        handle.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看效果如何.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> handle1 = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'handle1'</span>, <span class="built_in">JSON</span>.stringify(rest), <span class="string">'&lt;br/&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle2 = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'handle2'</span>, <span class="built_in">JSON</span>.stringify(rest))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ps = <span class="keyword">new</span> Pubsub()</span><br><span class="line"></span><br><span class="line">ps.subscribe(<span class="string">'notify-1'</span>, handle1)</span><br><span class="line"></span><br><span class="line">ps.subscribe(<span class="string">'notify-1'</span>, handle2)</span><br><span class="line"></span><br><span class="line">ps.subscribe(<span class="string">'notify-2'</span>, handle2)</span><br><span class="line"></span><br><span class="line">ps.unsubscribe(<span class="string">'notify-1'</span>, handle2)</span><br><span class="line"></span><br><span class="line">ps.publish(<span class="string">'notify-1'</span>, <span class="string">'hahaha'</span>, <span class="string">'heiheihei'</span>, [], &#123;&#125;)</span><br><span class="line"></span><br><span class="line">ps.publish(<span class="string">'notify-2'</span>, <span class="string">'hehehehehe'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line">handle1[<span class="string">"hahaha"</span>,<span class="string">"heiheihei"</span>,[],&#123;&#125;]</span><br><span class="line">handle2[<span class="string">"hehehehehe"</span>]</span><br></pre></td></tr></table></figure><p>不难发现, 我们的Pubsub老师只认令牌😅.</p>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>发布/订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title>白话MVC/MVP/MVVM</title>
    <url>/%E7%99%BD%E8%AF%9DMVC-MVP-MVVM/</url>
    <content><![CDATA[<blockquote><p>一切皆为数据（0，1），一切皆可量化</p></blockquote><p>不管承不承认，页面的展示都是数据的可视化。HTML 是数据，CSS 是数据，JS也是数据。只是这些数据的组合最终变成了我们想要的效果。<br>最为直观的是，我们在开发者工具 Console 控制台中，输入任何形式的数据并点击 Enter 时，最终会在下方显示出来（前提是输入正确的数据类型和格式）。又或者，我们用某些参数从服务请求一个 JSON 文件，浏览器上就会展示文件内容。<strong><code>数据 =&gt; 视图</code></strong>，就是这么简单直接。</p><h2 id="MV"><a href="#MV" class="headerlink" title="MV"></a>MV</h2><p>然而，实际上的情况远远比这复杂。为了更好的视觉享受和用户体验，浏览器上的页面效果越来越炫，交互逻辑也越来越复杂。我们拿到的第一手数据（或来自用户，或来自服务）已经不能直接用来展示了，而是要经过相应的逻辑处理（在这里我们称第一手数据为源数据，经过逻辑处理后的数据称为目标数据）。视图上的数据就是目标数据的映射。<br>而处理后的数据又该如何展示呢？是基于 DOM 做操作，还是基于目标数据重新渲染呢？两者都可，前者是以 jQuery 为代表，后者则是以 Vue 等新框架为主。举个例子🌰，对于某个 DOM 元素的显隐。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'jquery'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">$('#jquery').hide;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'jquery'</span> <span class="attr">v-show</span>=<span class="string">&#123;id[jquery]&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">data: &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">        jquery: fasle</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 DOM 操作， 如果我们需要对这个 DOM 随时改变显隐，就需要不断操作 DOM 来更改样式。 如果基于数据操作，我们只需要更改 jQuery 的值即可。<br>我们再回到刚才的话题，对于复杂的交互页面，<strong><code>数据 =&gt; 视图</code></strong> 的关系已经不再像之前那么纯净了。为了应付复杂的场景，<code>数据</code> 和 <code>视图</code> 不再是狭义上的数据和视图。<code>数据</code>包括了数据和数据相关的操作，<code>视图</code>包括了视图和对视图相关的一些操作。</p><h2 id="MV-模式"><a href="#MV-模式" class="headerlink" title="MV*模式"></a>MV*模式</h2><p>借用其他领域 <code>MV*</code> 框架模式，这里的 <code>数据</code> 和 <code>视图</code> 对应着 <code>Model</code> 和 <code>View</code>. 简单点的页面，<strong><code>Model - View</code></strong> 完全能够应付过来。但是复杂的场景，<code>Model</code> 和 <code>View</code> 会分担太多的逻辑而显得臃肿，甚至可能包含了不在自己职责范围内的逻辑。此时我们就要借助第三者来协调 <code>Model</code> 和 <code>View</code> 之间的关系。如何合作，其实也早有了相应的解决方案。比如 MVC、MVP、MVVM。因为重点始终在于协调 <code>Model</code>和 <code>View</code>，所以它们统称为 <code>MV*</code>。</p><p><img src="../images/MVC&amp;MVP.jpg" alt="MVC&amp;MVP.jpg"></p><p>MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(中介者)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))，是种模式也是种抽象的概念。每一种模式在实践中可能存在着不同的变体，但这不妨碍它们属于同一个模式。每一种模式的不同变体都是为了解决不同问题而产生的，所以它们没有什么优劣之分。<br>现在我们就把三种模式拟人化来阐述不同模式的运作方式。</p><p>由四节电池驱动的J-20模型:<br><img src="../images/J-20.jpg" alt="J-20.jpg"></p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote><p>公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。<br>模式：<strong>MVC</strong><br>飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。<br>工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作、通知飞机模型更新。<br>工程师 C：协调 M 和 V。负责响应用户、调用工程师M生成目标数据。</p></blockquote><p>首先我们要知道，客户提出了想要一个 <code>60cm * 60cm</code> 的飞机模型，这个需求到了制造商那里肯定不是给出个 <code>60cm * 60cm</code> 的小方块，而是根据需求计算处理生产真正的飞机模型（比如什么样的造型设计才能最大减少阻力），工程师M的工作之一就是根据原始数据并结合特定的逻辑规则给出最终的模型数据。<br>现在，用户手里有一飞机模型V，不过这个飞机模型的飞机双翼和用户想象的不一样。于是用户根据飞机模型上提供的方式反馈了问题（比如飞机模型提供了留言功能，用来收集用户反馈）。工程师C收到了反馈后，把工程师M拉过来对数据进行处理并生成新的模型数据，并让工程师M通知到共享相同数据的飞机模型去更新数据自主调整。插一句，说到调整，我们有两种方式。一个是，我们可以针对用户不满意的地方（飞机双翼）进行调整。一个是，我们飞机模型格式化按照最新的数据模型重新初始化一下。前者可以认为就是基于 DOM 操作的方式，后者就是基于数据的处理方式。在 MVC 中，Model 和 View 之间耦合，视图的更新需要 Model 去直接通知。Model 内因为有 View 的引用才能让视图更新。</p><p><img src="../images/MVC.png" alt="MVC.png"></p><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>如果 Model 只想做数据相关的操作，把通知 View 的逻辑挪到了 Control 里，这时 Control 摇身一变称为了 Presenter。因为解耦了 Model 和 View，也使得它们的职责划分更加清晰。</p><blockquote><p>公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。<br>模式：<strong>MVP</strong><br>飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。<br>工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。<br>工程师 P：协调 M 和 V。负责响应用户、调用工程师M生成目标数据、更新视图。</p></blockquote><p>在 MVP 模式中，工程师M的工作专注于数据，通知的活甩给了工程师P。<br>和 MVC 同样的场景，工程师P接到反馈后，把工程师M拉过来处理了数据，然后又让飞机模型依据已经处理后的数据自主调整。每次数据的变化都要主动去通知视图更新。</p><p><img src="../images/MVP.png" alt="MVP.png"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>如果数据变化能够自主触发视图更新，对 Presenter 来说也会轻松不少。于是 Presenter 再次摇身一变 称为了 ViewModel。</p><blockquote><p>公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。<br>模式：<strong>MVVM</strong><br>飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。<br>工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。<br>工程师 VM：协调 M 和 V。负责响应用户、调用工程师M生成目标数据并更新视图。</p></blockquote><p><img src="../images/MVVM.png" alt="MVVM.png"></p><p>在 MVVM 中，View 和 Model 的变化似乎不大。为了在数据变化后能够自动更新视图，ViewModel 进行了所谓的数据绑定。ViewModel 将 <strong>目标数据</strong> 和视图进行了绑定，在最终生成目标数据时，会触发视图的更新。在这里我们可以想象有两份数据，一份是源数据，一份是目标数据。绑定视图的是目标数据，这样，我们直接修改目标数据时会触发视图更新。如果是源数据经处理后赋给目标数据，目标数据也会改变，也会触发试图更新。总之，在 MVVM 中，视图是目标数据的可视化，通过改变视图里的数据也就等于改变了目标数据。<br>和 MVC、MVP 同样的场景，不过科技发达了，工程师VM有个自动化处理程序。用户反馈了问题，工程师VM的这个自动处理程序接到反馈自动处理并将结果发给飞机模型让其自主调整。</p><p>以下是Vue的MVVM示意图：<br><img src="../images/mvvmVue.png" alt="mvvmVue.png"><br>MVC、MVP和MVVM大致就是如此，根据三种模式以及不同场景，最终演变出了不同的变体。<br>但是，不同的变体是针对不同问题的解决方案，指不定后来还会有 MVA、MVB…, 谁知道呢</p>]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MV*</tag>
      </tags>
  </entry>
  <entry>
    <title>解剖排序算法</title>
    <url>/%E8%A7%A3%E5%89%96%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排序是计算机中对存储的数据执行最常见的操作之一。语法简单，却很精妙。在排序算法中绕不开的是循环，只有在深入学习排序算法时，才发现平时不起眼的循环语句不可小觑。</p><p>拿最简单的冒泡排序来说，道理我都懂，可为什么会想到两层嵌套的循环语句？为什么两层循环语句的条件会有所不同？两层循环的关联逻辑是什么？循环在冒泡中扮演着什么角色？循环是通过怎样的逻辑完成冒泡的？等等。这些问题的背后，都值得我们去探究。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>在说正题之前，需要说一个小插曲。由于互联网寒冬，程序员们都有一种危机感。在这场危机中，程序员的筛选条件也变得更加苛刻。无论是前端还是后端，都最好能够熟悉掌握一些基础算法。所以说，刷算法题，也在程序员间流行起来了。我旁边的一同事，就刷到了一个有趣的算法，说是挺有意思的，就让我也尝试一下。讲真，作为一个前端，除了简单处理一下接口数据，还真没有训练过应试般的算法。</p><p>题目大致是这样的，在 n*n 的平面中，以一半的空间螺旋有序排满以1起始若干数字。<br>画图如下：</p><center><br><img src="../images/spiralAlgorithm.jpg" alt="螺旋算法"><br></center><p>随着思考的深入，突然发现，这tm不就是一道数学题么？（原谅我说粗话了）<br>找出已知，列出未知，关联已知未知，就差列 x、y 了。</p><p>以下以 5*5 为例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;).map(<span class="function"><span class="params">item</span> =&gt;</span> ([]));</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sort</span>(<span class="params">init, length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = init, n= init;</span><br><span class="line">    <span class="keyword">while</span>(m &lt; length)&#123;</span><br><span class="line">        arr[m++][init] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    --m;</span><br><span class="line">    <span class="keyword">while</span>(n &lt; length <span class="number">-1</span>) &#123;</span><br><span class="line">        arr[--m][++n] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    --n;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; init) &#123;</span><br><span class="line">        arr[m][n--] = i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">3</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    Sort(n+<span class="number">1</span>, length - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Sort(<span class="number">0</span>, <span class="number">5</span>), arr)</span><br></pre></td></tr></table></figure><p>变动的就是未知，找出循环条件，关联已知，这样等式就算列出来了。在这里我把平面想像成平面坐标，m、n 当作 x、y 轴，数组就是坐标点的集合，数字螺旋折转的条件作为循环递归条件，就这样，一个粗糙的算法算是完成了。</p><p>虽然这和本次主题的关系不是很大，但是很受启发，让我觉得程序和数学果然存在着紧密的关系。回到这一小节，以最简单的 for 循环为例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length; i++)&#123;&#125;</span><br></pre></td></tr></table></figure><p>以上就是最简单的 for 循环写法，从这个简单的 for 语句，我们能够知道的是，第几次循环<code>i</code>（即当前），循环的次数<code>arr.length</code>及循环的驱动<code>i++</code>。很重要的一点就是，<code>i</code> 是随着循环递增的。循环就是这么简单，也没有什么其他魔力。</p><p>在排序算法中，还有一点需要注意的，那就是数组。在 JavaScript 中，数组元素在内存中并不是连续的。我们可以通过索引来引用相应位置的元素。更重要的是，我们通常操作数组元素的时候，并不是操作数组元素本身，而是该位置上的变量。我们可以想象成，每一个索引位置都是一个变量，然后通过给变量赋值数组元素。</p><p>循环和数组，如果单独使用倒也没什么。如果两者结合，你就会发现，随着循环的次数增加，数组索引也会递增，再结合一些逻辑，就可以把某些元素移动到制定的位置。</p><p>那么，都结合怎样的逻辑呢？</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序逻辑，通过两两比较，把较大的元素赋值给当前位置索引的后一索引位置，然后随着循环增加，当前索引也会递增，最终会把最大值推到末尾。然后把这个过程循环多次，最终把倒数第二大、倒数第三大…移到指定位置。</p><center><br><img src="../images/冒泡排序.gif" alt="冒泡排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)&#123;    <span class="comment">// 递增更换当前元素；</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;    <span class="comment">// 相邻元素比较；</span></span><br><span class="line">                [arr[j], arr[j+<span class="number">1</span>]] = [arr[j+<span class="number">1</span>], arr[j]];    <span class="comment">// 位置互换；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序逻辑，比较当前数组元素，找出最小元素的索引，将该位置的元素移动指定位置。然后多次循环遍历，最终将剩下数组元素中第二小元素、第三小元素…移到指定位置。</p><center><br><img src="../images/选择排序.gif" alt="选择排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j ++)&#123;    <span class="comment">// 递增替换当前元素；</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])&#123;</span><br><span class="line">                minIndex = j;    <span class="comment">// 更新最小元素索引；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];    <span class="comment">// 与最小元素互换位置；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序逻辑，将当前的数组元素与之前的数组元素比较，并将其插入到适当位置。</p><center><br><img src="../images/插入排序.gif" alt="插入排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">let</span> preIndex = i <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; temp)&#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex--];    <span class="comment">// 该位置元素若小于当前元素，则将其后移动；</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序算是插入排序的升级版本，插入排序是与之前的数组元素挨个进行比较，而希尔排序是以特定间隔进行多次分组比较，所以说在代码上很相似。</p><center><br><img src="../images/希尔排序.gif" alt="希尔排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">gap, arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gap.length; i++)&#123;    <span class="comment">// 以不同间隔分组比较；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = gap[i]; j &lt; len; j++)&#123;    <span class="comment">// 以间隔的下一索引位置起始；</span></span><br><span class="line">            <span class="keyword">let</span> temp = arr[j];</span><br><span class="line">            <span class="keyword">let</span> preGapIndex = j - gap[i];</span><br><span class="line">            <span class="keyword">while</span>(preGapIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preGapIndex] &gt; temp)&#123;    <span class="comment">// 当前元素与之前固定间隔索引位置元素进行比较；</span></span><br><span class="line">                arr[preGapIndex + gap[i]] = arr[preGapIndex];</span><br><span class="line">                preGapIndex = preGapIndex - gap[i];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[preGapIndex + gap[i]] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序逻辑，使用递归的方式将数组划分为更小的数组对，通过比较重新合成完整的数组。本文采用的是自顶向下的归并排序，还可以使用自底向上的归并排序。</p><center><br><img src="../images/归并排序.gif" alt="归并排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>);    <span class="comment">// 分组；</span></span><br><span class="line">    <span class="keyword">let</span> left = arr.slice(<span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">let</span> right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = left.length + right.length;</span><br><span class="line">    <span class="keyword">let</span> result = [], m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    left[left.length] = <span class="literal">Infinity</span>;</span><br><span class="line">    right[right.length] = <span class="literal">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;    <span class="comment">// 循环的次数为新数组的长度；</span></span><br><span class="line">        <span class="keyword">if</span>(left[m] &lt;= right[n])&#123;    <span class="comment">// 比较左右数组元素重新排列组合成新的数组；</span></span><br><span class="line">            result[i] = left[m];</span><br><span class="line">            m++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[i] = right[n];</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序逻辑，从数组中选出基准值，将大于基准值的元素移到右侧数组，将小于基准值的元素移到左侧数组，递归循环此操作直到数组为空。然后合并各组数组，最终得到排序后的新数组。</p><center><br><img src="../images/快速排序.jpg" alt="快速排序"><br></center><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length &lt; <span class="number">1</span>) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> pivot = arr[<span class="number">0</span>];    <span class="comment">// 设置基准值；</span></span><br><span class="line">    <span class="keyword">let</span> lesser = [], greater = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            lesser.push(arr[i]);    <span class="comment">// 将小于基准值推至左侧；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            greater.push(arr[i]);    <span class="comment">// 将大于基准值推至右侧；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(lesser).concat(pivot, quickSort(greater));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>over！</strong></p>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>让Python漫步在浏览器上</title>
    <url>/%E8%AE%A9Python%E6%BC%AB%E6%AD%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<blockquote><p>随着人工智能技术的普及，越来越多的前端程序员开始关注相关技术。Python 作为人工智能领域最常用的语言，与前端程序员日常使用的语言 JavaScript 同属脚本语言，且在两者发展过程中，社区也多有相互借鉴之处，因此有很多相似。一个熟悉 JavaScript 语言的前端程序员，通过掌握了他们之间的不同之处，可以快速上手 Python.</p></blockquote><p>如何快速上手? 对于一个前端程序员来说, 如果能够在熟悉的浏览器环境下学习, 最好不过了. 所以, 那就手撸一个 <a href="https://www.yexiaochen.com/pythonOnline/"><strong><em>Pathon</em></strong> 在线编程</a>. 而本文的重点则是本地文件的操作, 以下所有代码可见<a href="https://codepen.io/yexiaochen/pen/rowqYm" rel="external nofollow noopener noreferrer" target="_blank"><strong>在线demo</strong></a>.</p><h1 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h1><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><hr><p>将 <strong><em>File</em></strong> 和 <strong><em>Blob</em></strong> 类型的文件或数据异步读入内存.</p><h3 id="InstanceOfFileReader-Properties"><a href="#InstanceOfFileReader-Properties" class="headerlink" title="InstanceOfFileReader Properties"></a>InstanceOfFileReader Properties</h3><p><strong>instanceOfFileReader.<code>error(只读)</code></strong> : 在读取时的出现的错误.</p><p><strong>instanceOfFileReader.<code>readyState(只读)</code></strong> : 提供读取操作时的状态.</p><table><thead><tr><th style="text-align:center">Value(readyState)</th><th style="text-align:center">State(FileReader)</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">EMPTY</td><td style="text-align:center">未加载任何数据</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">LOADING</td><td style="text-align:center">加载数据中</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">DONE</td><td style="text-align:center">已完成数据读取</td></tr></tbody></table><p><strong>instanceOfFileReader.<code>result(只读)</code></strong> : 读取的结果, 要么是 <strong><em>String</em></strong>, 要么是 <strong><em>ArrayBuffer</em></strong>, 这取决于读取的方法, 且仅在 <strong><em>load</em></strong> 事件触发后可用.</p><h3 id="InstanceOfFileReader-Methods"><a href="#InstanceOfFileReader-Methods" class="headerlink" title="InstanceOfFileReader Methods"></a>InstanceOfFileReader Methods</h3><p><strong>instanceOfFileReader.<code>abort()</code></strong> : 终止读取操作.</p><p><strong>instanceOfFileReader.<code>readAsArrayBuffer()</code></strong> : 以 <strong><em>ArrayBuffer</em></strong> 类型为输出结果进行读取.</p><p><strong>instanceOfFileReader.<code>readAsDataURL()</code></strong> : 以 <strong><em>Data URLs</em></strong> 类型为输出结果进行读取.</p><p><strong>instanceOfFileReader.<code>readAsText()</code></strong> : 以 <strong><em>String</em></strong> 类型为输出结果进行读取.</p><h3 id="InstanceOfFileReader-Events"><a href="#InstanceOfFileReader-Events" class="headerlink" title="InstanceOfFileReader Events"></a>InstanceOfFileReader Events</h3><p><strong><code>onloadstart/loadstart</code></strong> : 在读取操作开始时触发.</p><p><strong><code>onprogress/progress</code></strong> : 在读取过程中触发以汇报当前读取进度.</p><p><strong><code>onload/load</code></strong> : 在读取操作成功完成时触发.</p><p><strong><code>onabort/abort</code></strong> : 因调用 <code>abort()</code> 而终止读取时触发.</p><p><strong><code>onerror/error</code></strong> : 在读取时遇到错误时触发.</p><p><strong><code>onloadend/loadend</code></strong> : 在读取操作完成时触发(无论成功或失败).</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">onchange</span>=<span class="string">'openFile(event)'</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">const</span> stateNames = &#123;</span><br><span class="line">  [FileReader.EMPTY] : <span class="string">'EMPTY'</span>,</span><br><span class="line">  [FileReader.LOADING] : <span class="string">'LOADING'</span>,</span><br><span class="line">  [FileReader.DONE] : <span class="string">'DONE'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> openFile = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> input = event.target;</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">  <span class="comment">// 打开注解即可查看隐藏属性</span></span><br><span class="line">  <span class="comment">// reader.onloadstart = function() &#123;</span></span><br><span class="line">  <span class="comment">//   reader.abort();</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Event: '</span>, e.type)</span><br><span class="line">  &#125;;</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Event: '</span>, e.type)</span><br><span class="line">  &#125;;</span><br><span class="line">  reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Event: '</span>, e.type)</span><br><span class="line">    <span class="built_in">console</span>.log(reader.error.message);</span><br><span class="line">  &#125;;</span><br><span class="line">  reader.onabort = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Event: '</span>, e.type)</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Event: '</span>, e.type)</span><br><span class="line">    <span class="built_in">console</span>.log(reader.error.message);</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataURL = reader.result;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ReadyState: '</span> + stateNames[reader.readyState]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Result: '</span>, dataURL)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ReadyState: '</span> + stateNames[reader.readyState]);</span><br><span class="line">  <span class="comment">// 打开注解即可查看隐藏属性</span></span><br><span class="line">  <span class="comment">// reader.readAsDataURL(input.files[0]);</span></span><br><span class="line">  <span class="comment">// reader.readAsArrayBuffer(input.files[0])</span></span><br><span class="line">  reader.readAsText(input.files[<span class="number">0</span>])</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ReadyState: '</span> + stateNames[reader.readyState]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h2><hr><p>原始数据的不可变对象. <strong><em>File</em></strong> 就是衍生于 <strong><em>Blob</em></strong>.<br>当 <strong><em>Blob</em></strong> 作为构造函数时, <strong><code>new Blob(blobParts, blobPropertyBag)</code></strong> 接受两个参数 :<br>=&gt; <strong><em>blobParts</em></strong> : <code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, 或 <code>String</code> 对象类型之一.<br>=&gt; <strong><em>blobPropertyBag({type, endings})</em></strong> : <strong><em>type</em></strong>=&gt; MIME类型. <strong><em>endings(transparent|native)</em></strong> =&gt; 用于指定包含行结束符 <code>\n</code> 的字符串如何被写入.</p><h3 id="InstanceOfBlob-Properties"><a href="#InstanceOfBlob-Properties" class="headerlink" title="InstanceOfBlob Properties"></a>InstanceOfBlob Properties</h3><p><strong>instanceOfBlob.<code>size(只读)</code></strong> : 所包含数据的大小(以字节为单位).</p><p><strong>instanceOfBlob.<code>type(只读)</code></strong> : 所包含数据的MIME类型, 如果类型未知，则该值为空字符串.</p><h3 id="InstanceOfBlob-Methods"><a href="#InstanceOfBlob-Methods" class="headerlink" title="InstanceOfBlob Methods"></a>InstanceOfBlob Methods</h3><p><strong>instanceOfBlob.<code>slice([start, [end, [contentType]]])</code></strong> : 创建基于原 <strong><em>Blob</em></strong> 对象指定字节范围内的数据的新 <strong><em>Blob</em></strong> 对象, 并赋予新 <strong><em>Blob</em></strong> 对象指定类型. 异于 <code>Array.slice()</code> 和 <code>String.slice()</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob( <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>), &#123;<span class="attr">type</span>: <span class="string">'plain/text'</span>,<span class="attr">endings</span>: <span class="string">'native'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> reader_1 = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader_1.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = reader_1.result;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result: '</span>, result, <span class="string">'type: '</span>, blob.type, <span class="string">'size: '</span>, blob.size)</span><br><span class="line">&#125;</span><br><span class="line">reader_1.readAsText(blob);</span><br></pre></td></tr></table></figure><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><hr><p><strong><em>File</em></strong> 是 <strong><em>Blob</em></strong> 的一种特殊类型, 所以适用 <strong><em>Blob</em></strong> 的场景也同样适用于 <strong><em>File</em></strong>.<br><strong><em>File</em></strong> 对象可以是来自用户在一个 <code>&lt;input&gt;</code> 元素上选择文件后返回的 <strong><em>FileList</em></strong> 对象, 也可以来自拖放操作生成的 <strong><em>DataTransfer</em></strong> 对象, 还可以是来自在一个 <strong><em>HTMLCanvasElement</em></strong> 上执行 <code>mozGetAsFile()</code> 方法后返回结果.<br>当 <strong><em>File</em></strong> 作为构造函数时, 较类似于 <strong><em>Blob</em></strong>.<br><code>new File(fileParts[, name[, filePropertyBag]])</code> 接受两个参数 :<br>=&gt; <strong><em>fileParts</em></strong> : <code>ArrayBuffer</code>, <code>ArrayBufferView</code>, <code>Blob</code>, 或 <code>String</code> 对象类型之一.<br>=&gt; <strong><em>name</em></strong> : 文件名称或文件路径.<br>=&gt; <strong><em>blobPropertyBag({type, endings})</em></strong> : <strong><em>type</em></strong>=&gt; MIME类型. <strong><em>endings(transparent|native)</em></strong> =&gt; 用于指定包含行结束符 <code>\n</code> 的字符串如何被写入.</p><h3 id="InstanceOfFile-Properties"><a href="#InstanceOfFile-Properties" class="headerlink" title="InstanceOfFile Properties"></a>InstanceOfFile Properties</h3><p><strong>instanceOfFile.<code>lastModified(只读)</code></strong> : 当前文件最后修改时间, 自 1970年1月1日0:00 以来的毫秒数.<br><strong>instanceOfFile.<code>lastModifiedDate(只读)</code></strong> : 当前文件最后修改时间.<br><strong>instanceOfFile.<code>name(只读)</code></strong> : 当前文件的名称.<br><strong>instanceOfFile.<code>webkitRelativePath(只读)</code></strong> : 当前文件的路径.<br><strong>instanceOfFile.<code>size(只读)</code></strong> : 当前文件的大小(以字节为单位).<br><strong>instanceOfFile.<code>type(只读)</code></strong> : 当前文件的MIME类型.</p><h3 id="InstanceOfFile-Methods"><a href="#InstanceOfFile-Methods" class="headerlink" title="InstanceOfFile Methods"></a>InstanceOfFile Methods</h3><p>继承使用 <strong><em>Blob</em></strong> 的方法.</p><h2 id="FileReaderSync"><a href="#FileReaderSync" class="headerlink" title="FileReaderSync"></a>FileReaderSync</h2><hr><p>以同步的方式读取 <strong><em>File</em></strong> 或 <strong><em>Blob</em></strong> 对象中的内容, 仅在 <strong><em>workers</em></strong> 里可用, 因为在主线程里进行同步 <strong><em>I/O</em></strong> 操作可能会阻塞用户界面. 有着和 <strong><em>FileReader</em></strong> 相同的读取方法.</p><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><hr><p>提供了将 <strong><em>Blob</em></strong> 生成 <strong><em>url</em></strong> 的方法, 可使本地内容生成 <strong><em>url</em></strong> 传给接受 <strong><em>url</em></strong> 的 <strong><em>API</em></strong>.</p><h3 id="URL-Methods"><a href="#URL-Methods" class="headerlink" title="URL Methods"></a>URL Methods</h3><p><strong>URL.<code>createObjectURL()</code></strong> : 为指定的 <strong><em>File</em></strong> 或 <strong><em>Blob</em></strong> 或 <strong><em>MediaSource</em></strong> 对象创建一个新的 <strong><em>url</em></strong>.<a href="https://w3c.github.io/FileAPI/#lifeTime" rel="external nofollow noopener noreferrer" target="_blank">Lifetime of blob URLs</a><br><strong>URL.<code>revokeObjectURL()</code></strong> : 释放之前生成的 <strong><em>url</em></strong>.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">accept</span>=<span class="string">'image/*'</span> <span class="attr">onchange</span>=<span class="string">'uploadPicture(event)'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'picture'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">let</span> picture = <span class="built_in">document</span>.getElementById(<span class="string">'picture'</span>);</span><br><span class="line"><span class="keyword">let</span> uploadPicture = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> target = event.target;</span><br><span class="line"><span class="keyword">let</span> file = target.files[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// URL</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line"><span class="keyword">let</span> url = URL.createObjectURL(file);</span><br><span class="line">img.width = <span class="number">300</span>;</span><br><span class="line">img.src = url;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  URL.revokeObjectURL(url);</span><br><span class="line">&#125;;</span><br><span class="line">picture.appendChild(img);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Auto download</span></span><br><span class="line"><span class="keyword">let</span> downLink = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> downUrl = URL.createObjectURL(file, &#123; <span class="attr">type</span>: <span class="string">'image/*'</span> &#125;);</span><br><span class="line">downLink.download = <span class="string">`picture.png`</span>;</span><br><span class="line">downLink.href = downUrl;</span><br><span class="line">downLink.click();</span><br><span class="line">URL.revokeObjectURL(downUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileReader</span></span><br><span class="line"><span class="keyword">let</span> reader_3 = <span class="keyword">new</span> FileReader();</span><br><span class="line">reader_3.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = reader_3.result;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">  img.width = <span class="number">300</span>;</span><br><span class="line">  img.src = result;</span><br><span class="line">  picture.appendChild(img);</span><br><span class="line">&#125;</span><br><span class="line">reader_3.readAsDataURL(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>File API</tag>
        <tag>FileReader</tag>
        <tag>Blob</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title>记开源项目的二次开发</title>
    <url>/%E8%AE%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Scratch项目的二次开发"><a href="#Scratch项目的二次开发" class="headerlink" title="Scratch项目的二次开发"></a>Scratch项目的二次开发</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>近些年来，青少儿编程被炒得火热，而 Scratch 语言因其简单易学等性质备受关注。国内多数的 Scratch 教学项目是来自 Github 上的开源 Scratch 项目，目前官方最新的版本 <a href="https://github.com/LLK/scratch-gui" rel="external nofollow noopener noreferrer" target="_blank">scratch-gui</a> 使用前端流行的 React 重写了一遍，而且该项目还在不断完善更新当中。</p><p>开源项目的二次开发就是在开源项目的基础上结合公司业务所做的二次开发，如果不考虑具体的项目，需要重视的问题是：在结合公司业务的基础上如何持续同步跟进官方项目？</p><h2 id="添加自己的代码"><a href="#添加自己的代码" class="headerlink" title="添加自己的代码"></a>添加自己的代码</h2><p>现在想象一下场景，拉取 GitHub 上的源码后，然后直接写入公司业务代码，一波猛如虎的操作后，再次拉取 GitHub 上的最新代码，发现自己写的代码全部冲突了。自己代码和源码有冲突是件正常的事，但我们依然可以减少这种冲突的出现。</p><p>要减少这种冲突就需要将公司业务代码从源码中解耦出来，尽量不干或扰覆写源码。说到这，突然想到了设计模式中的中介者模式、装饰者模式等，就是说不管是通过中间层还是包裹层，尽量不修改源码部分。</p><p>我们再说说 scratch-gui 项目，scratch-gui 使用的是 React + Redux 的技术栈，组件化开发再结合状态管理，在大型项目上，阅读源码是件痛苦的事。组件嵌套深，状态错综复杂，不过 Scratch 在组件分类上还是比较清晰的，有负责展示的基础 UI 组件，有负责状态逻辑的容器组件。</p><p>之前所说的用来解耦的模式在组件化开发上貌似并不是很好用，尤其是容器组件，与其麻烦地拆解包裹还不如封装自己的业务组件。再说了，像基础组件这类组件，源码可能需要经常修改，二次开发中，即便再省事，也不要想着直接修改这类组件。添加业务代码的原则是：尽量加，避免改，然后在复合组件中组装基础组件。</p><center><br><image src="../images/scratch-gui.png" style="width:90%"><br></image></center><p>状态流向：</p><center><br><image src="../images/project-state.svg" style="width:90%"><br></image></center><p>资源流向：</p><center><br><image src="../images/project-flow.png" style="width:90%"><br></image></center><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>我们费了那么大的劲去拆分组件不仅仅是为了后期可扩展可维护，更是为了减少因为合并最新源码所带来的代码冲突。对于提交频繁的开源项目，我们希望能够跟进同步最新代码。同时，对于业务代码的改动和提交信息，我们也很十分关注。</p><p>在说分支管理之前，我们先看看一些常用的 git 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 git 命令</span></span><br><span class="line">git <span class="built_in">help</span> [<span class="built_in">command</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理文件</span></span><br><span class="line">git clean -df</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支信息</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建与远程分支关联的分支</span></span><br><span class="line">git checkout -b 本地分支名 远程仓库／远程分支名称 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联远程分支</span></span><br><span class="line">git branch (--<span class="built_in">set</span>-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消关联远程分支</span></span><br><span class="line">git branch --<span class="built_in">unset</span>-upstream [&lt;branchname&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push --delete 远程主机 远程分支</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote -v </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">git remote add 远程仓库名称</span><br></pre></td></tr></table></figure><p>考虑到前端工程化的普及，我们把分支分为官方源码分支（Office），开发分支（dev），测试分支（test），预发布分支（pre）和生产分支（prod）。</p><p>我们是基于开源项目的二次开发，代码托管的位置自然会在两个位置，官方源码是在 GitHub 上，而我们的代码会放在公司的服务器上，所以我们需要添加两个远程仓库的地址。除了 office 分支关联 Github 上的远程仓库，其它的分支都是关联自己服务器的远程仓库。</p><p>在这里我们是将分支管理分为两个阶段，第一个阶段是首次拉取官方源码，切出 dev 分支，完成业务开发。第二个阶段为后期代码跟进同步与后期的需求开发。</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>切出 dev 分支后，我们要把公司业务代码了。可是在我们写自己业务的时候，人家官方也可能不断地完善更新。此时，我们要不断去合并最新的代码，在合并时我们使用 rebase 去合并代码，这样我们的提交记录会很清晰，毕竟我们也不会关注官方的更新。</p><p>当然了，在合并的过程中，可能会遇到了冲突的情况，在这种情况下，好多人喜欢使用 merge 命令。<del>一个一个地去解决突也挺好的</del>，而且 rebase 的功能可不止于此。</p><center><br><image src="../images/first-step.png" style="width:90%"><br></image></center><p>前期的业务开发完成后，还需要测试上线呢。测试分支（test），预发布分支（pre）和生产分支（prod）都差不多，就只说生产分支（prod）。我们切到 prod 分支，通过 merge 指令合并通过测试的分支。merge 和 rebase ，到底什么场合用，推荐的方案是，个人分支使用 rebase，公共分支使用 merge。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>第二阶段也是差不多，区别可能是我们不仅要解决是官方源码的冲突，还有自己团队代码的冲突。我们从 prod 分支切出 dev 分支，因为可能是团队协作，所以在合并到 prod 分支时，还需要同步 prod 上的更新。</p><center><br><image src="../images/second-step.png" style="width:90%"><br></image></center><p>我们切出那么多分支可不是闹着玩的，前端项目的打包行为，后端数据的来源的等，在不同的环境下都是存在区别的，所以针对不同的环境需要写不同的指令脚本，这也是开源项目二次开发需要改造的地方。</p><h2 id="构建及部署"><a href="#构建及部署" class="headerlink" title="构建及部署"></a>构建及部署</h2><p>并不是说要从零开始设计构建流，开源项目已经定义好了构建流，我们要做的只是按照自己的需要修改构建脚本。在 scratch-gui 中，构建命令是由 NPM 脚本结合 webpack 构建工具来完成的。在开发环境中为了提高开发体验，我们可能需要修改 SourceMap，使用模块热替换等，在不同环境我们还需要使用不同的打包策略等等。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"dev"</span>: <span class="string">"webpack --config webpack.config.dev.js"</span>,</span><br><span class="line"><span class="attr">"test"</span>: <span class="string">"webpack --config webpack.config.test.js"</span>,</span><br><span class="line"><span class="attr">"pre"</span>: <span class="string">"webpack --config webpack.config.pre.js"</span>,</span><br><span class="line"><span class="attr">"prod"</span>: <span class="string">"webpack --config webpack.config.prod.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于部署，前端项目是相对比较容易的，把打包好的项目往服务上一丢就算完成部署了。手动部署，自动化部署还是持续部署，这都无所谓，我们只要针对不同环境配置不同的构建脚本即可。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>公司的 Scratch 项目之前是有做过二次开发的，由于没有考虑分支管理和后期的持续跟进，所以后期拉取最新代码时，到处都是冲突，至此，项目已经没有持续开发下去的意义了。</p><p>之前的改造也是挺有意思的，改造重点是放在了项目的输入和输出上。这么做的好处就是不用详细地知道项目的细节，起码在视图上让人察觉不出任何不同。不过，就是这种很常用的方法，在这里却暴露了一个很大的问题。项目是开源的、是持续更新的，我们同样也需要持续跟进，在之前的项目中，虽然做到了输出和输入的一致，但是也抛弃项目的细节 —— 项目原有的状态管理。</p><p>我这一次的改造没有采用这种方法，而是使用的上面提到的方案。在我看来，基于 Scratch 的二次开发难度并不大只是有些繁琐。组件化开发配合状态管理，头痛的就是这种数据驱动的方式，状态在不同组件的生命周期中穿梭，导致状态的跟踪特别麻烦。所以，只有搞清楚组件的层级关系和用途，才能把整条线串起来。</p><p><img src="../images/Scratch3_project.png" alt="Scratch3方案"></p><p>项目大体如上，Scratch3 模式分为两种，一为可编辑模式，另一个是不可编辑模式。Scratch3 网站是编程官网的子站点，使用的是反向代理指向不同的项目。Scratch3 项目经过二次开发后打包部署到线上，另一方面也要打包成依赖上传到 npn 私库，供编程官网使用。编程官网和 Scratch3 的技术栈不同，编程官网提供挂载点即可。</p>]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>开源项目</tag>
        <tag>二次开发</tag>
        <tag>分支管理</tag>
      </tags>
  </entry>
  <entry>
    <title>记不住的继承方式</title>
    <url>/%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="记不住的继承方式"><a href="#记不住的继承方式" class="headerlink" title="记不住的继承方式"></a>记不住的继承方式</h1><blockquote><p>都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.</p><p>‘什么, 你说这套逻辑之前写过?!?! 速速把代码呈上来!!!’.</p><p>最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格.</p></blockquote><p>在 <strong><em>JavaScript</em></strong> 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 <strong><em>apply</em></strong>, <strong><em>call</em></strong>, <strong><em>new</em></strong> 等方法也拓宽了函数的使用场景.</p><p>除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用. 这种’无’中生有的事, 不妨了解一下.</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ol><li><p>默认情况下, 所有的原型对象都会自动获得一个 <strong><em>constructor</em></strong> (构造函数)属性, 这个属性是一个指向 <strong><em>prototype</em></strong> 属性所在函数的指针. 构造函数的原型 <strong><em>prototype</em></strong> 上 <strong><em>constructor</em></strong> 的初始值是构造函数本身. 即,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由构造函数构造出来的实例本身没有 <strong><em>constructor</em></strong> 属性, 不过可以通过原型链继承这个属性.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下person的constructor属性继承自Person.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.constructor === Person <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'constructor'</span>) === <span class="literal">false</span>  <span class="comment">// true</span></span><br><span class="line">person_1.constructor === Person.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>简单数据类型和复杂数据类型赋值传参的区别.</p><p><strong><em>JavaScript</em></strong> 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 复杂数据类型的引用指向的都是同一个值.它们相互之间没有引用/指向关系. 一旦值发生变化, 指向该值的多个引用将共享这个变化.</p></li><li><p><strong><em>new</em></strong>, <strong><em>apply</em></strong>, <strong><em>call</em></strong> 的函数调用模式.</p><p>三者的共同点都是都是指定调用函数的 <strong><em>this</em></strong> 值. 这使得同一个函数可以在不同的语境下正确执行. <strong><em>new</em></strong> 更为复杂一些. 可大致模拟为,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">constructor, arguments</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype) // 姑且称之为 new 的特性一</span><br><span class="line">    <span class="keyword">constructor</span>.apply(instance, arguments)  // 姑且称之为 new 的特性二</span><br><span class="line">    return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显, <strong><em>new</em></strong> 的操作中包涵了 <strong><em>apply</em></strong>, <strong><em>call</em></strong> 要做的事. 在此大胆猜测一下, 在实现继承的过程中, 一旦同时出现 <strong><em>new</em></strong> 和 <strong><em>apply</em></strong> 或 <strong><em>call</em></strong>, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.</p></li></ol><h2 id="不着痕迹的拿来主义"><a href="#不着痕迹的拿来主义" class="headerlink" title="不着痕迹的拿来主义"></a>不着痕迹的拿来主义</h2><blockquote><p>‘各单位请注意, 下面到我表演地时候了’</p><p>‘上道具!’</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 我是头小狮子</span></span><br></pre></td></tr></table></figure><p>想要无中生有, 那是不可能的😏, 所以我们准备了模板 <strong><em>Animal</em></strong>. <strong><em>Animal</em></strong> 有的东西, <strong><em>Leo</em></strong> 也想拥有.</p><p>而且 <strong><em>Animal</em></strong> 能用地东西也同样适用于 <strong><em>Leo</em></strong>.<br>所以, 我们期待 <strong><em>Leo</em></strong> 最终长成这个样子.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Leo.prototype.species = <span class="string">'animal'</span></span><br></pre></td></tr></table></figure><blockquote><p>‘就长这副熊样!? 这和简单的复制黏贴有什么区别!? 这和咸鱼又有什么区别!？ 说好的逼格呢！？’</p></blockquote><p>观察一下 <strong><em>Leo</em></strong>, <strong><em>Leo</em></strong> 构造函数内部逻辑和 <strong><em>Animal</em></strong> 构造函数的内部逻辑如出一辙. 既然都是一样的, 为什么不能借来用用呢? 改造一下,</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种在构造函数内部借函数而不借助原型继承的方式被称之为 <strong>借用构造函数式继承</strong>.</p><p>把属性和方法放在构造函数内部的定义, 使得每个构造出来的实例都有自己的属性和方法. 而对一些需要实例间共享的属性或方法却是没辙.</p><p>当然了, 我们本来就没打算止步于此. 构造函数内部可以靠借, 那原型上呢? 如何让 <strong><em>Leo</em></strong> 的原型上能和 <strong><em>Animal</em></strong> 的原型保持一致呢?</p><blockquote><p>‘这不是废话么? 我除了会借, 我还会继承啊, 原型继承啊!!!’</p></blockquote><p>关于原型链, 我们已经知道是怎么一回事了(不知道的可参考<a href="https://www.yexiaochen.com/%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/">从Function入手原型链</a>).</p><p>原型继承就是通过原型链实现了对象本身没有的属性访问和方法调用. 利用这个特性, 我们可以在原型上做些手脚.</p><p><strong>思路一</strong>: 可以使得 <strong><em>Leo</em></strong> 的 <strong><em>prototype</em></strong> 直接指向 <strong><em>Animal</em></strong> 的 <strong><em>prototype</em></strong>.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Leo.prototype = Animal.prototype</span><br></pre></td></tr></table></figure><p>这里有一点需要注意的, <code>Leo.prototype = Animal.prototype</code> 这种写法就等于完全覆写了 <strong><em>Leo</em></strong> 的原型, <code>Leo.prototype.constructor</code> 将和 <code>Animal.prototype.constructor</code> 保持一致, 这会使得一些等式显得诡异.</p><p>不信, 请看:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Leo.prototype.constructor === Animal.prototype.constructor === Animal</span><br></pre></td></tr></table></figure><p>针对这种情况, 我们往往会做一些修正:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接上例代码省略</span></span><br><span class="line">Leo.prototype = Animal.prototype</span><br><span class="line">Leo.prototype.constructor = Leo</span><br></pre></td></tr></table></figure><p>即使修正好了, 可是还有个大问题.</p><p>那就是, 如果想给 <strong><em>Leo</em></strong> 原型添加属性或方法, 将会影响到 <strong><em>Animal</em></strong>, 进而会影响到所有 <strong><em>Animal</em></strong> 的实例. 毕竟它们的原型之间已经画了等号.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接上例代码省略</span></span><br><span class="line"><span class="keyword">let</span> Dog = <span class="keyword">new</span> Animal(<span class="string">'dog'</span>)</span><br><span class="line">Dog.sayName  <span class="comment">// undefined</span></span><br><span class="line">Leo.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Dog.sayName()   <span class="comment">//  dog</span></span><br></pre></td></tr></table></figure><blockquote><p>‘我只想偷个懒, 没想过要捣乱啊😲!!!’</p></blockquote><p>为了消除这种影响, 我们需要一个中间纽带过渡. 还好我们知道 <strong><em>new</em></strong> 可以用来修改原型链.</p><p><strong>思路二</strong>: <strong><em>Leo</em></strong> 的 <strong><em>prototype</em></strong> 指向 <strong><em>Animal</em></strong> 的实例.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Leo.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Leo.prototype.contructor = Leo</span><br></pre></td></tr></table></figure><p>这种在构造函数内部借函数同时又借助原型继承的方式被称之为 <strong>组合继承</strong>. <strong><em>Leo</em></strong> 换个角度其实长这样:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Leo.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Leo,</span><br><span class="line">    name: undefined,</span><br><span class="line">    __proto__: Animal.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种继承模式中, <strong><em>Leo</em></strong> 的实例可以有自己的属性和方法, 实例之间又可以通过 <strong><em>prototype</em></strong> 来共享属性和方法却不会影响 <strong><em>Animal</em></strong>, 还可以通过 <strong><em><code>_proto_</code></em></strong> 追溯到 <strong><em>Animal.prototype</em></strong>.</p><p>一切都很完美👏. 不过还记得文章开始时所说的么</p><blockquote><p>在实现继承的过程中, 一旦同时出现 <strong><em>new</em></strong> 和 <strong><em>apply</em></strong> 或 <strong><em>call</em></strong>, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.</p></blockquote><p><strong><em>Animal</em></strong> 被调用了两次, 第一次是 <strong><em>Leo</em></strong> 构造函数内部作为一个普通函数被调用, 第二次是被作为构造函数构造一个实例充当 <strong><em>Leo</em></strong> 的原型.</p><p><strong><em>Animal</em></strong> 内部定义的属性和方法同时出现在 <strong><em>Leo</em></strong> 的原型和 <strong><em>Leo</em></strong> 的实例上. 实例上有的东西就不会再到原型上查找. 反之, 实例上没有的东西才会到原型上查找. 显然, 有多余的存在.</p><blockquote><p>‘这不是最优解, 我要最好的! 下一个!’</p></blockquote><p><strong>思路三</strong>: 既然有重复, 那就去其一呗. 既然 <strong><em>new</em></strong> 比 <strong><em>call</em></strong> 和 <strong><em>apply</em></strong> 厉害, 那就留着 <strong><em>new</em></strong> 吧.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line">Leo.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Leo.prototype.contructor = Leo</span><br></pre></td></tr></table></figure><p>这种在构造函数内部不借函数只借助原型继承的方式被称之为 <strong>原型链继承</strong>.</p><p>经过这么一折腾, 发现不好的地方有增无减. 实例没了自己的属性和方法了, 连 <strong><em>Animal</em></strong> 构造函数内部定义的属性方法都可以在实例间共享了(<em>思路二也存在这个问题</em>), 而且参数也不给传了.</p><blockquote><p>‘我要的不多, 能轻点折腾不, 心脏不好’</p></blockquote><p>回到 <strong>思路二</strong>, 那就删了 <strong><em>new</em></strong> 吧.</p><p><strong>思路四</strong>: 接上 <strong>思路二</strong>, 删了 <strong><em>new</em></strong>, 那只能在原型上做调整了.</p><p>我们从一开始就只是希望 <strong><em>Leo</em></strong> 的 <strong><em>prototype</em></strong> 指向 <strong><em>Animal</em></strong> 的 <strong><em>prototype</em></strong>, 不多不少且不会出现 <strong>思路一</strong> 的坏影响.</p><p>既然不能直接在两者之间画等号, 就造一个过渡纽带呗. 能够关联起原型链的不只有 <strong><em>new</em></strong>, <strong><em>Object.create()</em></strong> 也是可以的.</p><p>创建一个 <strong><em><code>_proto_</code></em></strong> 指向 <strong><em>Animal.prototype</em></strong> 的对象充当 <strong><em>Leo</em></strong> 的原型不就解决问题了么.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Leo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Leo.prototype = <span class="built_in">Object</span>.create(Animal.prototype)</span><br><span class="line">Leo.prototype.contructor = Leo</span><br></pre></td></tr></table></figure><p>这种在构造函数内部借函数同时又间接借助原型继承的方式被称之为 <strong>寄生组合式继承</strong>.</p><p>这种模式完美解决了 <strong>思路二</strong> 的弊端. 算是较为理想的继承模式吧.</p><blockquote><p>‘确认过眼神, 你才我想要的!’</p></blockquote><p>以上还是只是构造函数间的继承, 还有基于已存在对象的继承, 譬如, <strong>原型式继承</strong> 和 <strong>寄生式继承等</strong>.</p><p>讲真, 说了辣么多, 我还真没记住 <strong>借用构造函数式继承</strong>, <strong>组合继承</strong>, <strong>原型链继承</strong>, <strong>寄生组合式继承</strong>, <strong>原型式继承</strong>, <strong>寄生式继承等</strong>.</p><blockquote><p>‘你没记住这么多模式, 那你都记住什么了’</p></blockquote><p>答曰: 要想很好得继承, 一靠朋友, 二靠拼爹.</p><blockquote><p>‘这孩子是不是傻? 这都什么年代了? 再说了, 就没人告诉你你家里有矿???’</p></blockquote><p><strong>思路五</strong>: <strong><em>ES6</em></strong> 引入了 <strong><em>Class</em></strong>（类）这个概念，通过 <strong><em>class</em></strong> 关键字，可以定义类, <strong><em>Class</em></strong> 实质上是 <strong><em>JavaScript</em></strong> 现有的基于原型的继承的语法糖. <strong><em>Class</em></strong> 可以通过extends关键字实现继承. 我们可以对 <strong><em>思路四</em></strong> 来个华丽变身.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.species = <span class="string">'animal'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leo</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这么一处理后行为上和 <strong><em>思路四</em></strong> 基本没什么区别, <code>constructor(){}</code> 充当了之前的构造函数, <code>super()</code> 作为函数调用扮演着 <code>Animal.call(this, name)</code> 的角色(<em>还可以表示父类</em>). 最重要的是 <strong><em>Leo</em></strong> 的 <strong><em><code>_proto_</code></em></strong> 也指向了 <strong><em>Animal</em></strong>.</p><blockquote><p>‘矿多基因好, 啧啧啧, 我都快要喜欢上我自己了😏’</p></blockquote>]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>JavaScript继承</tag>
      </tags>
  </entry>
  <entry>
    <title>读《学习之道》</title>
    <url>/%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<blockquote><p>我意识到自己最擅长的既不是象棋也不是太极，我最擅长的是学习之道。</p></blockquote><p>偶然间听到了《学习之道》这本书，吸引我的并不是这么霸气的书名，而是书里说的一些观念很是契合。好奇之下，买本看看。书中描述的是作者传奇般的经历，与其说是传授他的学习之道，倒不如说把他经历的点点滴滴讲述给大家听。</p><p>书中并没有提出速成的方法，只是事无巨细的讲述自己的经历和感悟。而这些却是本书最重要的，作为一个传奇人物，他的经历是很有参考价值的，就算只是描述日常生活的流水账。此时，能否从书中受益，不再取决于书的内容，而是读者如何看待这本书。而最让我敬佩的是，作者能够体察入微，探究其背后的真相。</p><blockquote><p>上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道</p></blockquote><p>在读书的过程中，我才知道，为什么我会被这本书吸引。原来，作者也是《道德经》的读者，和我这个半吊子，也算是志同道合了。看完这本书，我就预料，能够读懂这书的势必赞不绝口，读不懂此书的也会觉得味同嚼蜡，索然无味。而我个人观点则是，作者把自己感悟融入了生活之中，在描述个人经历的时候，其实就是在诠释什么是学习之道。这也是我觉得作者很厉害的原因，复归自然。</p><blockquote><p>道之出口，淡乎其无味，视之不足见，听之不足闻</p></blockquote><p>生活中处处透着大道理，可是看不到，摸不着，听不见，不留痕迹。就如侦探小说里说，之所以主人公能够发现一些线索进而破解案件，是因为发现了不合理的地方。而道法自然，我们在这种环境下成长，也会觉得一切自然而然。我们生气也是自然，我们开心也是自然，以至于我们从来不追究看似自然的背后到底发生了什么。</p><p>而作者还是个孩童时，补充一下，作者很小的时候就已经过着开挂的人生了，在经历挫折时，及时发现自身处境，并从中获益。我们今天能够有幸看到这本书，也正是因为作者敏锐得观察能力。</p><blockquote><p>知人者智，自知者明。胜人者有力，自胜者强</p></blockquote><p>在当今这个社会，人们被快节奏的生活压地喘不过气来。我认为所谓的自知，不仅仅指的是个人的能力，还应该包括情绪等。很多人被情绪控制而不自知，而由情绪带来的负面影响又将人带向更坏的处境。</p><p>冥想，作为缓解压力的运动，在当今社会很流行。在冥想时，我们需要感受自身肌肉的情况，然后不断去调节放松。很多初学者在刚开始冥想时，压根不知道自己的肌肉到底是处于什么状态。人的情绪也是如此，我们需要时刻关注自己情绪的变化，最终也可以做到掌控情绪。而作者也多次在对局中，克服消极情绪，最后拿下冠军。</p><p>生气也好，开心也罢，这些都不重要。重要的是，我们需要接纳自己情绪，不抵触。如果放在学习里，那就是放下我们的畏难情绪。其实，阻止我们前行的一直都是我们自己。同时，我们还要做到静如处子，动如脱兔，把自己的注意力用在它被需要的地方。</p><blockquote><p>天下难事必作于易，天下大事必作于细</p></blockquote><p>看似简单的事物，也仅仅是因为我们想简单了。<code>不出户，知天下；不窥牖，见天道</code>，还是那句话，生活中处处透着大道理，看似简单的事情，做多了做透了，也可以作出一番成绩。而我们常常观察不到，是因为我们的想法太多，杂念太多，有太多的理所当然。</p><blockquote><p>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨</p></blockquote><p>在古时候，人们还想着修心养性。在这个物欲横流的社会中，我们更应该如此，受诱惑的东西太多，往往导致我们无法追寻本源。你呆的越舒适，你就越觉得理所当然，也就越不能发现容易忽略的细节。</p><p>之前看过一个有趣的报道，人有意识和潜意识之说。在人休息发呆的时候，人的潜意识开始进行知识整合。这也是好多人在知识储备足够的时候会有灵光一现的说法。而现在的科技发达，太多的科技产品占用了我们的生活，这也破坏了原有的整合机制。最后报道给出的结论是，在这种环境下，人类会变得越来越笨。说的貌似挺有道理的，所以说玩手机要适度。</p><p>作者还提到，内化和强化训练。就是不断针对自己不熟悉的领域去强化，进而使其成为身体惯性。讲真，写到这里，其实我已经不记得书中的细节了，虽然才刚看完。书中的内容可以说是干货满满，毕竟作者是以自己的行动去实践并取得了很大的成就。也可以说这本书什么都没说，内容宽泛，更像心理指导。</p><p>最后用一句话总结，<strong>面临危机，坦然接受痛苦，直至从容，闲庭信步</strong>。</p>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>道德经</tag>
        <tag>学习之道</tag>
      </tags>
  </entry>
  <entry>
    <title>读《乌合之众》</title>
    <url>/%E8%AF%BB%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B/</url>
    <content><![CDATA[<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>在读《乌合之众》的过程中，有时候会想，如果作者生在中国该多好，有着时间跨度长，历史悠久的群体可以研究，定会获得意想不到的收获。个人认为本书的论调基础是，人终究不是一个理性的人，能够被群体接受的意见往往不是最优的，而是能够被普遍接受的。</p><h2 id="语录"><a href="#语录" class="headerlink" title="语录"></a>语录</h2><blockquote><p>个人有意识的行为，会逐渐被群体无意识行为取代。</p></blockquote><blockquote><p>理性只是较晚的人类才有的属性，并且还不够完美，还不能揭示无意识的规律，理性想要站稳脚跟，还需要未来很长时间。在我们的所有行为中，无意识作用很大，而理性却没什么作用。</p></blockquote><blockquote><p>群体是不善于推理的，但却是急于采取行动的。</p></blockquote><blockquote><p>创造文明，领导文明的，从来都不是群体，而是少数的知识贵族。群体有的只是强大的破坏力，他们的统治永远都是一个野蛮阶段。文化的高级阶段的表现有着复杂的典章制度，能够从原始的本能状态转为思想的理性状态。</p></blockquote><blockquote><p>最容易被人们容忍的办法，其实是不怎么清楚、不容易理解，而且看上去负担最小的办法。</p></blockquote><blockquote><p>个人的自觉的个性消失，并且情感和思想要和其他人一起转向一个共同的方向，这是想要组成群体的个人所必须表现的特征。</p></blockquote><blockquote><p>无意识现象不但存在于有机体的生活中，而且存在于智力活动中，并发挥着一种完全压倒性的重要作用。</p></blockquote><blockquote><p>事实上，人们在智力上是有很大差异的，但在本能和情感方面是很相似的。</p></blockquote><blockquote><p>在集体的心理中，个人的才智是被削弱的，个性也同样被削弱了。也就是异质性被同质性吞没，无意识的特性品质占据了上风。</p></blockquote><blockquote><p>群体中可以累加的一般只有愚蠢而不是天生的智慧。</p></blockquote><blockquote><p>群体中的每个个人只是把他们拥有的共同的寻常品质集中在一起，那么这个群体所拥有的只能是明显的平庸，而无法创造出新的特点。</p></blockquote><blockquote><p>无意识人格的强势，有意识人格的消失，通过暗示和相互传染的作用，人的思想和感情向着一个共同的方向发展，并且会立刻将这种暗示的观念转化为行动。</p></blockquote><blockquote><p>群体感情的狂暴，会因为群体的责任感消失而得到强化，尤其是在异质的群体中，而且这个群体中人数越多，就越会这样。</p></blockquote><blockquote><p>群体有着明确认识的感情，就是专横和偏执，群体中的他们很容易产生这种感情，而且，只要有人在他们中间，暗示他们，或者煽动他们的这种情绪，他们会立刻付诸行动，将之实现。</p></blockquote><blockquote><p>一种观念的产生，不管它刚出现时有多么高深和伟大的成分，不管它多么伟大，仅仅是因为它进入了群体这个理由，处在群体低下智力的范围，并对群体产生的影响，就让这种观念的伟大成分丧失殆尽。</p></blockquote><blockquote><p>一种观念，只有经过彻底的改造，并进入无意识领域，变成一种情感，才能被群体接受。</p></blockquote><blockquote><p>任何推理，不管是高级的推理，还是群体的拙劣的推理，都需要借助他们头脑中的观念，但是有所差别的是，群体用来推理的各种观念之间，没有逻辑性，只有表面的连续性和相似性。</p></blockquote><blockquote><p>把群体不同的事物，只在表面上有一些相似的事物混合在一起，同时让具体的事物普遍化，这就是群体推理的一个特点。</p></blockquote><blockquote><p>对于智慧形象思维的群体来说，形象的重要性可想而知，他们一般也只能被形象打动。这些形象可以吸引或者恐吓群体，自然而然就成为群体行动的最直接动机。</p></blockquote><blockquote><p>可以影响民众想象力的，是事件发生以及引起人们注意力的方式，并不仅仅是事件的真实本身。</p></blockquote><blockquote><p>一切宗教的创立者，或者某个政治信条的创立者，他们之所以能够站稳脚跟，取决于一个共同的特点，就是他们都成功地激起了群众那种想入非非的感情。</p></blockquote><blockquote><p>在感情与理性的冲突中，感情从未失败过。</p></blockquote><blockquote><p>是时间把各种观念、信仰、思想等碎片集聚起来，形成这个时代的思想和观念。可以说，思想与观念的形成，根植于漫长的岁月的积累，可不像掷骰子那样凭运气。</p></blockquote><blockquote><p>各个不同民族的行动，支配他们的是自己的性格，但凡与这种性格不吻合的，即使拿来了，也不过是暂时借来的，只能作为表面的伪装。</p></blockquote><blockquote><p>国家用教育、教科书，让很多人具有了高文凭，然而国家只能利用这部分人中很小的一部分，那么另一部分只能无事可做。所以，工作只能给最先来的人，后面剩下的人变成为了敌人。</p></blockquote><blockquote><p>一切文明存在的主要动力向来不是理性，也可以说，尽管理性是存在的，但文明的动力始终还是各种感情，这些感情包含有尊严、自我牺牲、宗教信仰、爱国主义精神和对于荣誉的热爱。</p></blockquote><blockquote><p>让某种观念进入群众的头脑，最可靠最有效的办法，就是做出断言，并且简洁有力，不用理睬任何的证据和推理。</p></blockquote><blockquote><p>利用断言、重复和传染而进行普及的观念，借助环境得到了最大的威力，然后它们具有了一种神奇的力量，那就是我们经常说的名望。</p></blockquote><blockquote><p>没有成功陪伴的名望，是很容易在极短的时间里就走向消失的结局的。</p></blockquote><blockquote><p>所有的普遍的信念，都是虚构的，它能够生存的唯一条件，就是不要去审查它。</p></blockquote><blockquote><p>群体的头脑中，一旦有新的教条生根，那么这些教条作为源泉，会持续鼓舞人心，并且会产生出各种各样的制度、生活方式以及艺术。人们处于这样的环境中，就会被它绝对地控制。</p></blockquote><blockquote><p>能够引导意见的力量是不存在的，再加上普遍信仰的不断消亡，产生的唯一结果就是，不管是什么秩序，总会存在着完全相反的意见。并且让群体产生一种态度，就是只要不是直接触及他们的利益，他们就不会关心。</p></blockquote><blockquote><p>因为讨论和分析，所有的意见都没有了名望。意见的特征退化得很快，持续的时间也非常短暂，我们的热情也就很难被唤醒。现代人也开始变得越发麻木不仁。</p></blockquote><blockquote><p>一种文明，如果使得群众占据了上风，那么它离消亡也就不远了。如果非要找一些事去延缓它的毁灭，那就只剩群众极不稳定的意见了，还有群众对所有普遍信仰所表现出的麻木不仁。</p></blockquote><blockquote><p>群体所拥有的状态，或者说支配群体的那种力量都类似于一种野蛮的状态，或者可以理解为像这种野蛮状态的一种回归。种族需要的是获得稳定结构的集体精神，只有这样，种族才会逐渐摆脱那种缺乏思考的群体力量，进而走出野蛮状态。</p></blockquote><blockquote><p>古老的理想一旦消失，种族的才华也就消失了。它回到了原始状态，变成一群独立的个体，成为乌合之众。它没有同一性，没有未来，它所拥有的特性只是乌合之众一时的特点。它的文明的稳定性已经没有了，毫无办法地随波逐流。至上的权力是民众，盛行的是野蛮的风气。文明可能依旧比较精彩，因为历史悠久，文明的外表依旧存在，但是它已经是将要倾倒的大厦，摇摇欲坠，没有支撑，只等风暴来临，它就马上倾倒。</p></blockquote><blockquote><p>一个民族的生命循环，就是在追求理想中，从野蛮到文明，然后，理想没有了优势，便会走向衰落，然后死亡。</p></blockquote>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>乌合之众</tag>
      </tags>
  </entry>
  <entry>
    <title>读《JavaScript 轻量级函数式编程》</title>
    <url>/%E8%AF%BB%E3%80%8AJavaScript-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B/</url>
    <content><![CDATA[<h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。<a href="https://github.com/getify/Functional-Light-JS" rel="external nofollow noopener noreferrer" target="_blank">《Functional-Light JavaScript》</a>（中文翻译版<a href="https://wizardforcel.gitbooks.io/functional-light-js/content/" rel="external nofollow noopener noreferrer" target="_blank">《JavaScript 轻量级函数式编程》</a>）自称是轻量级的，抛开了概念的讲解，从为什么用，怎么用，最终呈现什么等几个方面带我们重新认识了函数这个基础且重要的概念。</p><h2 id="为什么函数式编程"><a href="#为什么函数式编程" class="headerlink" title="为什么函数式编程"></a>为什么函数式编程</h2><p>当下有三种编程范式，结构化编程、面向对象编程和函数式编程。虽然函数式编程是近些年才采用的编程范式，但是它的发明却是最早的。函数式编程概念是基于 𝛌 演算的直接衍生物，𝛌 演算法的一个核心思想是不变性。故，理论上讲，在函数式编程语言中应该不存在赋值语句的。</p><p>函数式编程的原则可以使得我们写出的代码是可读、可信任的，但这并不代表它是容易理解的。声明式的风格可以让我们知道程序是干什么的，但是要写出这样的程序却不是很容易理解的，起码对于刚接触函数式编程的人来说。</p><p>在维护代码的过程中，大部分时间是用来阅读和理解代码。有时候我们需要小心翼翼地阅读每一行代码，生怕某一个不为人知的骚操作会引发了一些列的 bug；有时候也需要在不同函数调用中了解程序的意图。总之，函数式编程的一些原则可以让我们写出可读性高、可验证的代码。当然，即便掌握了函数式编程，也并不意味着你一定得用它。</p><blockquote><p>最好的代码是可读性高的代码，因为它在正确的（理想主义）和必然的（正确的）之间寻求到了恰到好处的平衡。</p></blockquote><center><br><br><img src="../images/FP.png" alt="FP"><br><br></center><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>在数学中，函数总是获取一些输入值，然后返回一个输出值，输入值和输出值存在某种关系的映射。在函数式编程中使用的就是数学意义上的函数，接受输入值，明确 <code>return</code> 值。</p><p>函数通常是这个模样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    &#125;</span><br><span class="line">foo.length  <span class="comment">// 3</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><code>foo.length</code> 是函数期望的参数个数，通常就是形參个数。但是，并不要求实参和形參的个数相同，在函数内部可以通过 <code>arguments</code> 查看所有入參（箭头函数无此参数）。</p><p>使用 ES6 中的解构可以轻松给变量绑定入參的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[x, y, ...args]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> y = params[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> args = params.slice(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上对比，我们可以看出，声明式代码通常比命令式代码更干净。所以只要有可能，还是尽可能使用声明式和自解释的代码。</p><p>有时候函数会根据不同的输入值来重载不同的功能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> y == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计虽然暂时很方便，但是对以后的功能添加或修改会带来很大的麻烦。</p><p>在上面已经提到函数要有明确的 <code>return</code> 值，如果函数内部改变了外层作用域的变量或引用类型的入參，那么这个函数就有了副作用的，对该函数外的环境造成了污染。我们希望函数是个没有副作用的函数，即纯函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[i]) list[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        total = total + list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [ <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, , <span class="number">84</span> ];</span><br><span class="line"></span><br><span class="line">sum( nums );            <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><p>函数可以接受并返回任何类型的值，当这种类型的值恰好是函数时，它就叫高阶函数。而真正高阶的用法，就是闭包，它可以记录并且访问作用于外的变量，甚至该函数在不同作用域中被执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runningCounter</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span>(<span class="params">increment = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        val = val + increment;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score = runningCounter( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">score();                <span class="comment">// 1</span></span><br><span class="line">score();                <span class="comment">// 2</span></span><br><span class="line">score( <span class="number">13</span> );            <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>闭包中保存的变量并不会在函数执行后自动销毁，只要内部函数依然存在对变量的引用，变量就会一直保留。在函数式编程中，闭包是最重要的基础，所以，这个概念一定要理解。</p><p>还有的函数是没有名字的，这种函数称之为匿名函数，使用最多的是立即执行表达式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我是 IIFE!</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名函数的好处有很多，可以在堆栈中方便调试，可以通过名字引用自身等。但并不是所有的函数都可以命名的，箭头函数可以说是十分简洁，可以使用最简单的符号来表示一个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">people.map( <span class="function"><span class="params">person</span> =&gt;</span> person.nicknames[<span class="number">0</span>] || person.firstName );</span><br></pre></td></tr></table></figure><p>箭头函数除了写法简洁之外，还有一个可以称之为好处的便是 <code>this</code>。箭头函数中的 <code>this</code> 是基于作用域的，是可以预测的。而对于普通函数，<code>this</code> 是动态绑定的，是基于调用者的。不管是哪一种 <code>this</code>， 我们还是希望能够显式地表示上下文。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.x + ctx.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sum( context );</span><br></pre></td></tr></table></figure><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><p>在程序中往往将不变的封装起来，变化的隔离开来。很多时候不变的包括一些预设的参数。</p><p>首先封装一个请求函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data,callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的请求，有不同的 url 或参数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤二：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params">data,cb</span>) </span>&#123;</span><br><span class="line">    ajax( <span class="string">"http://some.api/person"</span>, data, cb );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrder</span>(<span class="params">data,cb</span>) </span>&#123;</span><br><span class="line">    ajax( <span class="string">"http://some.api/order"</span>, data, cb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url 就是预设的参数，而剩余的参数在调用的时候传入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤三：</span></span><br><span class="line">getPerson( &#123; <span class="attr">user</span>: CURRENT_USER_ID &#125;, cb );</span><br></pre></td></tr></table></figure><p>仔细观察步骤二，代码似乎还可以提炼下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤二：</span></span><br><span class="line"><span class="keyword">var</span> partial = <span class="function">(<span class="params">fn, ...presetArgs</span>) =&gt;</span></span><br><span class="line">                (...laterArgs) =&gt; </span><br><span class="line">                    fn(...presetArgs, ...laterArgs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPerson = partial(ajax, <span class="string">"http://some.api/person"</span>);</span><br><span class="line"><span class="keyword">var</span> getOrder = partial(ajax, <span class="string">"http://some.api/order"</span>);</span><br></pre></td></tr></table></figure><p>步骤二的转换就是偏函数的应用，它是通过预设参数的方式来减少入參的数量。如果颠倒入參的顺序，就成了右偏函数。</p><p>同样是对函数输入管理的技术，即柯里化，该技术将一个接受多个实参的函数拆解成连续的链式函数，每个链式函数接受单一实参并返回接受下一个实参的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curry =</span><br><span class="line">    (fn, arity = fn.length, nextCurried) =&gt;</span><br><span class="line">        (nextCurried = <span class="function"><span class="params">prevArgs</span> =&gt;</span></span><br><span class="line">            nextArg =&gt; &#123;</span><br><span class="line">                <span class="keyword">var</span> args = prevArgs.concat( [nextArg] );</span><br><span class="line">                <span class="keyword">if</span> (args.length &gt;= arity) &#123;</span><br><span class="line">                    <span class="keyword">return</span> fn( ...args );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextCurried( args );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )( [] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5 用来指定需要链式调用的次数)</span></span><br><span class="line"><span class="keyword">var</span> curriedSum = curry( sum, <span class="number">5</span> );</span><br><span class="line">curriedSum( <span class="number">1</span> )( <span class="number">2</span> )( <span class="number">3</span> )( <span class="number">4</span> )( <span class="number">5</span> );</span><br></pre></td></tr></table></figure><p>从以上的代码可以发现，无论是偏函数还是柯里化，都是收齐所有的实参后才执行原函数，也就是说没必要一次性传入所有的参数，而且柯里化这种只接受单一参数的特性在后面的组合函数中也起着很重要的作用。</p><p>函数式编程可以说在参数上下了很大的功夫，甚至还有种称之为无形參的风格，其目的就是移除非必要的形參到实参之间的映射。无形參风格是否提高了代码的可读性，有没有必要使用无形參风格，还需要你自己去定夺。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( <span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> double( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无形參风格；</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( double );</span><br></pre></td></tr></table></figure><h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><p>函数组合，就是把上一个函数的输出值作为下一个函数的输入值，并以此持续下去。</p><p>看个例子，将一句话拆分为单词数组：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转小写，过虑出单词；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">words</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>( str )</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .split( <span class="regexp">/\s|\b/</span> )</span><br><span class="line">        .filter( <span class="function"><span class="keyword">function</span> <span class="title">alpha</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\w]+$/</span>.test( v );</span><br><span class="line">        &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去重；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uniqList = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="comment">// value not yet in the new list?</span></span><br><span class="line">        <span class="keyword">if</span> (uniqList.indexOf( list[i] ) === <span class="number">-1</span> ) &#123;</span><br><span class="line">            uniqList.push( list[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uniqList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"To compose two functions together, pass the \</span></span><br><span class="line"><span class="string">output of the first function call as the input of the \</span></span><br><span class="line"><span class="string">second function call."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueWords</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unique( words( str ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wordsUsed = uniqueWords(text);</span><br><span class="line"><span class="comment">// ["to","compose","two","functions","together","pass",</span></span><br><span class="line"><span class="comment">// "the","output","of","first","function","call","as",</span></span><br><span class="line"><span class="comment">// "input","second"]</span></span><br></pre></td></tr></table></figure><p>数据的流向：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">wordsUsed &lt;-- unique &lt;-- words &lt;-- text</span><br></pre></td></tr></table></figure><p>但是函数式编程喜欢声明式风格，关注点在是什么而不是怎么做，我们不需要知道具体的实现细节。我们希望是这样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shorterWords</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> skipLongWords( unique( words( text ) ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="keyword">var</span> shorterWords = compose( skipLongWords, unique, words );</span><br></pre></td></tr></table></figure><p>如何实现函数 <code>compose</code> ？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt;</span><br><span class="line">        result =&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> list = fns.slice();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将最后一个函数从列表尾部拿出</span></span><br><span class="line">                <span class="comment">// 并执行它</span></span><br><span class="line">                result = list.pop()( result );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt;</span><br><span class="line">        fns.reverse().reduce( <span class="function">(<span class="params">fn1,fn2</span>) =&gt;</span></span><br><span class="line">            (...args) =&gt;</span><br><span class="line">                fn2( fn1( ...args ) )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 拿出最后两个参数</span></span><br><span class="line">        <span class="keyword">var</span> [ fn1, fn2, ...rest ] = fns.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> composedFn =</span><br><span class="line">            (...args) =&gt;</span><br><span class="line">                fn2( fn1( ...args ) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rest.length == <span class="number">0</span>) <span class="keyword">return</span> composedFn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compose( ...rest.reverse(), composedFn );</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="副作用和值的不可变性"><a href="#副作用和值的不可变性" class="headerlink" title="副作用和值的不可变性"></a>副作用和值的不可变性</h2><p><code>const</code> 是用来声明一个常量的，而常量就是不允许被重新赋值的变量。在排查问题的时，我们很少将注意力放在由 const 声明的变量上，毕竟它就是一个无关痛痒的常量。如果最终就是因为这个常量发生了变化，会不会很刺激？！虽然 const 声明的是常量，但是对于引用类型的值，程序还是允许它改变的。因为 const 的不靠谱，我们不得不重新关注由它声明的常量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = [ <span class="number">2</span> ];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>数据的突变引发了一系列意想不到的 bug，究其原因，是变量被共享或有着不同的用处。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br><span class="line"></span><br><span class="line">baz();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br></pre></td></tr></table></figure><p>当变量被共享时（在函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code> 中，任何一个函数都有可能改变变量 x），最终我们无法确认 x 到底是什么值，为了追踪变量 x 的变化，我们不得不仔细逐个阅读函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code>。显而易见，这给我们阅读理解代码带来了很大的麻烦。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[i]) list[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        total = total + list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [ <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, , <span class="number">84</span> ];</span><br><span class="line"></span><br><span class="line">sum( nums );            <span class="comment">// 124</span></span><br><span class="line"></span><br><span class="line">sums;    <span class="comment">//[1, 3, 9, 27, 0, 84]</span></span><br></pre></td></tr></table></figure><p>而对于引用同一对象的不同变量，对象的改变也是同步的，这种改变往往是不易察觉的。所以，对于引用类型的特殊性，需要特别注意的。</p><p>归纳一下，什么样的变量被共享时需要额外上心的，外层作用域里的变量和引用类型的变量。</p><p>如何避免这种数据突变带来的状态紊乱的？可以想到的是将变量变成只读的或重新拷贝一份以作区别。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Object</span>.freeze( [ <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>] ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许改变：</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oops，仍然允许改变：</span></span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>Object.freeze</code> 等 API 将数据转为不可变，但是这种 API 的还是有局限性的，只能浅层限制不可变。要想使得一个深层嵌套的对象不可变，就需要深度遍历对每个属性使用 <code>Object.freeze</code> 等 API。</p><p>另一种思路就是拷贝一份数据，这样的话，再怎么折腾副本都不会影响到源数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addValue</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [ ...arr, <span class="number">4</span> ];</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addValue( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );    <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>在此，我们不由地想起函数式编程的核心 —— 不变性。我们看到了变化的数据给程序造成的可读性差、状态紊乱等坏处，自然我们就想到数据不变性会让程序更加友好。但值的不变性并不意味着值代表的状态不会发生改变，所以就有了值的拷贝。这种不变性是指，当需要改变程序中某个状态时，我们不能改变源数据，而是拷贝跟踪它的副本。拷贝也有深拷贝和浅拷贝，我们需要的是独立于源数据的副本。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLastLogin</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newUserRecord = <span class="built_in">Object</span>.assign( &#123;&#125;, user );</span><br><span class="line">    newUserRecord.lastLogin = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> newUserRecord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = updateLastLogin( user );</span><br></pre></td></tr></table></figure><p>然而，拷贝也不是没有代价的。突然多出来的副本，多少会影响到性能。我们希望有种方式可以减少内存占用，提高性能。它使得不同变量指向同一个数据源同时有着不同版本的数据，不同版本的数据互不影响，这有点像 git 的版本控制，这样的话，值的不变性这个语义也得以保留。其实已经有一些库实现了类似的优化，如 Immutable.js 等。</p><p>如果用两个字总结以上的内容，无疑，就是「干扰」了，这种干扰来自于非预期的数据变化。</p><p>作为函数式编程的主角 —— 函数，我们自然也会希望函数内部不会造成数据的突变，一切结果是可预测的，更多的希望它能够符合函数式编程的核心 —— 不变性。也就是说，我们在编码的过程中要减少函数的副作用。</p><p>除了以上所说的数据共享，副作用还包括随机性 （<code>Math.random()</code>）、IO 操作、竞态问题等。副作用是多种多样，我们使用纯函数来减少这种副作用。换句话说，与纯函数相违背的，我们基本可以认为是副作用。</p><p>什么是纯函数？有说纯函数就是幂等函数，但并不是所有的纯函数都是数学概念上的幂等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hist = <span class="built_in">document</span>.getElementById( <span class="string">"orderHistory"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等的：</span></span><br><span class="line">hist.innerHTML = order.historyText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非幂等的：</span></span><br><span class="line"><span class="keyword">var</span> update = <span class="built_in">document</span>.createTextNode( order.latestUpdate );</span><br><span class="line">hist.appendChild( update );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非幂等的：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateAverage</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        sum += list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateAverage( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">22</span>] );            <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>另一种定义函数的方法是，给定相同的输入（一个或多个），它总是产生相同的输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleArea</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种定义就是，即纯函数具有引用透明性。</p><blockquote><p>引用透明性是指一个函数调用可以被它的输出值所代替，并且整个程序的行为不会改变。换句话说，不可能从程序的执行中分辨出函数调用是被执行的，还是它的返回值是在函数调用的位置上内联的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateAverage</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        sum += list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avg = calculateAverage( nums );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"The average is:"</span>, avg );        <span class="comment">// The average is: 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avg = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"The average is:"</span>, avg );        <span class="comment">// The average is: 9</span></span><br></pre></td></tr></table></figure><p>代码的副作用降低了程序的质量，同时也加大了我们对代码的阅读难度。没有副作用的程序是不存在的，我们只是通过重构不纯的函数或封装副作用等方式来避免副作用的产生。</p><h2 id="闭包和对象"><a href="#闭包和对象" class="headerlink" title="闭包和对象"></a>闭包和对象</h2><p>首先用两段代码来描述同一个东西：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> happyBirthday()&#123;</span><br><span class="line">        age++;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">"Happy "</span> + age + <span class="string">"th Birthday, "</span> + name + <span class="string">"!"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> birthdayBoy = person( <span class="string">"Kyle"</span>, <span class="number">36</span> );</span><br><span class="line">birthdayBoy();            <span class="comment">// Happy 37th Birthday, Kyle!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方式</span></span><br><span class="line"><span class="keyword">var</span> birthdayBoy = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span>,</span><br><span class="line">    age: <span class="number">36</span>,</span><br><span class="line">    happyBirthday() &#123;</span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">"Happy "</span> + <span class="keyword">this</span>.age + <span class="string">"th Birthday, "</span> + <span class="keyword">this</span>.name + <span class="string">"!"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">birthdayBoy.happyBirthday();</span><br><span class="line"><span class="comment">// Happy 37th Birthday, Kyle!</span></span><br></pre></td></tr></table></figure><p>可以发现闭包和对象就是对同一事物的两种表达方式。</p><p>关于闭包和对象有着以下的论调：</p><ol><li>一个没有闭包的编程语言可以用对象来模拟闭包。</li><li>一个没有对象的编程语言可以用表报模拟对象。</li></ol><p>现在，我们在 JavaScript 中用对象模拟闭包。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要解决 <code>outer()</code> 执行后，<code>x</code> 变量没有被销毁。在创建函数 <code>outer</code> 时，有个对象会保存该作用域下的所有变量:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scopeOfOuter = &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建函数 <code>inner</code> 时，也会生成一个 <code>scopeOfInner</code> 的作用域对象，这个对象的原型指向 <code>scopeOfOuter</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">scopeOfInner = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( scopeOfInner, scopeOfOuter );</span><br></pre></td></tr></table></figure><p>所以在访问 x 变量时，更像是在访问 scopeOfInner.x，然后沿原型链查找。</p><p>以上只是些假设，真实的情况肯定比这复杂。这里只是论证可以使用对象实现闭包，同样我们也可以使用闭包实现对象。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归可以说是很函数式，它的优点是更具有声明行，简洁易读，但最大的弊端还是内存占用方面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">"foo!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">"bar!"</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"baz!"</span>;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>每个函数调用都将开辟出一小块称为堆栈帧的内存。堆栈帧中包含了函数语句当前状态的某些重要信息，包括任意变量的值。之所以这样，是因为一个函数暂停去执行另外一个函数，而另外一个函数运行结束后，引擎需要返回到之前暂停时候的状态继续执行。</p><center><br><br><img src="../images/stack_heap.png" alt="stack_heap"><br><br></center><p>但是对于递归来说，可能会生成上万的堆栈，最终会导致爆栈。</p><p>我们希望内层函数在函数底部调用时，外部函数的堆栈直接弹出。</p><center><br><br><img src="../images/tailCall.png" alt="tailCall"><br><br></center><p>这种技术叫做尾调用优化。</p><p>减少内存的方法还包括后继传递风格（CPS）和 Trampoline 等。</p><blockquote><p>利用CPS变换，把任意递归函数改写成尾调用形式，以 continuation 链的形式，将递归占用的栈空间转移到堆上，避免爆栈的悲剧。（<a href="https://www.zhihu.com/question/28458981" rel="external nofollow noopener noreferrer" target="_blank">CPS变换可以用来将普通递归转变为尾递归？？</a>）</p></blockquote><blockquote><p>在缺乏尾调用优化的语言中，并不知晓函数不会返回，状态、参数压栈依旧会发生，因此需要手动强制弹出下一层调用的函数，禁止解释器的压栈行为，这就是所谓的Trampoline。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib( n - <span class="number">2</span> ) + fib( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  CPS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n,cont = r =&gt; r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> cont( n );</span><br><span class="line">    <span class="keyword">return</span> fib(</span><br><span class="line">        n - <span class="number">2</span>,</span><br><span class="line">        n2 =&gt; fib(</span><br><span class="line">            n - <span class="number">1</span>,</span><br><span class="line">            n1 =&gt; cont( n2 + n1 )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">trampolined</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = fn( ...args );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">typeof</span> result == <span class="string">"function"</span>) &#123;</span><br><span class="line">            result = result();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trampoline 化</span></span><br><span class="line">trampoline(fib(n,cont = <span class="function"><span class="params">r</span> =&gt;</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> cont( n );</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> fib(</span><br><span class="line">        n - <span class="number">2</span>,</span><br><span class="line">        n2 =&gt; fib(</span><br><span class="line">            n - <span class="number">1</span>,</span><br><span class="line">            n1 =&gt; cont( n2 + n1 )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>书中还有其它章节，大部分属于实操，按下不表。对于 JavaScript 函数式编程入门，本书倒是一个不错的选择。不知道是外国人本来就说话啰嗦还是翻译的问题，<a href="https://wizardforcel.gitbooks.io/functional-light-js/content/" rel="external nofollow noopener noreferrer" target="_blank">中文版</a>有些地方读起来不是很顺畅。不过翻译向来是出力不讨好，请原谅我的吐槽，你们都是棒棒的！</p>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>读懂UML类图</title>
    <url>/%E8%AF%BB%E6%87%82UML%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="类的描述"><a href="#类的描述" class="headerlink" title="类的描述"></a>类的描述</h2><p>在面向对象编程，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。<br>类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这些对象就被称为该类的实例。<br>类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分为多个属性。类是与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。</p><h2 id="类的UML表示"><a href="#类的UML表示" class="headerlink" title="类的UML表示"></a>类的UML表示</h2><p>类图是面向对象系统建模中最常用和最重要的图，主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图描述一类的属性和操作，也对系统的约束。类图显示集合的类，接口，关联，协作和约束，它也被称为作为结构图。</p><p><img src="../images/UML.png" alt="类图表示"></p><p>在类的UML图中，使用长方形描述一个类的主要构成，长方形垂直地分为三层，分别放置类的名称、属性和方法。</p><ol><li>第一部分是类名。</li><li>第二部分是类的属性：即类的成员变量，类的性质。表示方式为：可见性 名称：类型 [= 缺省值]<ul><li>可见性表示该属性对于类外的元素是否可见，包括共有（public）、私有（private）和受保护（protected），在类图中分别表示为 <code>+</code>、<code>-</code> 和 <code>#</code>。</li><li>类型表示属性的数据类型。</li><li>缺省值表示属性的初始值，可选。</li></ul></li><li>第三部分是类的方法：即类的成员方法，操作或行为。表示方式为：可见性 名称（参数列表）[: 返回值]。<ul><li>可见性同类的属性。</li><li>参数列表表示方法的参数，多个参数之间用逗号隔开。</li><li>返回类型表示方法返回值类型，可选。</li></ul></li></ol><h2 id="类图常见关系"><a href="#类图常见关系" class="headerlink" title="类图常见关系"></a>类图常见关系</h2><p>在UML类图中，常见的有以下几种关系:泛化（Generalization）, 实现（Realization）,组合(Composition)，聚合（Aggregation）,关联（Association）,依赖(Dependency)。</p><p><img src="../images/URLRelationship.png" alt="类图常见关系"></p><ul><li>泛化（Generalization）：是父类与子类之间的关系，描述的是 <strong>is a king of</strong>(<code>is a</code>)的关系。表现为继承非抽象类。</li><li>实现（Realization）：是类与接口的关系，表示为类是接口所有特征和行为的实现。表现为继承抽象类。</li><li>组合(Composition)：是类之间整体与部分的关系。在组合关系中，整体对象负责成员对象的创建以及生命周期，即当整体对象被销毁时成员对象也会不复存在。</li><li>聚合（Aggregation）：是类之间整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。</li><li>关联（Association）：是类之间的结构关系，用于表示一类对象与另一类对象之间有联系。关联关系默认是双向的，表示相互知道，也可以单向关联、自关联、多重性关联。</li><li>依赖(Dependency)：是描述一个对象在运行期间会用到另一个对象的关系（使用关系），通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变换。</li></ul><p>各种关系的强弱顺序：<strong>泛化</strong> = <strong>实现</strong> &gt; <strong>组合</strong> &gt; <strong>聚合</strong> &gt; <strong>关联</strong> &gt; <strong>依赖</strong></p><p><img src="../images/UMLOverview.png" alt="overview"></p>]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title>读《娱乐至死》</title>
    <url>/%E8%AF%BB%E3%80%8A%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%E3%80%8B/</url>
    <content><![CDATA[<h2 id="文字时代"><a href="#文字时代" class="headerlink" title="文字时代"></a>文字时代</h2><p>我很庆幸，在我的童年时代娱乐还不盛行，那个时代教会我，一份耕耘才会有一份收获，成长总是在曲折的环境下蜕变。而今，娱乐盛行于世，它虽然给了我笑的理由，但却没有给予我笑的底气。</p><blockquote><p>你根本不可能用烟雾来表现哲学，它的形式已经排除了他的内容。<br>在电视上，话语是通过视觉形象进行的，也就是说，电视上会话的表现形式是形象而不是语言。政坛上形象经理的出现以及与此相伴的讲稿作家的没落证明了这样一点，就是：电视需要的内容和其他媒体截然不同。电视无法表现政治哲学，电视的形式注定了它同政治哲学是水火不相容的。</p><blockquote><p><font color="#007fff">批注：</font>有人说《如何阅读一本书》是如何的生硬，而文中也有观点对此做过论述。无论是语言还是文字，都不过是表达想法的媒介，如果去咬文嚼字反而会本末倒置。先不说表述者的表达方式确实可能存在问题，更有甚者，会有掩盖真实想法的可能。</p></blockquote></blockquote><blockquote><p>媒介的形式偏好某些特殊的内容，从而能最终控制文化。</p><blockquote><p><font color="#007fff">批注：</font>所以，神秘的事物一旦具像化就失去了意义。并不是说神秘感消失了，而是我们再也无法想象这种神秘了。</p></blockquote></blockquote><blockquote><p>语言不愧为一种原始而不可或缺的媒介，它使我们成为人，保持人的特点，事实上还定义了人的含义。但这并不是说，除了语言之外没有任何其他媒介，人们还能够同样方便地以同样的方式讲述同样的事情。我们对语言的了解使我们知道，语言结构的差异会导致所谓「世界观」的不同。人们怎样看待时间和空间，怎样理解事物和过程，都会受到语言中的语法特征的重要影响，所以，我们不敢斗胆宣称所有的人类大脑对于世界的理解是一致的。</p><blockquote><p><font color="#007fff">批注：</font>语言结构不同导致人们对这个世界的认知和理解也会有所不同。由此可以联想到，对于不同的语言，语法，词汇量等同样影响和塑造不同的思维方式。语言延伸了自由，同时也限制了自由。</p></blockquote></blockquote><blockquote><p>和语言一样，每一种媒介都为思考、表达思想和抒发情感的方式提供了新的定位，从而创造出独特的话语符号。<br>信息是关于这个世界的明确具体的说明，但是我们的媒介，包括那些使会话得意实现的符号，却没有这个功能。它们更像是一种隐喻，用一种隐蔽但有力的暗示来定义这个世界。</p><blockquote><p><font color="#007fff">批注：</font>世界是我们看到的世界，但是通过媒介了解的世界却是经过加工处理的，是带有媒介偏见的。</p></blockquote></blockquote><blockquote><p>媒介的独特之处在于，虽然它指导着我们看待和了解事物的方式，但它的这种介入却往往不为人所注意。</p><blockquote><p><font color="#007fff">批注：</font>我们不曾怀疑过习以为常的事物，自然不会想到它们对我们的改变，更不要说它们是怎么改变我们的。</p></blockquote></blockquote><blockquote><p>所有这些人都需要把语言放在眼前才能看清它的意思，找出它的错误，明白它的启示。</p><blockquote><p><font color="#007fff">批注：</font>语言一旦被凝固成为文字，就有时间去质疑它。</p></blockquote></blockquote><blockquote><p>在学校里，老师非常正常地告诉我们，隐喻是一种通过把某一事物和其他事物做比较来揭示该事物实质的方法。通过这种强大的暗示力，我们脑中也形成了这样一个概念。</p><blockquote><p><font color="#007fff">批注：</font>我们通过媒介了解世界，媒介通过隐喻的方式表述世界。每个真实的事物背后都有蕴含超越自身的含义，而由此构成的世界可能会因为我们对隐喻理解的不同而千差万别。</p></blockquote></blockquote><blockquote><p>我们认识到的自然、智力、人类动机或思想，并不是它们的本来面目，而是它们在语言中的表现形式。我们的语言即媒介，我们的媒介即隐喻，我们的隐喻创造了我们的文化的内容。</p><blockquote><p><font color="#007fff">批注：</font>抛开媒介，我们依然可以通过更自然的语言来表达意图，比如，表情，动作等。通过媒介认识到的世界可能并非是它们的本来面目，而是语言的表现形式。换句话说，这个世界就是通过媒介加工后的产物。</p></blockquote></blockquote><blockquote><p>真理的定义至少有一部分来自传递信息的媒体的性质。<br>不管一种媒介原来的语境是怎样的，它都有能力越过这个语境并延伸到新的位置的语境中。由于它能够引导我们组织思想和总结生活经历，所以总是影响着我们的一时和不同的社会结构。它有时影响着我们对于真善美的看法，并且一直左右着我们理解真理和定义真理的方法。</p><blockquote><p><font color="#007fff">批注：</font>我们使用媒介描绘出我们认为的世界，并在这个世界中总结出所谓的真理。真理到底有多真？事实上，我们与真正的真理相隔了一个世界。</p></blockquote></blockquote><blockquote><p>在学术界里，出版的文字被赋予的权威性和真实性远远超过口头语言。<br>我们的书面说明代表的是「事实」，而我们的口头统治却只是一个传言。</p><blockquote><p><font color="#007fff">批注：</font>文字是凝固后的语言，存在的本身就是要对存在负责，文字可被质疑，可被校对，它比语言更有效用。</p></blockquote></blockquote><blockquote><p>印刷文字对于我们的身体和大脑都提出了相当苛刻的要求。但是，控制你的身体是最低限度的要求。你还必须学会注意书本上文字的形状。你必须看穿它们，这样你才能直接了解这些形状所代表的意思。如果你仅仅专注于文字的形状，那么你就是一个让人不能容忍的低效读者，会被人当作傻子。如果你已经学会了怎样不受外观的干扰去理解意义，那么你就应该采取一种超然而客观的态度，这包括你要能够区分文字的感官愉悦、魅力或奉承语气（如果有的话）和文字所表达的观点之间的逻辑。同时，你还必须能够根据语言的语气去判断作者对于所写内容和读者的态度。换句话说，你必须知道笑话和观点之间的区别。在判断观点性质的时候，你要同时做几件事情，包括把判断推迟到整个观点完成时做出；把问题记在脑中，知道你已经决定何时、何地或是否能回答它们；用你所有相关的经历作为现有观点的反证。你还必须能够舍弃那些同所涉及观点无关的知识和经历。在你做这些准备的时候，你必须摒弃原来认为文字具有魔力的看法，更重要的是，你要接受一个抽象的形象。在铅字的文化里，我们可以说某个人不够聪明，需要给他画张图才能帮助他理解。而现在，聪明则意味着我们不借助图画就可以从容应对一个充满概念和归纳的领域。</p><blockquote><p><font color="#007fff">批注：</font>与其说是阅读一本书，倒不如说是去理解作者想要表达的意图。不管是采用何种形式，形式的背后才是关键。</p></blockquote></blockquote><blockquote><p>如果要传达意义，内容自然就要严肃。作者在写下一个句子后总希望能够说明一点儿东西，也希望读者能明白其中的意思。当作者和读者为句子的语义绞尽脑汁的时候，它们面对的其实是对智力最大的挑战。对于读者更是如此，因为作者并不是一直值得信任的。他们撒谎，他们陷入迷茫，他们过于笼统，他们滥用逻辑甚至常识。读者对于此必须有备而来，用知识武装好自己。这不是一件容易的事，因为读者往往是孤独地面对文本的。在阅读的时候，读者的反应是孤立的，他只能依靠自己的智力。面对印在纸上的句子，读者看见的是一些冷静的抽象符号，没有美感或归属感。所以，阅读从本质上来说是一件严肃的事情，当然也是一项理性的活动。<br>阅读文字意味着要跟随一条思路，这需要读者具有相当强的分类、推理和判断能力。读者要能够发现谎言，明察作者笔头流露的迷惑，分清过于笼统的概括，找出滥用逻辑和常识的地方。同时，读者还要具有评判能力，要对不同的观点保持一定的距离，这是由文本自身不受情感影响的特征所决定的。</p><blockquote><p><font color="#007fff">批注：</font>如何阅读一本书，大抵如此。</p></blockquote></blockquote><blockquote><p>阐释是一种思想的模式，一种学习的方法，一种表达的途径。所有成熟话语所拥有的特征，都被偏爱阐释的印刷术发扬光大：富有逻辑的复杂思维，高度的理性和秩序，对于自相矛盾的憎恶，超常的冷静和客观以及等待受众反应的耐心。</p><p><font color="#007fff">批注：</font>在以文字为中心的时代，人们用文字去阐述世界，用逻辑追寻真理，尽管不真，但相对客观。</p></blockquote><blockquote><p>电报对于印刷术统治下的话语定义进行了三路进攻，遭到攻击后的话语内容无聊、表现无力、形式散乱。之所以会这样，是因为电报是脱离语境的信息合法化，也就是说，信息的价值不再取决于其在社会和政治对策和行动中所起的作用，而是取决于它是否新奇有趣。电报把信息变成了一种商品，一种可以置用处或意义于不顾而进行买卖的东西。</p><blockquote><p><font color="#007fff">批注：</font>因为关注，才会有价值；因为有价值，消息才会流通。电报的冲击，使得信息从「你要你觉得」变成了「我要我觉得」。信息量大且内容空洞浮夸，除去吸引眼球的噱头，有用的信息也就三两行。</p></blockquote></blockquote><blockquote><p>梭罗说过，电报使相关的东西变得无关。这些源源不断的信息与它们的受众之间很少或几乎没有任何关系，也就是说，这些信息并没有可以赖以存在的社会环境和精神环境。<br>电报可能已经使这个国家成为「一个社区」，但这个社区却是奇怪的，因为这里住着一群除了了解一些最表面的情况外彼此之间几乎一无所知的陌生人。</p><blockquote><p><font color="#007fff">批注：</font>人是社会中的人，是需要社会认可的人。人们自以为通过共同的话题去了解彼此，殊不知真正需要了解的是交流的彼此。话题后剩下的只有空虚，空虚后需要的是更多的话题。</p></blockquote></blockquote><blockquote><p>这正是电报的传统：通过生产大量无关的信息，它完全改变了我们所称的「信息——行动比」。<br>不管是在口头文化还是在印刷术文化中，信息的重要性都在于它可能促成某种行动。当然，在任何一种交流环境中，输入（人们得到的信息）总是多于输出的（在所得到信息的基础上采取行动的可能性）。<br>电报适合于传播转瞬即逝的消息，因为会有更多更新的信息很快取代它们。这些信息后浪推前浪地进出于人们的意识，不需要也不容你稍加思索。</p><blockquote><p><font color="#007fff">批注：</font>趋利避害是一种生物本能，人们会整合信息然后采取对自己有利的行动。在文字的时代，人们要判断字里行间的真实意图。信息过剩的时代里，依旧需要如此，更何况，信息已从「我要我觉得」变成了「我要你觉得」。</p></blockquote></blockquote><blockquote><p>照片把世界表现为一个物体，而语言则把世界表现为一个概念。即是最简单的命名，也是一个思考过程——把一样东西和其他东西进行比较，选择共同的某些特征，忽略不同之处，然后进行归类。<br>照片本身就是不容置疑的观点，代表着确定无误的事实。它无心辩驳，所以它就是无可辩驳的。</p><blockquote><p><font color="#007fff">批注：</font>新的媒介与其说解放了人类的大脑，倒不如说是想代替大脑。如果说古人力能扛鼎，我相信；如果说未来人不会思考，我也相信。</p></blockquote></blockquote><blockquote><p>事实上，照片的意义就在于能让形象脱离语境，从而使它们能以不同的方式表现出来。<br>确实，照片为你听到的一句话提供了语境，而这句话又为照片提供了某种语境，然后你甚至会相信你确实学到了什么东西。<br>伪语境的作用是为了让脱离生活、毫无关联的信息获得一种表面的用处。但伪语境所能提供的不是行动，或解决问题的方法，或变化。这种信息剩下的唯一用处和我们的生活也没有真正的联系。当然，这唯一的用处就是它的娱乐功能。伪语境是丧失活力之后的文化的最后避难所。</p><blockquote><p><font color="#007fff">批注：</font>只有在某些语境下，某些信息才会有价值。而某些人又刻意去制造让信息有价值的伪语境。动力何在？因为信息就是财富。所以也不难理解，当今自媒体的火热程度。</p></blockquote></blockquote><blockquote><p>电子和图像革命所产生的最令人不安的后果是：电视呈现出来的世界在我们的眼里已经不再是奇怪的，而是自然的。这种陌生感的丧失是我们适应能力的一种标志，而且我们的适应程度在一定程度上反映了我们的变化程度。我们的文化对于电视认识论的适应非常彻底，我们已经完全接受了电视对于真理、知识和现实的定义，无聊的东西在我们眼里充满了意义，语无伦次变得合情合理。</p><blockquote><p><font color="#007fff">批注：</font>电视的普及比文字的普及要快得多，也容易得多。人之所以有进步，是因为我们遇到了挑战并克服了困难。如果从文字到电视是一种文化上的进阶，那么，这次的征服未免太过简单。</p></blockquote></blockquote><p>娱乐时代就应该持有文字时代的理性。娱乐至死，还不至于，蠢死的，倒有可能。</p><h2 id="娱乐时代"><a href="#娱乐时代" class="headerlink" title="娱乐时代"></a>娱乐时代</h2><p>娱乐时代，本来无需再多的解读。但是一场疫情，让在线教育重新活跃在公众的视野中，那么，我们就有必要重新审视一下，作为在线教育的重要媒介—— 影像、电视 ——是如何影响到人们的认知。当然，电视作为传播信息的媒介并不可怕，可怕的是，它在往奇怪的方向发展。</p><blockquote><p>但我这里想要说的不是电视的娱乐性，而是电视把娱乐本身变成了表现一切经历的形式。<br>我们的问题不在于电视为我们展示具有娱乐性的内容，而在于所有的内容都以娱乐的方式表现出来，这就完全是另一回事了。<br>“好电视”同用于陈述的语言或其他口头交流形式无关，重要的是图像要吸引人。<br>思考不是表演艺术，而电视需要的是表演艺术。<br>正是电视本身的这种性质决定了它必须舍弃思想，来迎合人们对视觉快感的需求，适应娱乐业的发展。</p><blockquote><p><font color="#007fff">批注：</font> 电视作为新的传播媒介，以图像刺激感官，博取大众眼球，奠定了其在娱乐时代的霸主地位。而这种迎合大众的方式又反过来要求它就应该娱乐大众。 如果在线教育还没有摆脱这种思维，那么，它的发展方向是奇怪的，也是可怕的。</p></blockquote></blockquote><blockquote><p>任何人都可以在电视上看到这一切，甚至更多，这就解释了为什么对文化会产生如此巨大的冲击力。电视是我们文化中存在的、了解文化的最主要方式。于是—— 这是关键之处 ——电视中表现的世界变成了这个世界应该如何存在的模型。娱乐不仅仅在电视上成为所有话语的象征，在电视下，这种象征仍然统治着一切。<br>所有这一切都证明了一点，那就是我们的文化已经开始采用一种新的方式处理事务，尤其是重要事务。随着娱乐业和非娱乐业的分界线变得越来越难划分，文化话语的性质也改变了。</p><blockquote><p><font color="#007fff">批注：</font>电视已经充斥在生活的各个角落，它作为传播信息的新媒介，虽然代表不了这个世界，却用自己的方式阐述了这个世界。通过媒介了解的世界是带有媒介偏见的，而这个媒介偏见就是它的娱乐性。</p></blockquote></blockquote><blockquote><p>当然，在电视的“今日新闻”中，我们可以看见“好……现在”这个话语模式以它最大胆也最让人尴尬的方式出现。在这里，我们看见的不仅是零散不全的新闻，而且是没有背景、没有结果、没有价值、没有任何严肃性的新闻，也就是说，新闻成了纯粹的娱乐。<br>事实上，电视新闻并不想提醒观众某条新闻有严肃的内涵，否则观众在新闻播报完后必定还要继续思考，这样就会妨碍他们观看下一条新闻。</p><blockquote><p><font color="#007fff">批注：</font>当一个悲剧被简单地陈述成百上千次，这将不再是悲剧，而是无关紧要的谈资。信息泛滥，已经使得人们丧失敬畏之心。人们自以为见惯了风雨，麻木了情感，自然也不知自己才是最可怜的那一个。</p></blockquote></blockquote><blockquote><p>电视通过创造出一种可以被称为“假消息”的种类改变了“得到消息”的含义。…假消息并不意味着错误的消息，而是意味着使人产生误解的消息—— 没有依据、毫无关联、支离破碎或流于表面的信息 ——这些信息让人产生错觉，以为自己知道了很多事实，其实却离真相越来越远。…当新闻被包装成一种娱乐形式时，它就不可避免地起到了蒙蔽作用。我前面说过，电视新闻节目提供给观众的是娱乐而不是信息，这种情况的严重性不仅在于我们被剥夺了真实的信息，还在于我们正在逐渐失去判断什么是信息的能力。无知是可以补救的，但如果我们把无知当成知识，我们该怎么做呢？<br>简单地说，自相矛盾的存在需要具备一些条件，只有在一个前后连贯的语境中，观点和事件彼此相关，自相矛盾才能成立。如果语境消失了，或者被割裂了，那么自相矛盾也会随之消失。<br>在这样一个被割裂的世界里，我们无法通过识别自相矛盾来检验正误，因为自相矛盾根本不存在。<br>我们已经彻底地适应了电视中“好……现在”的世界————所有的事件都是独立存在的，被剥夺了与过去、未来或其他任何事件的关联————连贯性消失了，自相矛盾存在的条件也随之消失了。在没有语境的语境中，它只能消失。<br>谎言没有被定义成真理，真理也没有被定义成谎言。真正发生的是公众已经适应了没有连贯性的世界，并且已经被娱乐得麻木不仁了。</p><blockquote><p><font color="#007fff">批注：</font>电视媒介所带来的世界是支离破碎的，是没有严谨性可言的。我们失去了判断的依据，失去了衡量的标准，一切皆可娱乐，一切皆为娱乐，我们即将成为没有思考，没有底线的那群人。</p></blockquote></blockquote><blockquote><p>和早些时候的印刷机一样，电视已经获得了定义新闻存在形式的力量，而且它还决定了我们如何对新闻做出反应。在把新闻包装成杂耍的同时，电视也引诱其他媒介这样做，于是整个信息环境都变成了电视的一面镜子。<br>电视告诉杂志“新闻是一种娱乐”，杂志转而告诉电视“只有娱乐才是新闻”。<br>如果你以为用某种形式表达出来的东西可以用另一种形式丝毫不损害意义地表达出来，那你就过于天真了。<br>不是一切都是可以用电视表达的，或者更准确地说，电视把某种事情转换成了另一种东西，原来的本质可能丢失，也可能被保留下来。<br>如果传递方式改变了，传递的信息就极有可能也不一样了。如果信息传递的语境和耶稣所处的时代完全不同，那么我们就不能指望信息的社会意义和心理意义还能保持不变。</p><blockquote><p><font color="#007fff">批注：</font>不要天真地认为电视可以还原出真实的世界，实质上，任何媒介都不具备这种能力。无论场景重现的影像有多么逼真，它也重现不了身临其境的感受。如果在线教育只是简单地把线下搬到线上，从教育的角度来看，失去的比获得的多。</p></blockquote></blockquote><blockquote><p>电视最大的长处是它让具体的形象进入我们的心里，而不是让抽象的概念留在我们脑海中。<br>资本主义与科学和自由民主一样，是启蒙运动的产物。资本主义的理论家们都相信，买卖双方应该具有相当的成熟度，了解足够的信息，然后理智地进行双方互惠的交易，这些事资本主义的基础。如果贪欲是资本主义机车的燃料，那么理性就应该机车的司机。根据这个理论，市场中的竞争要求买者不仅要知道什么产品对他来说是好的，而且要知道什么是好的产品。如果卖方生产了没有价值的东西，那么根据市场的规律，他就应该败出。他们认为，买方的理性激励竞争者成为赢家，并且敦促赢家不断进步。在买方无法做出理性决定的情况下，法律就应该介入使交易无效。<br>举一个最简单的例子：任何要求，不论是商业的还是其他的，如果要引起别人的注意，就一定要用语言表达出来；更精确地说，是要用陈述的方式表达出来，因为这个话语世界真实我们判断对错的依据。如果我们丢弃了这个话语世界，那么实践检验、逻辑分析或任何其他理性的工具都将失去意义。<br>电视广告把企业从生产有价值的产品引向了设法使消费者感觉产品有价值，这意味着企业的业务已经成为一种伪疗法，消费者成了信赖心理表演疗法的病人。</p><blockquote><p><font color="#007fff">批注：</font>文字时代，人们通过精确的话语表述事物（比如产品说明书），而图像时代，则是通过影像让消费者自行判断，没有阐述自身观点，全凭用户的主观臆想。这种暧昧的方式，使得很多人肆意妄为。</p></blockquote></blockquote><blockquote><p>所有的问题都是可以解决的，所有的问题都是可以快速解决的，它们快速解决要借助工艺、技巧和化学。</p><blockquote><p><font color="#007fff">批注：</font> 电视认为所有事物都可以轻而易举地使用图像来传达信息，而这种信息应该是易于理解的。久而久之，人们也会认为任何事都可以简单明了地去解决，回避冗长的处理方式。而这种趋于安逸的想法，让人沉沦于逸乐。</p></blockquote></blockquote><blockquote><p>换句话说，导致历史消失的是人们事不关己的态度，而不是他们的固执和无知。<br>在一个本身结构就是偏向图像和片段的媒介里，我们注定要丧失历史的角度。<br>“零星破碎的信息无法汇集成一个连贯而充满智慧的整体”。我们不是拒绝记忆，我们也没有认为历史不值得记忆，问题的症结在于我们已经被改造得不会记忆了。如果记忆不仅仅是怀旧，那么语境就应该成为记忆的基本条件———— 理论、洞察力、比喻 ———— 某种可以组织和明辨事实的东西。但是，图像和瞬间即逝的新闻无法提供给我们语境。<br>但是，赫胥黎的预测更接近事实：历史的消失根本不需要如此残酷的手段，表面温和的现代技术通过为民众提供一种政治形象、瞬间快乐和安慰疗法，能够同样有效地让历史销声匿迹，也许还更很久，并且不会遭到任何反对。<br>我们的文化部是赫胥黎式的，而不是奥威尔式，它想尽一切办法让我们不断地看电视，但是我们看到的是信息简单化的一种媒介，它使信息变得没有内容、没有历史、没有语境，也就是说，信息被包装成为娱乐。</p><blockquote><p><font color="#007fff">批注：</font> 很庆幸自己不是生活在单一媒介的世界里，我们还有很多的选择和很多方式去了解这个真实的世界。所以，做一个独立思考的人，做一个思想自由的人，做一个媒介世界不能约束的人。</p></blockquote></blockquote><blockquote><p>换句话说，一个人学到的最重要的东西是学习的方法。正如杜威在另一本书里写到的，我们学习我们要做的事情。而电视教育的方法是让孩子们去做电视要求他们做的事情，当然这和教室对他们提出的要求相去甚远，就像读书和看演出风马牛不相及一样。<br>电视对教育哲学的主要贡献是它提出了教学和娱乐不可分的理念。…但是从来没有人说过或暗示过，只有当教育成为娱乐时，学习才能最有效、最持久、最真实。教育哲学家们认为获得知识是一件困难的事情，因为其中必然有各种约束的介入。他们认为学习是要付出代价的，耐力和汗水必不可少；个人的兴趣要让位于集体的利益。在他们看来，要想获得出色的思辨能力对于年轻人来说绝非易事，而是一场艰苦卓绝的斗争。西塞罗说过，教育的目的是让学生们摆脱现实的奴役，而现在的年轻人正竭力做着相反的努力————为了适应现实而改变自己。<br>也就说，任何信息、故事或观点都要以最易懂的方式出现，因为对于电视来说，最重要的是学习者的满意程度，而不是学习者的成长。<br>如果要给这样一种没有前提条件、没有难题、没有阐述的教育取一个合适的名字，那么这个名字只能是“娱乐”。</p><blockquote><p><font color="#007fff">批注：</font> 知道学习什么比怎么学习更重要。阅读，从某种程度上来说是一件痛苦的事，既然选择通过阅读来学习，也就默认了愿意承担这份痛苦。而电视的表现形式正好迎合了一大批投机者 —— 妄图在不付出代价的情况下，轻松愉快地学习。</p></blockquote></blockquote><blockquote><p>到了这个时候，如果你还不能意识到技术必然会带来社会变迁，还在坚持技术是中性的，仍然认为技术始终是文化的朋友，那么你实在是太愚蠢了。<br>人们感到痛苦的不是他们用笑声代替了思考，而是他们不知道自己为什么笑以及为什么不再思考。</p><blockquote><p><font color="#007fff">批注：</font>做个真正的自己，而不是被媒介带偏的自己。</p></blockquote></blockquote><p>舜发于畎亩之中，傅说举于版筑之间，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。</p><p>故天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p><p>人恒过，然后能改，困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也。</p>]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>娱乐至死</tag>
      </tags>
  </entry>
  <entry>
    <title>进击的观察者模式</title>
    <url>/%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="商品信息改变带来的烦恼"><a href="#商品信息改变带来的烦恼" class="headerlink" title="商品信息改变带来的烦恼"></a>商品信息改变带来的烦恼</h1><blockquote><p>Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)</p></blockquote><p><em>以下所有代码参见<a href="https://codepen.io/yexiaochen/pen/rQmYQJ?editors=0110" rel="external nofollow noopener noreferrer" target="_blank">Design pattern transformation</a>.</em></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 商品的信息: 价格 &amp; 折扣</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    price: <span class="number">100</span>,</span><br><span class="line">    discount: <span class="number">0.8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顾客信息: 是否为会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳</span></span><br><span class="line"><span class="keyword">const</span> customer = &#123;</span><br><span class="line">    <span class="string">"VIP"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"quantity"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"total"</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总消费计算方式</span></span><br><span class="line">total = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!info.VIP) &#123;</span><br><span class="line">        info.total = data.price * info.quantity;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        info.total = data.price * data.discount * info.quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total(customer);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'customer'</span>, customer);</span><br><span class="line"><span class="comment">// customer &#123; VIP: true, quantity: 10, total: 800 &#125;</span></span><br></pre></td></tr></table></figure><p>从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.</p><blockquote><p>data.price = 200</p></blockquote><p>价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 <strong>total</strong> 计费.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">total(customer);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'customer'</span>, customer);</span><br><span class="line"><span class="comment">// customer &#123; VIP: true, quantity: 10, total: 1600 &#125;</span></span><br></pre></td></tr></table></figure><p>这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">    const customer = &#123;</span><br><span class="line">        "VIP": true,</span><br><span class="line">        "quantity": 10,</span><br><span class="line">        "total": 0,</span><br><span class="line"><span class="addition">+       "timeStamp": 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    // 获取购买时间</span><br><span class="line">   purchaseTime = (info) =&gt; &#123;</span><br><span class="line">        info.timeStamp = Date.now();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>于是, 我们需要执行的函数就多了一个.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">total(customer)</span><br><span class="line">purchaseTime(customer)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'customer'</span>, customer)</span><br><span class="line"><span class="comment">// &#123; VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 &#125;</span></span><br></pre></td></tr></table></figure><p>如果我们的需求还有很多, 而且不知一个customer呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="addition">+    const customer1 = &#123;</span></span><br><span class="line"><span class="addition">+    "VIP": false,</span></span><br><span class="line"><span class="addition">+    "quantity": 8,</span></span><br><span class="line"><span class="addition">+    "total": 0,</span></span><br><span class="line"><span class="addition">+    "timeStamp": 0</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"></span><br><span class="line">    total(customer)</span><br><span class="line">    purchaseTime(customer)</span><br><span class="line">    func(customer)</span><br><span class="line">    ...</span><br><span class="line">    funcN(customer1)</span><br><span class="line">    total(customer1)</span><br><span class="line">    purchaseTime(customer1)</span><br><span class="line">    func(customer1)</span><br><span class="line">    ...</span><br><span class="line">    funcN(customer)</span><br><span class="line">    ...</span><br><span class="line">    funcN(customerN)</span><br></pre></td></tr></table></figure><p>现在我们就对上面的代码进行观察者模式改造.</p><h1 id="用观察者模式改造"><a href="#用观察者模式改造" class="headerlink" title="用观察者模式改造"></a>用观察者模式改造</h1><p>从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. 那么问题来了, 这和之前所说的观察者模式(<a href="https://yexiaochen.github.io/从观察者模式说起/" rel="external nofollow noopener noreferrer" target="_blank">从观察者模式说起</a>)有什么区别呢? 在此, 我们试着用观察者模式改造下.<br>首先观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList = []</span><br><span class="line">  &#125;</span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  notify(params) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.update(params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着, 把我们想要调用的方法包装一下, 存储起来.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将要重复使用的包装一下</span></span><br><span class="line">observer1 = <span class="keyword">new</span> Observer(total)</span><br><span class="line">observer2 = <span class="keyword">new</span> Observer(purchaseTime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存起来</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject()</span><br><span class="line">subject.addObserver(observer1)</span><br><span class="line">subject.addObserver(observer2)</span><br></pre></td></tr></table></figure><p>每次价格改变时, 只需要通知一下即可.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整商品价格</span></span><br><span class="line">data.price = <span class="number">100</span></span><br><span class="line">subject.notify(customer)</span><br><span class="line">subject.notify(customer1)</span><br></pre></td></tr></table></figure><p>改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合Objec.defineProperty会有什么惊喜.</p><h1 id="与Objec-defineProperty结合"><a href="#与Objec-defineProperty结合" class="headerlink" title="与Objec.defineProperty结合"></a>与Objec.defineProperty结合</h1><p>支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. 大家都知道经过Objec.defineProperty处理的对象, 在设置和获取对象属性的时候, 会自动触发响应set和get方法. 利用这一点, 我们就可以做到生活自理了. 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependency</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watcherList = []</span><br><span class="line">  &#125;</span><br><span class="line">  addObserver(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watcherList.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  notify(params) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watcherList.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</span><br><span class="line">      watcher.update(params)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们此行的目的, 是要在data.price 或data.discount改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置data.price或data.discount的时候.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> value = data[key]</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependency()</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">          <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">              value = newVal</span><br><span class="line">              dep.notify()</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="keyword">get</span>() &#123;</span><br><span class="line">              <span class="keyword">return</span> value</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到customer有很多个, 需要通知到位. 另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. 回头看一看.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 总消费计算方式</span></span><br><span class="line"> total = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(!info.VIP) &#123;</span><br><span class="line">         info.total = data.price * info.quantity;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         info.total = data.price * data.discount * info.quantity;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 获取购买时间</span></span><br><span class="line">purchaseTime = <span class="function">(<span class="params">info</span>) =&gt;</span> &#123;</span><br><span class="line">     info.timeStamp = <span class="built_in">Date</span>.now();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现, <strong>total</strong> 函数依赖于data.price或data.discount的. 如果我们在获取属性时去添加依赖倒是一个好时机.</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">    class Dependency &#123;</span><br><span class="line">        // 省略</span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+    Dependency.targey = null;</span></span><br><span class="line"></span><br><span class="line">class Watcher &#123;</span><br><span class="line">    constructor(fn, key) &#123;</span><br><span class="line">        this.update = fn</span><br><span class="line"><span class="addition">+        this.key = key</span></span><br><span class="line"><span class="addition">+        this.value = this.getter()</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="addition">+    getter() &#123;</span></span><br><span class="line"><span class="addition">+        Dependency.targey = this;</span></span><br><span class="line"><span class="addition">+        // 触发下面的get()</span></span><br><span class="line"><span class="addition">+        this.value = data[this.key];</span></span><br><span class="line"><span class="addition">+        Dependency.targey = null;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.keys(data).forEach(key =&gt; &#123;</span><br><span class="line">    let value = data[key]</span><br><span class="line">    const dep = new Dependency()</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        set(newVal) &#123;</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.notify()</span><br><span class="line">        &#125;,</span><br><span class="line">        get() &#123;</span><br><span class="line"><span class="addition">+            if (Dependency.targey) &#123;</span></span><br><span class="line"><span class="addition">+                dep.addObserver(Dependency.targey)</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line">            return value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而 <strong>purchaseTime</strong> 方法里并没有data.price或data.discount可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个customer, 我们封装下.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与defineProperty结合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, watcherList, funcList</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = data[key]</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependency()</span><br><span class="line">    funcList.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">      dep.addObserver(<span class="keyword">new</span> Watcher(func))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        value = newVal</span><br><span class="line">        watcherList.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</span><br><span class="line">          dep.notify(watcher)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defineReactive(data, [customer, customer1], [total, purchaseTime])</span><br></pre></td></tr></table></figure><p>大功告成, 价格变动时, 我们就会自动获取到想要的结果了. 我都能自理了, 你花呗为嘛还不能自己还钱呢😒</p>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>随手记（一）</title>
    <url>/%E9%9A%8F%E6%89%8B%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="NET-ERR-CERT-DATE-INVALID"><a href="#NET-ERR-CERT-DATE-INVALID" class="headerlink" title="NET::ERR_CERT_DATE_INVALID"></a>NET::ERR_CERT_DATE_INVALID</h2><ul><li>描述：开发环境，接口请求转 https，Chrome 开发者工具控制台报错 <code>## NET::ERR_CERT_DATE_INVALID</code>。</li><li>解决方案：<a href="https://blog.51cto.com/xujpxm/2085695" rel="external nofollow noopener noreferrer" target="_blank">Chrome HSTS异常导致无法访问HTTPS网页</a>、<a href="https://www.thesslstore.com/blog/clear-hsts-settings-chrome-firefox/" rel="external nofollow noopener noreferrer" target="_blank">Re-Hashed: How to clear HSTS settings in Chrome and Firefox</a></li><li>涉及点：<a href="chrome://chrome-urls/" rel="external nofollow noopener noreferrer" target="_blank">List of Chrome URLs</a>、<a href="chrome://net-internals/#hsts" rel="external nofollow noopener noreferrer" target="_blank">hsts</a></li></ul><h2 id="Chrome插件本地导出"><a href="#Chrome插件本地导出" class="headerlink" title="Chrome插件本地导出"></a>Chrome插件本地导出</h2><ul><li>描述：由于某些原因，Chrome 应用商店无法浏览。对已下载的 Chrome 插件导出安装。</li><li>解决方案：<ol><li>地址栏输入 <code>chrome://extensions/</code>, 开启开发者模式，打开待导出插件的详细信息，记录扩展程序 ID。</li><li>地址栏输入 <code>chrome://version/</code>, 记录个人资料路径。</li><li>扩展程序路径即为：个人资料路径 + ‘Extensions’ + 扩张程序 ID。终端进入拓展程序路径目录，目录下还有扩展程序的对应版本目录，记录扩展程序版本目录。</li><li>回到扩展程序详情页，点击打包程序，输入扩展程序版本目录并点击打包扩展程序。</li><li>进入扩展程序路径，拷贝 <code>crx</code> 格式文件即可。（ <code>prm</code> 为密钥文件）</li></ol></li><li>涉及点：无</li></ul><h2 id="Cookie、跨域请求、请求方式"><a href="#Cookie、跨域请求、请求方式" class="headerlink" title="Cookie、跨域请求、请求方式"></a>Cookie、跨域请求、请求方式</h2><ul><li>描述：不同的请求方式（fetch、axios等）跨域请求时，是否主动携带 Cookie</li><li>解决方案：<a href="https://github.com/yinxin630/blog/issues/2" rel="external nofollow noopener noreferrer" target="_blank">Cookie的设置、读取以及是否自动携带问题</a></li><li>涉及点：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" rel="external nofollow noopener noreferrer" target="_blank">Fetch</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" rel="external nofollow noopener noreferrer" target="_blank">XMLHttpRequest</a></li></ul><h2 id="github-资源下载慢"><a href="#github-资源下载慢" class="headerlink" title="github 资源下载慢"></a>github 资源下载慢</h2><ul><li>描述：GitHub clone 开源项目，国内下载资源慢</li><li>可能解决方案：简单有效的方法是，修改 host 文件，添加 <code>192.30.253.112 github.com</code>。</li></ul><h2 id="本地开发环境获取-Cookie"><a href="#本地开发环境获取-Cookie" class="headerlink" title="本地开发环境获取 Cookie"></a>本地开发环境获取 Cookie</h2><ul><li>描述：后端服务部署到测试环境时，本地开发无法获取非同域名下的 Cookie</li><li>解决方案：修改 host 文件，DNS 解析，IP 映射到相应的子域名下。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># hosts文件</span></span><br><span class="line"><span class="comment"># 比如测试地址 test.domain.com</span></span><br><span class="line"></span><br><span class="line">127.0.0.1 local.domain.com</span><br></pre></td></tr></table></figure></li></ul><h2 id="Charles-抓去-https-请求显式-unknown"><a href="#Charles-抓去-https-请求显式-unknown" class="headerlink" title="Charles 抓去 https 请求显式 unknown"></a>Charles 抓去 https 请求显式 unknown</h2><ul><li>描述：抓去 https 请求时，会标红显式 <code>unknown</code></li><li>解决方案：参考以下设置项。</li></ul><p>CharlesInstallCASetting:</p><center><br><img src="../images/CharlesInstallCASetting.png" alt="CharlesInstallCASetting" width="90%"><br></center><p>CharlesProxyCA:</p><center><br><img src="../images/CharlesProxyCA.png" alt="CharlesProxyCA" width="90%"><br></center><p>CharlesProxySetting:</p><center><br><img src="../images/CharlesProxySetting.png" alt="CharlesProxySetting" width="90%"><br></center><p>CharlesProxySSLSetting:</p><center><br><img src="../images/CharlesProxySSLSetting.png" alt="CharlesProxySSLSetting" width="90%"><br></center><p>SwitchyOmegaCharles:</p><center><br><img src="../images/SwitchyOmegaCharles.png" alt="SwitchyOmegaCharles" width="90%"><br></center><h2 id="父层-overflow-需要子层溢出"><a href="#父层-overflow-需要子层溢出" class="headerlink" title="父层 overflow 需要子层溢出"></a>父层 overflow 需要子层溢出</h2><ul><li>描述：父层使用属性 overflow，子层类似于弹窗的表现，需要溢出。</li><li>解决方案：<a href="https://www.ofcss.com/2011/03/20/misunderstood-of-overflow-hidden.html" rel="external nofollow noopener noreferrer" target="_blank">容易被误解的overflow:hidden</a></li></ul><h2 id="withCredentials-请求未返回资源"><a href="#withCredentials-请求未返回资源" class="headerlink" title="withCredentials 请求未返回资源"></a><code>withCredentials</code> 请求未返回资源</h2><ul><li>描述：向 CDN 服务跨域请求资源，资源未响应。</li><li>解决方案：将 XMLHttpRequest 的 withCredentials 标志设置为 true，从而向服务器发送 Cookies。因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。但是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code> ，浏览器将不会把响应内容返回给请求的发送者。</li><li>涉及点：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" rel="external nofollow noopener noreferrer" target="_blank">Access_control_CORS</a></li></ul>]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
</search>
