<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="baidu-site-verification" content="dil57BBbBc"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="YH32omENY7b_BdEuIWv46jSBK-0Vyw_dWbJTGNBblT0"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="JavaScript 引擎,V8,"><meta name="description" content="JavaScript 引擎原理：外形与内联缓存前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 JavaScript engine fundamentals: Shapes and Inline Caches。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)"><meta name="keywords" content="JavaScript 引擎,V8"><meta property="og:type" content="article"><meta property="og:title" content="【译】JavaScript engine fundamentals: Shapes and Inline Caches"><meta property="og:url" content="http://www.yexiaochen.com/【译】JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="JavaScript 引擎原理：外形与内联缓存前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 JavaScript engine fundamentals: Shapes and Inline Caches。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://www.yexiaochen.com/images/js-engine-pipeline.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/interpreter-optimizing-compiler.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/interpreter-optimizing-compiler-v8.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/interpreter-optimizing-compiler-spidermonkey.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/interpreter-optimizing-compiler-chakra.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/interpreter-optimizing-compiler-jsc.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/object-model.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/array-1.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/array-2.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/object-model.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shape-1.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shape-2.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shape-chain-1.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shape-chain-2.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shape-tree.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/empty-shape-bypass.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shapetable-1.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/shapetable-2.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/ic-1.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/ic-2.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/ic-3.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/ic-4.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/array-shape.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/array-elements.svg"><meta property="og:image" content="http://www.yexiaochen.com/images/array-dictionary-elements.svg"><meta property="og:updated_time" content="2019-12-29T04:41:25.079Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【译】JavaScript engine fundamentals: Shapes and Inline Caches"><meta name="twitter:description" content="JavaScript 引擎原理：外形与内联缓存前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 JavaScript engine fundamentals: Shapes and Inline Caches。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)"><meta name="twitter:image" content="http://www.yexiaochen.com/images/js-engine-pipeline.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.yexiaochen.com/【译】JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/"><title>【译】JavaScript engine fundamentals: Shapes and Inline Caches | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ad8db08f31eca01d048b60d4299de095";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.yexiaochen.com/【译】JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">【译】JavaScript engine fundamentals: Shapes and Inline Caches</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-28T10:03:15+08:00">2019-09-28 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-12-29T12:41:25+08:00">2019-12-29 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4,117 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">15 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1 id="JavaScript-引擎原理：外形与内联缓存"><a href="#JavaScript-引擎原理：外形与内联缓存" class="headerlink" title="JavaScript 引擎原理：外形与内联缓存"></a>JavaScript 引擎原理：外形与内联缓存</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>。</p><p>本次暂定翻译三篇文章：</p><ol><li><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</li><li><a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</li><li><a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</li></ol><h2 id="JavaScript-引擎工作流"><a href="#JavaScript-引擎工作流" class="headerlink" title="JavaScript 引擎工作流"></a>JavaScript 引擎工作流</h2><p>一切从你写的 JavaScript 代码开始。JavaScript 引擎会解析源码并将其转换成抽象语法树（AST）。基于 AST，解释器（interpreter）会进一步地生成字节码。</p><p><img src="../images/js-engine-pipeline.svg" alt="js-engine-pipeline" title="js-engine-pipeline"></p><p>为了能够运行得更快，字节码可能会和分析数据（profiling data）一同发给优化编译器（the optimizing compiler）。优化编译器会根据这些分析数据作出某些假设以此生成高度优化的机器码。</p><p>如果某个时刻，某种假设被证明是错误的，优化编译器将去优化并回滚到解释器部分。</p><h2 id="JavaScript-引擎中的解释器-编译器流程"><a href="#JavaScript-引擎中的解释器-编译器流程" class="headerlink" title="JavaScript 引擎中的解释器/编译器流程"></a>JavaScript 引擎中的解释器/编译器流程</h2><p>现在来关注下 JavaScript 代码被解释和优化的地方，并重温下主流 JavaScript 引擎之间的不同之处。</p><p>一般来说，在运行 JavaScript 代码过程中，会有解释器和优化编译器的参与。解释器会快速地生成尚未优化的字节码，而优化编译器会耗费一些时间用来生成高度优化的机器码。</p><p><img src="../images/interpreter-optimizing-compiler.svg" alt="interpreter-optimizing-compiler" title="interpreter-optimizing-compiler"></p><p>上面的流程和 V8 在浏览器和 Node 环境下的工作流程及其相似：</p><p><img src="../images/interpreter-optimizing-compiler-v8.svg" alt="interpreter-optimizing-compiler-v8" title="interpreter-optimizing-compiler-v8"></p><p>V8 引擎的解释器被称作 Ignition，主要负责生成和执行字节码。当字节码运行时，解释器会收集分析数据，这些数据之后可能会被用来提升执行速度。如果一个函数经常被调用，即 hot，那么，经过解释器转换来的字节码和收集到的分析数据会传给 TurboFan（V8 的优化编译器），进一步被加工成高度优化的机器码。</p><p><img src="../images/interpreter-optimizing-compiler-spidermonkey.svg" alt="interpreter-optimizing-compiler-spidermonkey" title="interpreter-optimizing-compiler-spidermonkey"></p><p>SpiderMonkey，Mozilla 的 JavaScript 引擎，拥有两个优化编译器，Baseline 和 IonMonkey。解释器将转换后的代码传给 Baseline 编译器，Baseline 编译器会将其加工成部分优化的代码。再加上收集到的分析数据，IonMonkey 编译器可以生成高度优化的代码。如果基于假设的优化不成立，IonMonkey 会将代码会滚到 Baseline 部分。</p><p><img src="../images/interpreter-optimizing-compiler-chakra.svg" alt="interpreter-optimizing-compiler-chakra" title="interpreter-optimizing-compiler-chakra"></p><p>Chakra，Microsoft 的 JavaScript 引擎，也有着类似的两个优化编译器，SimpleJIT 和 FullJIT。解释器将转换后的代码传给 SimpleJIT（JIT，Just-In-Time），SimpleJIT 会将其加工成部分优化的代码。再加上收集到的分析数据，FullJIT 可以生成高度优化的代码。</p><p><img src="../images/interpreter-optimizing-compiler-jsc.svg" alt="interpreter-optimizing-compiler-jsc" title="interpreter-optimizing-compiler-jsc"></p><p>JavaScriptCore（JSC），Apple 的 JavaScript 引擎，更是发挥到了极致，使用了三个不同的优化编译器，Baseline、DFG 和 FTL。低级解释器（LLInt）将转换后的代码传给 Baseline 编译器，经其加工后传给 DFG（Data Flow Graph） 编译器，进一步加工后，传给 FTL（Faster Than Light） 编译器。</p><p>为什么有些引擎的优化编译器会比其他引擎的多？这完全是取舍问题。解释器可以很快地生成字节码，但是字节码的效率不高。优化编译器虽然会花更长的时间，但是生成的机器码更为高效。是更快地去执行代码，还是花些时间去执行更优的代码，这都是需要考虑的问题。有些引擎添加多种不同特点（省时或高效）的优化编译器，虽然这会变得更加复杂，但却可以对以上的取舍有着更细粒度地控制。还有一点需要考虑的是，内存的使用。</p><p>以上只是强调了不同 JavaScript 引擎的解析器/编译器的区别。抛开这些不谈，从更高的层面来看，所有的 JavaScript 引擎有着相同的架构：一个解析器和一些解释器/编译器。</p><h2 id="JavaScript-对象模型"><a href="#JavaScript-对象模型" class="headerlink" title="JavaScript 对象模型"></a>JavaScript 对象模型</h2><p>再来看看，在某些具体实现上，JavaScript 引擎之间还有哪些相同之处。</p><p>例如，JavaScript 引擎是如何实现 JavaScript 对象模型的？它们又是如何提升对象属性访问速度的？事实证明，所有主流的引擎在这点实现上都非常得相似。</p><p>ECMAScript 规范把所有的对象定义为词典，将字符串键映射到属性特性（<a href="https://tc39.es/ecma262/#sec-property-attributes" rel="external nofollow noopener noreferrer" target="_blank">property attributes</a>）。</p><p><img src="../images/object-model.svg" alt="object-model" title="object-model"></p><p>除了 <code>[[Value]]</code>， 规范还定义了一下属性：</p><ul><li><code>[[Writable]]</code> 定义是否可写。</li><li><code>[[Enumerable]]</code> 定义是否可枚举。</li><li><code>[[Configurable]]</code> 定义是否可配置。</li></ul><p><code>[[双中括号]]</code> 是用来描述不能直接暴露给 JavaScript 的属性。不过你依然可以通过 <code>Object.getOwnPropertyDescriptor</code> 获取某个对象上的以上属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">foo</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(object, <span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// → &#123; value: 42, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>ok，这是 JavaScript 如何定义对象的。那么，数组呢？</p><p>你可以认为数组是一个特殊的对象。一个不同点是，数组会对数组索引特殊处理。数组索引是 JavaScript 规范中的一个特殊术语。数组索引是某个范围内的任何有效索引，即在 0 ～ 2³²−2 范围内的任何一个整数。</p><p>另一个不同点是，数组还有一个 <code>length</code> 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">array.length; <span class="comment">// → 2</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="string">'c'</span>;</span><br><span class="line">array.length; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure><p>在这个例子里，数组创建好后，<code>&#39;length&#39;</code> 值为 2。当我们给数组索引为 2 的位置赋值时，数组的 <code>&#39;length&#39;</code> 会自动更新。</p><p>在 JavaScript 中，数组的定义和对象很相似。例如，数组的所有的键（包括数组索引）都是字符串表示。数组的第一个元素存在键值为 <code>&#39;0&#39;</code> 的地方。</p><p><img src="../images/array-1.svg" alt="array-1" title="array-1"></p><p>另一个属性是 <code>&#39;length&#39;</code> 属性，该属性不可枚举不可配置。</p><p>一旦数组添加一个元素，JavaScript 会自动更新 <code>&#39;length&#39;</code>属性上的 <code>[[Value]]</code> 值。</p><p><img src="../images/array-2.svg" alt="array-2" title="array-2"></p><p>一般来说，数组的行为也是和对象非常相似。</p><h2 id="优化属性的访问"><a href="#优化属性的访问" class="headerlink" title="优化属性的访问"></a>优化属性的访问</h2><p>既然我们知道在 JavaScript 中如何定义对象的。接下来让我们深入了解 JavaScript 引擎是如何高效地处理对象的。</p><p>属性访问是最常见的一个操作，对 JavaScript 引擎来说，提升访问速度事件很有意义的事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">	foo: <span class="string">'bar'</span>,</span><br><span class="line">	baz: <span class="string">'qux'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here, we’re accessing the property `foo` on `object`:</span></span><br><span class="line">doSomething(object.foo);</span><br><span class="line"><span class="comment">//          ^^^^^^^^^^</span></span><br></pre></td></tr></table></figure><h3 id="外形（Shapes）"><a href="#外形（Shapes）" class="headerlink" title="外形（Shapes）"></a>外形（Shapes）</h3><p>在 JavaScript 程序中，有相同键的对象很多，它们有相同的 <code>Shape</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">// `object1` and `object2` have the same shape.</span></span><br></pre></td></tr></table></figure><p>有着相同 <code>Shape</code> 的对象，自然会访问相同的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logX</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(object.x);</span><br><span class="line">	<span class="comment">//          ^^^^^^^^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">logX(object1);</span><br><span class="line">logX(object2);</span><br></pre></td></tr></table></figure><p>考虑到这一点，JavaScript 引擎可以基于 对象的 <code>Shape</code> 来优化对象属性的访问速度。</p><p>我们假设一个对象有 x、y 属性，且用着字典这种数据结构：它包含字符串表示的键，并且键指向各自的属性特性（property attributes）。</p><p><img src="../images/object-model.svg" alt="object-model" title="object-model"></p><p>如果要访问一个属性，例如 <code>object.y</code>，JavaScript 引擎会在 <code>JSObject</code> 中查找 <code>y</code>，然后加载对应的属性特性，最后返回 <code>[[Value]]</code>。</p><p>但是在内存中，这些属性特性要存储在哪儿呢？我们应该把它们当作 <code>JSObject</code> 的一部分存储吗？假设之后会有更多的拥有相同 <code>Shape</code> 的对象，如果我们在 <code>JSObject</code> 上存储一个包含属性名称和属性特性的完整字典的话，那显然会是一种浪费。因为拥有相同 <code>Shape</code> 的对象，它们的属性名称会重复。这回造成大量重复和不必要的内存使用。作为优化，引擎将对象的 <code>Shape</code> 单独地存储。</p><p><img src="../images/shape-1.svg" alt="shape-1" title="shape-1"></p><p><code>Shape</code> 包含所有的属性名称和属性特性，除了 <code>[[Value]]</code>。不过，<code>Shape</code> 包含了 <code>[[Value]]</code> 在 <code>JSObject</code> 上的偏移量，因此 JavaScript 引擎知道去哪里找到相应的值。 每个拥有相同 <code>Shape</code> 的 <code>JSObject</code> 都指向同一个 <code>Shape</code> 实例。现在，每个 <code>JSObject</code> 只需存储对象的值即可。</p><p><img src="../images/shape-2.svg" alt="shape-2" title="shape-2"></p><p>当我们有很多个对象时，好处也是显而易见的。不管有多少个对象，只要有相同的 <code>Shape</code>，<code>Shape</code> 和属性信息只需要存储一次。</p><p>所有的 JavaScript 引擎都用 Shapes 来优化，但叫法却不同：</p><ul><li>学术论文称之为 Hidden Classes（容易和 JavaScript 中的 Class 混淆）</li><li>V8 称之为 Maps（容易和 JavaScript 中的 Map 混淆）</li><li>Chakra 称之为 Types（容易和 JavaScript 中的动态类型与 typeof 混淆）</li><li>JavaScriptCore 称之为 Structures</li><li>SpiderMonkey 称之为 Shapes</li></ul><p>在这篇文章中，我们继续称之为 Shapes。</p><h3 id="过渡链与树（Transition-chains-and-trees）"><a href="#过渡链与树（Transition-chains-and-trees）" class="headerlink" title="过渡链与树（Transition chains and trees）"></a>过渡链与树（Transition chains and trees）</h3><p>如果一个对象有了一个确定的 <code>Shape</code>,然后又添加了一个属性，这会发生什么呢？JavaScript 引擎如何找到改变后的新 <code>Shape</code>？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object.x = <span class="number">5</span>;</span><br><span class="line">object.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>在 JavaScript 引擎中，这种 Shapes 结构称之为过渡链。如下：</p><p><img src="../images/shape-chain-1.svg" alt="shape-chain-1" title="shape-chain-1"></p><p>对象开始时没有任何属性，因此它会指向一个空的 <code>Shape</code>。下一条语句对象添加了一个属性 <code>&#39;x&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 0 的位置添加 5。下一条语句对象添加了一个属性 <code>&#39;y&#39;</code>，属性值为 5，因此对象指向包含属性 <code>&#39;x&#39;</code> 和 <code>&#39;y&#39;</code> 的 <code>Shape</code>，且在 <code>JSObject</code> 中偏移量为 1 的位置添加 6。</p><blockquote><p>注意： 属性的添加顺序会影响 <code>Shape</code>。例如，<code>{x: 4, y: 5}</code> 和 <code>{y: 5, x: 4}</code> 有不同的 <code>Shape</code>。</p></blockquote><p>我们没有必要让每个 <code>Shape</code> 都存储完整的属性表。相反，每个 <code>Shape</code> 只需要知道新引入的属性即可。例如，在这种情况下，我们没有必要在最后一个 <code>Shape</code> 中存储属性 <code>&#39;x&#39;</code> 的信息，因为它可以在链的上游中被查找到。要达此目的，每个 <code>Shape</code> 都会和先前的 <code>Shape</code> 链接。</p><p><img src="../images/shape-chain-2.svg" alt="shape-chain-2" title="shape-chain-2"></p><p>如果你在 JavaScript 代码中写了 <code>o.x</code>，JavaScript 引擎会沿着过渡链查找属性 <code>&#39;x&#39;</code>，直到发现引入 <code>&#39;x&#39;</code> 的 <code>Shape</code>。</p><p>但是，如果没法创建过渡链呢？例如，给两个空对象添加不同的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123;&#125;;</span><br><span class="line">object2.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，不得不进行分支处理，用过渡树（transition tree）取代过渡链。</p><p><img src="../images/shape-tree.svg" alt="shape-tree" title="shape-tree"></p><p>在这里，我们创建了一个空对象 <code>a</code>并给它添加了属性 <code>&#39;x&#39;</code>。最终得到以一个包含单个值的 <code>JSObject</code>和两种 <code>Shape</code>（空的 <code>Shape</code> 和仅有属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>）。</p><p>第二个例子也是以一个空对象 <code>b</code> 开始，但是添加的是属性 <code>&#39;y&#39;</code>。最终得到两条 <code>Shape</code> 链和三个 <code>Shape</code>。</p><p>这是否意味着总是以空 <code>Shape</code> 开头呢？不一定。</p><p>引擎对已经存在属性的对象字面两做了优化。来看两个例子，一个是从空的对象开始添加属性 <code>&#39;x&#39;</code>，一个是已经存在属性 <code>&#39;x&#39;</code> 的对象字面量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure><p>第一个例子中，我们从空的 <code>Shape</code> 过渡到包含属性 <code>&#39;x&#39;</code> 的 <code>Shape</code>，就如之前所看到的那样。</p><p>对于 <code>object2</code>，它直接生成包含属性 <code>&#39;x&#39;</code> 的对象而不是从空对象开始过渡。</p><p><img src="../images/empty-shape-bypass.svg" alt="empty-shape-bypass" title="empty-shape-bypass"></p><p>这个包含属性 <code>&#39;x&#39;</code> 的对象，以包含 <code>&#39;x&#39;</code> 的 <code>Shape</code> 开头，省去了空 <code>Shape</code> 这个步骤。至少 V8 和 SpiderMonkey 是这么做的。这种优化缩短了过渡链，使得创建对象更加高效。</p><p>Benedikt 的文章 <a href="https://medium.com/@bmeurer/surprising-polymorphism-in-react-applications-63015b50abc" rel="external nofollow noopener noreferrer" target="_blank">surprising polymorphism in React applications</a> 讨论了这些微妙之处是如何影响到实际性能的。</p><p>这有一个拥有属性 <code>&#39;x&#39;、</code>‘y’<code>、</code>‘z’` 的三维点对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123;&#125;;</span><br><span class="line">point.x = <span class="number">4</span>;</span><br><span class="line">point.y = <span class="number">5</span>;</span><br><span class="line">point.z = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>就如之前所学到的，在内存上，这回创建有三个 <code>Shape</code> 的对象（空 <code>Shape</code> 不计入）。访问对象的属性 <code>&#39;x&#39;</code>，例如，如果你在程序中写下了 <code>point.x</code>，JavaScript 引擎会顺着链表：它会从底部的 <code>Shape</code> 开始，一直向上查找，直到发现引入 <code>&#39;x&#39;</code> 的那个 <code>Shape</code>。</p><p><img src="../images/shapetable-1.svg" alt="shapetable-1" title="shapetable-1"></p><p>如果这种操作很频繁，就会显得很慢，尤其是一个对象有很多属性时。检索到需要的属性所花时间是 O（n），即线性的。为了提高检索速度，JavaScript 引擎加入了 <code>ShapeTable</code> 数据结构。<code>ShapeTable</code> 是个字典，它将属性和引入该属性的 <code>Shape</code> 关联起来。</p><p><img src="../images/shapetable-2.svg" alt="shapetable-2" title="shapetable-2"></p><p>且慢，我们又回到了字典查找……这不就是我们在引入 Shapes 之前的方式吗？为什么我们非要整出个 Shapes？</p><p>原因是 Shapes 可以实现另一种称之为内联缓存的优化。</p><h3 id="内联缓存（Inline-Caches-ICs-）"><a href="#内联缓存（Inline-Caches-ICs-）" class="headerlink" title="内联缓存（Inline Caches (ICs)）"></a>内联缓存（Inline Caches (ICs)）</h3><p>ICs 是 JavaScript 快速运行的关键因素。JavaScript 引擎可以利用 ICs 缓存对象的属性信息，从而减少属性查找的开销。</p><p>有个函数 <code>getX</code> ，接受一个对象并加载该对象上的属性 <code>x</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> o.x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在 JSC（JavaScriptCore） 中运行这个函数，它会生成以下的字节码：</p><p><img src="../images/ic-1.svg" alt="js-engines/ic-1" title="js-engines/ic-1"></p><p>第一条指令（<code>get_by_id</code>）是从参数 <code>arg1</code> 中加载属性 <code>x</code>，并将其值存储到 <code>loc0</code> 中。第二条指令是返回 <code>loc0</code> 中存储的值。</p><p>JSC 还在 <code>get_by_id</code> 指令中嵌入了内联缓存，它是由两个未初始化的插槽组成。</p><p><img src="../images/ic-2.svg" alt="ic-2" title="ic-2"></p><p>现在给函数 <code>getX</code> 传入对象 <code>{ x: &#39;a&#39; }</code>。如我们所知，这个对象有一个包含属性 <code>x</code> 的 <code>Shape</code>，这个 <code>Shape</code> 存储了属性 <code>x</code> 的偏移量和特性。当我们第一次执行函数时，<code>get_by_id</code> 指令会查找属性 <code>x</code> 并检索到值被存储在偏移量为 <code>0</code> 位置。</p><p><img src="../images/ic-3.svg" alt="ic-3" title="ic-3"></p><p>嵌在 <code>get_by_id</code> 指令中的内联缓存会记住 <code>Shape</code> 和属性的偏移量。</p><p><img src="../images/ic-4.svg" alt="ic-4" title="ic-4"></p><p>在下次函数执行时，内联缓存会对比 <code>Shape</code>，如果与之前的 <code>Shape</code> 相同，就只需要通过缓存的偏移量加载值。具体来说，如果 JavaScript 引擎发现对象的 <code>Shape</code> 和之前记录的 <code>Shape</code> 一样，那么它就再也不需要去查找属性信息了 —— 属性信息的查找就可以完全跳过。相比每次都去查找属性信息，这样的操作会显著地提升速度。</p><h3 id="高效存储数组（Storing-arrays-efficiently）"><a href="#高效存储数组（Storing-arrays-efficiently）" class="headerlink" title="高效存储数组（Storing arrays efficiently）"></a>高效存储数组（Storing arrays efficiently）</h3><p>对于数组，使用数组索引作为数组的属性是很常见的，属性对应的值称之为数组元素。为每个数组的每个数组元素存储属性特性是一种铺张浪费的行为。在 JavaScript 引擎中，数组的索引属性默认是可读、可枚举和可配置的，且数组元素是与命名属性分开存储的。</p><p>思考以下这个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">	<span class="string">'#jsconfeu'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>引擎存储了一个数组长度为 1 的数组，它指向一个包含偏移量和 <code>length</code> 特性的 <code>Shape</code>。</p><p><img src="../images/array-shape.svg" alt="array-shape" title="array-shape"></p><p>这个之前见过的很相似…… 但是数组元素的值存在哪呢？</p><p><img src="../images/array-elements.svg" alt="array-elements" title="array-elements"></p><p>每个数组都有一个独立的元素备份存储（elements backing store），包含着所有索引属性对应的值。JavaScript 引擎不必为数组元素存储属性特性，因为他们通常是可写、可枚举和可配置的，且数组索引可以替代偏移量的作用。</p><p>如果是不寻常的情况会怎样呢？比如，改变数组元素的属性特性（property attributes）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Please don’t ever do this!</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">	[],</span><br><span class="line">	<span class="string">'0'</span>,</span><br><span class="line">	&#123;</span><br><span class="line">		value: <span class="string">'Oh noes!!1'</span>,</span><br><span class="line">		writable: <span class="literal">false</span>,</span><br><span class="line">		enumerable: <span class="literal">false</span>,</span><br><span class="line">		configurable: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面的这个代码片段是给对象属性 <code>&#39;0&#39;</code> 的特性设置成非默认值。</p><p>像这种情况，JavaScript 引擎会将整个元素备份存储表示为一个字典，把数组索引和属性特性关联起来。</p><p><img src="../images/array-dictionary-elements.svg" alt="array-dictionary-elements" title="array-dictionary-elements"></p><p>即使数组中只有一个元素的属性特性是非默认值，元素备份存储也会进入缓慢低效的模式（从 Elements 模式 到 Dictionary Elements 模式）。避免用 <code>Object.defineProperty</code> 改变数组索引！</p><h2 id="看点（Take-aways）"><a href="#看点（Take-aways）" class="headerlink" title="看点（Take-aways）"></a>看点（Take-aways）</h2><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>始终以相同的方式初始化对象，这样就可以复用 <code>Shape</code>。</li><li>不要没事瞎折腾数组元素的属性特性，它们本可以高效地工作。</li></ol></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.yexiaochen.com/【译】JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/" title="【译】JavaScript engine fundamentals: Shapes and Inline Caches">http://www.yexiaochen.com/【译】JavaScript-engine-fundamentals-Shapes-and-Inline-Caches/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript-引擎/" rel="tag"><i class="fa fa-tag"></i> JavaScript 引擎</a> <a href="/tags/V8/" rel="tag"><i class="fa fa-tag"></i> V8</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/前端架构碎碎念/" rel="next" title="前端架构碎碎念"><i class="fa fa-chevron-left"></i> 前端架构碎碎念</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/【译】JavaScript-engine-fundamentals-optimizing-prototypes/" rel="prev" title="【译】JavaScript engine fundamentals: optimizing prototypes">【译】JavaScript engine fundamentals: optimizing prototypes <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-引擎原理：外形与内联缓存"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 引擎原理：外形与内联缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-引擎工作流"><span class="nav-number">1.2.</span> <span class="nav-text">JavaScript 引擎工作流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-引擎中的解释器-编译器流程"><span class="nav-number">1.3.</span> <span class="nav-text">JavaScript 引擎中的解释器/编译器流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-对象模型"><span class="nav-number">1.4.</span> <span class="nav-text">JavaScript 对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优化属性的访问"><span class="nav-number">1.5.</span> <span class="nav-text">优化属性的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外形（Shapes）"><span class="nav-number">1.5.1.</span> <span class="nav-text">外形（Shapes）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过渡链与树（Transition-chains-and-trees）"><span class="nav-number">1.5.2.</span> <span class="nav-text">过渡链与树（Transition chains and trees）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内联缓存（Inline-Caches-ICs-）"><span class="nav-number">1.5.3.</span> <span class="nav-text">内联缓存（Inline Caches (ICs)）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高效存储数组（Storing-arrays-efficiently）"><span class="nav-number">1.5.4.</span> <span class="nav-text">高效存储数组（Storing arrays efficiently）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#看点（Take-aways）"><span class="nav-number">1.6.</span> <span class="nav-text">看点（Take-aways）</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>