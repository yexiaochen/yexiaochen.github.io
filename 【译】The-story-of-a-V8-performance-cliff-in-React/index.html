<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="UGOd-4AuTAVn0sg3M96JPfTUNvXjmjV0uCNLkjuKX8Q"><meta name="baidu-site-verification" content="codeva-cs18pREvQ9"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="JavaScript 引擎,V8,"><link rel="alternate" href="/atom.xml" title="贪空" type="application/atom+xml"><meta name="description" content="前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 The story of a V8 performance cliff in React。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: opt"><meta name="keywords" content="JavaScript 引擎,V8"><meta property="og:type" content="article"><meta property="og:title" content="【译】The story of a V8 performance cliff in React"><meta property="og:url" content="https://yexiaochen.github.io/【译】The-story-of-a-V8-performance-cliff-in-React/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 The story of a V8 performance cliff in React。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: opt"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://yexiaochen.github.io/images/01-javascript-types.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/02-primitives-objects.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/03-primitives-objects-typeof.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/04-smi-vs-heapnumber.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/05-update-smi.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/06-update-heapnumber.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/07-heapnumbers.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/08-garbage-heapnumbers.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/09-mutableheapnumber.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/10-update-mutableheapnumber.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/11-mutableheapnumber-to-heapnumber.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/12-smi-no-boxing.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/13-shape.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/14-shape-transition.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/15-shape-deprecation.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/16-split-shape.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/17-shape-nonextensible.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/18-repro-shape-setup.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/19-orphaned-shape.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/20-fibernode-shape.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/21-orphan-islands.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/22-fix.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/23-fix-fibernode-shape-1.svg"><meta property="og:image" content="https://yexiaochen.github.io/images/24-fix-fibernode-shape-2.svg"><meta property="og:updated_time" content="2019-11-26T14:10:07.989Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【译】The story of a V8 performance cliff in React"><meta name="twitter:description" content="前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 The story of a V8 performance cliff in React。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: opt"><meta name="twitter:image" content="https://yexiaochen.github.io/images/01-javascript-types.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://yexiaochen.github.io/【译】The-story-of-a-V8-performance-cliff-in-React/"><title>【译】The story of a V8 performance cliff in React | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7503c6e413a2a7205320ec2396c811d0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yexiaochen.github.io/【译】The-story-of-a-V8-performance-cliff-in-React/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">【译】The story of a V8 performance cliff in React</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-29T21:35:57+08:00">2019-09-29 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-11-26T22:10:07+08:00">2019-11-26 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4,070 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">17 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是根据自己的理解翻译而来，如有疑惑可查看原文 <a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>。</p><p>本次暂定翻译三篇文章：</p><ol><li><a href="https://mathiasbynens.be/notes/shapes-ics" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: Shapes and Inline Caches</a>(Published 14th June 2018)</li><li><a href="https://mathiasbynens.be/notes/prototypes" rel="external nofollow noopener noreferrer" target="_blank">JavaScript engine fundamentals: optimizing prototypes</a>(Published 16th August 2018)</li><li><a href="https://v8.dev/blog/react-cliff" rel="external nofollow noopener noreferrer" target="_blank">The story of a V8 performance cliff in React</a>(Published 28 August 2019)</li></ol><h2 id="JavaScript-types"><a href="#JavaScript-types" class="headerlink" title="JavaScript types"></a>JavaScript types</h2><p>在 JavaScript 中，值有 8 总类型（当前）：<code>Number</code>，<code>String</code>，<code>Symbol</code>，<code>BigInt</code>，<code>Boolean</code>，<code>Undefined</code>，<code>Null</code>，<code>Object</code>。</p><p><img src="../images/01-javascript-types.svg" alt="01-javascript-types" title="01-javascript-types"></p><p>除了一个明显的例外，这些类型都可以用 <code>typeof</code> 直接查看。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'foo'</span>;</span><br><span class="line"><span class="comment">// → 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="comment">// → 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span>;</span><br><span class="line"><span class="comment">// → 'bigint'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// → 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// → 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// → 'object' 🤔</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="comment">// → 'object'</span></span><br></pre></td></tr></table></figure><p><code>typeof null</code> 返回的是 <code>&#39;object&#39;</code>，而不是 <code>&#39;null&#39;</code>，要了解为什么，首先要把所有的 JavaScript 类型分成两组：</p><ul><li>objects(即，对象类型)</li><li>primitives(即，非对象类型)</li></ul><p>照此来说，<code>null</code> 表示「没有对象」，而 <code>undefined</code> 表示 「没有值」。</p><p><img src="../images/02-primitives-objects.svg" alt="02-primitives-objects" title="02-primitives-objects"></p><p>按照这个思路，Brendan Eich 在设计 JavaScript 时，受到 Java 的影响，使得右手边的值执行 <code>typeof</code> 后都返回 <code>object</code>。因此，即便规范里有 <code>Null</code> 类型，<code>typeof null === &#39;object&#39;</code> 依然成立。</p><p><img src="../images/03-primitives-objects-typeof.svg" alt="03-primitives-objects-typeof" title="03-primitives-objects-typeof"></p><h2 id="Value-representation"><a href="#Value-representation" class="headerlink" title="Value representation"></a>Value representation</h2><p>JavaScript 引擎能够在内存中表示任意的 JavaScript 值。然而，值得注意的是，JavaScript 引擎在内存中值类型的表现形式是不同于 JavaScript 中的类型描述。</p><p>例如，42，在 JavaScript 中是 <code>number</code> 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// → 'number'</span></span><br></pre></td></tr></table></figure><p>在内存中有好多种方式表示整数，例如 42:</p><table><thead><tr><th style="text-align:center">representation</th><th style="text-align:center">bits</th></tr></thead><tbody><tr><td style="text-align:center">two’s complement 8-bit</td><td style="text-align:center"><code>0010 1010</code></td></tr><tr><td style="text-align:center">two’s complement 32-bit</td><td style="text-align:center"><code>0000 0000 0000 0000 0000 0000 0010 1010</code></td></tr><tr><td style="text-align:center">packed binary-coded decimal (BCD)</td><td style="text-align:center"><code>0100 0010</code></td></tr><tr><td style="text-align:center">32-bit IEEE-754 floating-point</td><td style="text-align:center"><code>0100 0010 0010 1000 0000 0000 0000 0000</code></td></tr><tr><td style="text-align:center">64-bit IEEE-754 floating-point</td><td style="text-align:center"><code>0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</code></td></tr></tbody></table><p>ECMAScript 将数字标准化为 64 位浮点值，也称为双精度浮点或 Float64。但是，这并不意味着 JavaScript 引擎总是以 Float64 的形式存储数字 —— 这么做会很低效。引擎会选择其它的内部表现形式，除非观测到的行为完全匹配 Float64。</p><p>在真实的 JavaScript 应用中，大多数数字都是合法的 ECMAScript <a href="https://tc39.es/ecma262/#array-index" rel="external nofollow noopener noreferrer" target="_blank">数组索引</a>，即，属于 0 ~ 2³²−2 范围内的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>]; <span class="comment">// Smallest possible array index.</span></span><br><span class="line">array[<span class="number">42</span>];</span><br><span class="line">array[<span class="number">2</span>**<span class="number">32</span><span class="number">-2</span>]; <span class="comment">// Greatest possible array index.</span></span><br></pre></td></tr></table></figure><p>JavaScript 引擎会为数字选择最优存储的表达形式以此优化数组元素的访问效率。对于处理器的内存访问操作，数组索引必须是二进制补码的形式。用 Float64 表示数组是一种很费性能的行为，因为每次访问数组元素引擎都需要在 Float64 和二进制补码之间转换。</p><p>32 位的二进制补码表达形式对数组操作是很有用的。通常来说，处理器执行整型操作比执行浮点型操作要快得多。所以说，下面的例子，第一个循环比第二个循环快两倍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// fast 🚀</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0.1</span>; i &lt; <span class="number">1000.1</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// slow 🐌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作符也是一样。在下面的代码中，模运算符的性能取决于处理的是否是整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remainder = value % divisor;</span><br><span class="line"><span class="comment">// Fast 🚀 if `value` and `divisor` are represented as integers,</span></span><br><span class="line"><span class="comment">// slow 🐌 otherwise.</span></span><br></pre></td></tr></table></figure><p>如果两个操作数都是整数的形式，CPU 就可以高效地计算出结果。如果除数是 2 的倍数，V8 还会有额外的捷径。对于值是浮点型的形式，计算过程会变得复杂耗时。</p><p>因为整型操作的执行速度通常比浮点型要快很多，所以，引擎就应该使用二进制补码来表示所有的整型和整型操作的结果。遗憾的是，那是有悖于 ECMAScript 规范的！ECMAScript 采用了 Float64，某些整数运算实际上产生的是浮点型。在下面这种情况下，对于能够产生正确的结果很重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Float64 has a safe integer range of 53 bits. Beyond that range,</span></span><br><span class="line"><span class="comment">// you must lose precision.</span></span><br><span class="line"><span class="number">2</span>**<span class="number">53</span> === <span class="number">2</span>**<span class="number">53</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 supports negative zeros, so -1 * 0 must be -0, but</span></span><br><span class="line"><span class="comment">// there’s no way to represent negative zero in two’s complement.</span></span><br><span class="line"><span class="number">-1</span>*<span class="number">0</span> === <span class="number">-0</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 has infinities which can be produced through division</span></span><br><span class="line"><span class="comment">// by zero.</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span> === <span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"><span class="number">-1</span>/<span class="number">0</span> === -<span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">// → true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Float64 also has NaNs.</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> === <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><p>左边的值都是整型，而右边的却是浮点型。以上的操作在使用 32 位二进制补码的形式是没法正确执行的。JavaScript 引擎必须确保整型操作被合理地处理以生成想要的 Float64 结果。</p><p>对于在 31 位有符号整数范围内的小整数，V8 有特殊的表示形式，称为 Smi。对于非 Smi 的数值会被表示为 HeapObject，它是内存中某些实体的地址。我们使用一种特殊的 HeapObject，即所谓的 HeapNumber，来表示超出 Smi 范围的数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">-(<span class="number">2</span>**<span class="number">30</span>)<span class="number">-1</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  -(<span class="number">2</span>**<span class="number">30</span>) <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">-42</span> <span class="comment">// Smi</span></span><br><span class="line">        <span class="number">-0</span> <span class="comment">// HeapNumber</span></span><br><span class="line">         <span class="number">0</span> <span class="comment">// Smi</span></span><br><span class="line">       <span class="number">4.2</span> <span class="comment">// HeapNumber</span></span><br><span class="line">        <span class="number">42</span> <span class="comment">// Smi</span></span><br><span class="line">   <span class="number">2</span>**<span class="number">30</span><span class="number">-1</span> <span class="comment">// Smi</span></span><br><span class="line">     <span class="number">2</span>**<span class="number">30</span> <span class="comment">// HeapNumber</span></span><br><span class="line">  <span class="literal">Infinity</span> <span class="comment">// HeapNumber</span></span><br><span class="line">       <span class="literal">NaN</span> <span class="comment">// HeapNumber</span></span><br></pre></td></tr></table></figure><p>如上所示，某些数字被表示为 Smi，其它数字被表示为 HeapNumber。V8 对 Smi 专门优化，因为在真实的 JavaScript 编程中，小的整数是非常普遍的。Smi 没必要在内存中分配专用的实体，而且可以素快速地整型操作。</p><h2 id="Smi-vs-HeapNumber-vs-MutableHeapNumber"><a href="#Smi-vs-HeapNumber-vs-MutableHeapNumber" class="headerlink" title="Smi vs. HeapNumber vs. MutableHeapNumber"></a>Smi vs. HeapNumber vs. MutableHeapNumber</h2><p>有以下对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  x: <span class="number">42</span>,  <span class="comment">// Smi</span></span><br><span class="line">  y: <span class="number">4.2</span>, <span class="comment">// HeapNumber</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>x 的值 42 被编程为 Smi，因此它被存储在对象里。另一方面值 4.2 需要一个独立的实例（空间）来保存这个值，并且这个对象会指向这个实体。</p><p><img src="../images/04-smi-vs-heapnumber.svg" alt="04-smi-vs-heapnumber" title="04-smi-vs-heapnumber"></p><p>运行以下 JavaScript 代码片段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o.x += <span class="number">10</span>;</span><br><span class="line"><span class="comment">// → o.x is now 52</span></span><br><span class="line">o.y += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → o.y is now 5.2</span></span><br></pre></td></tr></table></figure><p>这种情况下，x 的值可以就地更新，因为新的值 52 也在 Smi 的范围内。</p><p><img src="../images/05-update-smi.svg" alt="05-update-smi" title="05-update-smi"></p><p>然而，新的值 <code>y=5.2</code> 不在 Smi 范围内且不同于之前的值 4.2，因此 V8 为 y 重新分配了新的 HeapNumber 实体。</p><p><img src="../images/06-update-heapnumber.svg" alt="06-update-heapnumber" title="06-update-heapnumber"></p><p>HeapNumber 是不可变的，它使得某些优化成为可能。例如，我们把 y 赋值给 x：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.x = o.y;</span><br><span class="line"><span class="comment">// → o.x is now 5.2</span></span><br></pre></td></tr></table></figure><p>我们只需要把它连接到同一个 HeapNumber 上而不是重新分配一个新的实体（空间）。</p><p><img src="../images/07-heapnumbers.svg" alt="07-heapnumbers" title="07-heapnumbers"></p><p>HeapNumber 不可变也存在缺点，如果更新的值经常不在 Smi 的范围内，它就会变慢，例如下面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a `HeapNumber` instance.</span></span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">0.1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// Create an additional `HeapNumber` instance.</span></span><br><span class="line">  o.x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行创建了一个 HeapNumber 实例，其初始值为 0.1。在循环体中值从 1.1，2.1，3.1，4.2 变到 5.1，一共创建了 6 个 HeapNumber 实例，其中 5 个会在循环结束后变没有任何用处。</p><p><img src="../images/08-garbage-heapnumbers.svg" alt="08-garbage-heapnumbers" title="08-garbage-heapnumbers"></p><p>为了避免这种情况，作为优化，V8 提供了就地更新非 Smi 数值的方法。当一个字段对应着非 Smi 的数值，V8 会在 shape 上将这个字段标记为 Double，并分配一个保存 Float64 的 MutableHeapNumber 实体。</p><p><img src="../images/09-mutableheapnumber.svg" alt="09-mutableheapnumber" title="09-mutableheapnumber"></p><p>当字段里的值发生变化时，V8 不必分配一个新的 HeapNumber，而是在 MutableHeapNumber 实体中就地更新。</p><p><img src="../images/10-update-mutableheapnumber.svg" alt="10-update-mutableheapnumber" title="10-update-mutableheapnumber"></p><p>然而，需要注意的是，MutableHeapNumber 中的值是可以改变的，所以值不应该传来传去的。</p><p><img src="../images/11-mutableheapnumber-to-heapnumber.svg" alt="11-mutableheapnumber-to-heapnumber" title="11-mutableheapnumber-to-heapnumber"></p><p>例如，你把 <code>o.x</code> 赋值给变量 y，你不希望 y 会随着 <code>o.x</code> 的改变而改变！所以在给 y 赋值前，必须将 <code>o.x</code> 的值重新包装成 HeapNumber。</p><p>对于浮点型，V8 已经默默地包装了一下。但是，对于小的整数也采用和 MutableHeapNumber 相同的方法，就会显得浪费，因为 Smi 本就是一种更高效的表现形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// → no “boxing” for `x` in object</span></span><br><span class="line"></span><br><span class="line">object.x += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// → update the value of `x` inside object</span></span><br></pre></td></tr></table></figure><p>为了避免低效率，我们会在 shape 上为小整数对应的字段上标记 Smi，并且会原地更新数值，只要这个数值在 Smi 范围内。</p><p><img src="../images/12-smi-no-boxing.svg" alt="12-smi-no-boxing" title="12-smi-no-boxing"></p><h2 id="Shape-deprecations-and-migrations"><a href="#Shape-deprecations-and-migrations" class="headerlink" title="Shape deprecations and migrations"></a>Shape deprecations and migrations</h2><p>如果一个字段里包含的值在 Smi 范围内，之后又不属于 Smi 范围，这中间发生了什么？现有两个对象，它们的 x 属性值都是 Smi 表示形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// → objects have `x` as `Smi` field now</span></span><br><span class="line"></span><br><span class="line">b.x = <span class="number">0.2</span>;</span><br><span class="line"><span class="comment">// → `b.x` is now represented as a `Double`</span></span><br><span class="line"></span><br><span class="line">y = a.x;</span><br></pre></td></tr></table></figure><p>这两个对象都指向同一个 shape，x 属性特性 Representation 被标记为 Smi：</p><p><img src="../images/13-shape.svg" alt="13-shape" title="13-shape"></p><p>当 <code>b.x</code> 变成 Double 形式，V8 会创建一个新的 shape，属性 x 的 Representation 被标记为 Double 且指向之前的空 shape。V8 也会为属性 x 分配一个 MutableHeapNumber 实体用来保存值 0.2。然后让对象 b 指向新创建的 shape 并且内部偏移量为 0 的位置指向刚分配的 MutableHeapNumber 实体。最后，我们把旧的 shape 标记为废弃的，并断开与过渡树（transition tree）的链接。这就完成了从空 shape 到新 shape 的过渡。</p><p><img src="../images/14-shape-transition.svg" alt="14-shape-transition" title="14-shape-transition"></p><p>我们不能同时完全删除旧 shape，因为对象 a 还在使用，而且短时间找到所有链接到旧 shape 的对象并更新它们，对 V8 来说是笔很大的开销。相反，V8 不急着处理：只有在改变对象 a 的时候才开始迁移到新的 shape。最终，标记为废弃的 shape 会慢慢淡出视野并被垃圾回收机制抹除。</p><p><img src="../images/15-shape-deprecation.svg" alt="15-shape-deprecation" title="15-shape-deprecation"></p><p>更棘手的问题是，如果对象上属性特性 Representation 发生变化的属性不是 shape 链上的最后一个，又会发生什么呢？</p><p><img src="../images/16-split-shape.svg" alt="16-split-shape" title="16-split-shape"></p><p>从产生分支的 shape 开始，我们为属性 y 创建了一个新的过渡链且 y 被标记为 Double。我们在使用新的过渡链时，也就意味着旧的过渡链将被废弃。在最后一步，我们把实例 o 迁移到新的 shape 并用 MutableHeapNumber 保存 y 的值。就这样，新对象不再使用老的那一套，一旦旧的 shape 上的链接都被移除掉，旧 shape 也会从过渡树上消失。</p><h2 id="Extensibility-and-integrity-level-transitions"><a href="#Extensibility-and-integrity-level-transitions" class="headerlink" title="Extensibility and integrity-level transitions"></a>Extensibility and integrity-level transitions</h2><p><code>Object.preventExtensions()</code> 防止将新属性添加到对象中。如果你这么做了，它将会抛异常。（如果是在非严格模式下，它不会抛异常而是默认什么都不做。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br></pre></td></tr></table></figure><p><code>Object.seal</code> 与 <code>Object.preventExtensions</code> 相似，但是它会把所有的属性标记为不可配置，这就意味着你不能删除它们，或改变他们的可枚举性，可配置性，可写性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br></pre></td></tr></table></figure><p><code>Object.freeze</code> 与 <code>Object.seal</code> 相似，但是它将所有属性标记为不可写以防止属性值被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(object);</span><br><span class="line">object.y = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot add property y;</span></span><br><span class="line"><span class="comment">//            object is not extensible</span></span><br><span class="line"><span class="keyword">delete</span> object.x;</span><br><span class="line"><span class="comment">// TypeError: Cannot delete property x</span></span><br><span class="line">object.x = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Cannot assign to read-only property x</span></span><br></pre></td></tr></table></figure><p>让我们来思考一个具体的例子，有两个都只有属性 y 的对象，并阻止第二个对象有任何的扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(b);</span><br></pre></td></tr></table></figure><p>就如我们所知的，从空的 shape 过渡到一个有属性 x （被标记为 Smi）的新 shape 上。当我们阻止 b 的扩展时，我们会过渡到标记为不可扩展的新 shape 上。这个新 shape 没有任何属性，仅仅作为一个标识。</p><p><img src="../images/17-shape-nonextensible.svg" alt="17-shape-nonextensible" title="17-shape-nonextensible"></p><p>注意，我们不能就地更新有 x 的 shape，因为对象 a 依然是可扩展的。</p><h2 id="The-React-performance-issue"><a href="#The-React-performance-issue" class="headerlink" title="The React performance issue"></a>The React performance issue</h2><p>让我们用以上学到的知识来解析下 <a href="https://github.com/facebook/react/issues/14365" rel="external nofollow noopener noreferrer" target="_blank">the recent React issue #14365</a>。简单重现这个 bug：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(o);</span><br><span class="line">o.y = <span class="number">0.2</span>;</span><br></pre></td></tr></table></figure><p>有一个拥有两个字段的对象，而且它们的属性特性 Representation 被标记为 Smi。我们阻止对象的进一步扩展，但最终我们还是强制改变第二字段的属性特性 Representation 的值（Double）。</p><p>就如之前学到的，大致流程如下：</p><p><img src="../images/18-repro-shape-setup.svg" alt="18-repro-shape-setup" title="18-repro-shape-setup"></p><p>每个属性的特性 Representation 都被标记为 Smi，并最终过渡到被标记为不可扩展的 shape 上。</p><p>我们需要将 y 的属性特性 Representation 标记为 Double，这意味着我们需要从引入 y 属性之前的 shape 开始。在这个例子中，就是引入 x 属性的那个 shape。但是， V8 会很困惑，因为当前的 shape 是不可扩展的，而找到的 shape 却是可扩展的。V8 不知道怎么去处理这个过渡树。因此，V8 不再试图搞清楚这些关系，而是创建了一个独立的 shape，这个 shape 和先前的过渡树没有任何关联，而且也不被任何其它对象共享。可以把它当作孤立的 shape：</p><p><img src="../images/19-orphaned-shape.svg" alt="19-orphaned-shape" title="19-orphaned-shape"></p><p>你可以想象，如果有很多对象的话，这样会变得很糟糕，因为整个 shape 系统已经失去价值。</p><p>在 React 的案例中，当开始分析数据时，FiberNode 上的一些字段需要记录时间戳。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>这些字段（比如，actualStartTime）初始化值是 0 或 -1，因此属性特性 Representation 为 Smi。但是，之后由 <code>performance.now()</code> 生成的浮点型数值被保存在这些字段中，因此属性特性 Representation 被标记为 Double。除此之外，React 还阻止 FiberNode 实例扩展属性。</p><p>刚开始的状况如下：</p><p><img src="../images/20-fibernode-shape.svg" alt="20-fibernode-shape" title="20-fibernode-shape"></p><p>如预期，两个实例共享着 shape 树。但是之后，一旦你存储了真实的时间戳，V8 就会无从下手：</p><p><img src="../images/21-orphan-islands.svg" alt="21-orphan-islands" title="21-orphan-islands"></p><p>V8 先后给 node1，node2 分别分配了独立的 shape，且它们之间没有任何关联。真实中的 React 应用有着数万个这样的 FiberNode。你可以想象，这种情况将会严重影响到 V8 的性能。</p><p>幸运的是，这个<a href="https://chromium-review.googlesource.com/c/v8/v8/+/1442640/" rel="external nofollow noopener noreferrer" target="_blank">问题</a>在 <a href="https://v8.dev/blog/v8-release-74" rel="external nofollow noopener noreferrer" target="_blank">V8 v7.4</a> 中解决了。研发人员找到了改变属性特性 Representation 的方法，V8 终于知道它该怎么做了：</p><p><img src="../images/22-fix.svg" alt="22-fix" title="22-fix"></p><p>两个 FiberNode 实例指向不可扩展的 shape，shape 中的 <code>actualStartTime</code> 被标记为 Smi。当 <code>node1.actualStartTime</code> 被分配新的值时，将会生成一条新的过渡链，而且之前的过渡链会被标记为废弃的。</p><p><img src="../images/23-fix-fibernode-shape-1.svg" alt="23-fix-fibernode-shape-1" title="23-fix-fibernode-shape-1"></p><p>可以注意到，现在的过渡链可以正确的过渡转移。</p><p><img src="../images/24-fix-fibernode-shape-2.svg" alt="24-fix-fibernode-shape-2" title="24-fix-fibernode-shape-2"></p><p>当 <code>node2.actualStartTime</code> 也被重新分配时，所有的链接都指向了新的 shape，过渡树中废弃的部分将会被垃圾回收机制清除。</p><p>React 团队将 FiberNode 所有关于时间的字段都改成了 Double 形式从而缓解这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiberNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// Force `Double` representation from the start.</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="built_in">Number</span>.NaN;</span><br><span class="line">    <span class="comment">// Later, you can still initialize to the value you want:</span></span><br><span class="line">    <span class="keyword">this</span>.actualStartTime = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node1 = <span class="keyword">new</span> FiberNode();</span><br><span class="line"><span class="keyword">const</span> node2 = <span class="keyword">new</span> FiberNode();</span><br></pre></td></tr></table></figure><p>由 React 具体的 Bug 引出了 V8 特有的问题，通常来说，开发者不必对某个版本的 JavaScript 引擎做优化。不过，当时事情向不好的方向发展时，我们也不会束手无策。</p><p>要知道 JavaScript 引擎在幕后做了很多事，尽可能的不要去混合类型。例如，给一个数字字段初始化为 null，这样做的话会使得一些优化化为泡影，而且可读性降低。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don’t do this!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x = <span class="literal">null</span>;</span><br><span class="line">  y = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p.x = <span class="number">0.1</span>;</span><br><span class="line">p.y = <span class="number">402</span>;</span><br></pre></td></tr></table></figure><p>换句话说，写可读性代码，性能自然会紧跟其后！</p><h2 id="Take-aways"><a href="#Take-aways" class="headerlink" title="Take-aways"></a>Take-aways</h2><p>本文覆盖了一下几点：</p><ol><li>JavaScript 区分了 primitives 和 objects，而且 typeof 不靠谱。</li><li>即使是相同类型的值也会有不同的表达形式。</li><li>JavaScript 引擎会为每个属性找到最优的表达形式。</li><li>讨论了 V8 处理 shape 的废弃，迁移和可扩展。</li></ol><p>基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：</p><ol><li>以相同的方式初始化对象类型，这样 shape 系统会更高效。</li><li>为你的字段选择合理的值（「Representation」：Smi 或 非 Smi）。</li></ol></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://yexiaochen.github.io/【译】The-story-of-a-V8-performance-cliff-in-React/" title="【译】The story of a V8 performance cliff in React">https://yexiaochen.github.io/【译】The-story-of-a-V8-performance-cliff-in-React/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/JavaScript-引擎/" rel="tag"><i class="fa fa-tag"></i> JavaScript 引擎</a> <a href="/tags/V8/" rel="tag"><i class="fa fa-tag"></i> V8</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/【译】JavaScript-engine-fundamentals-optimizing-prototypes/" rel="next" title="【译】JavaScript engine fundamentals: optimizing prototypes"><i class="fa fa-chevron-left"></i> 【译】JavaScript engine fundamentals: optimizing prototypes</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/读《乌合之众》/" rel="prev" title="读《乌合之众》">读《乌合之众》 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-types"><span class="nav-number">2.</span> <span class="nav-text">JavaScript types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Value-representation"><span class="nav-number">3.</span> <span class="nav-text">Value representation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Smi-vs-HeapNumber-vs-MutableHeapNumber"><span class="nav-number">4.</span> <span class="nav-text">Smi vs. HeapNumber vs. MutableHeapNumber</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shape-deprecations-and-migrations"><span class="nav-number">5.</span> <span class="nav-text">Shape deprecations and migrations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extensibility-and-integrity-level-transitions"><span class="nav-number">6.</span> <span class="nav-text">Extensibility and integrity-level transitions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-React-performance-issue"><span class="nav-number">7.</span> <span class="nav-text">The React performance issue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Take-aways"><span class="nav-number">8.</span> <span class="nav-text">Take-aways</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>