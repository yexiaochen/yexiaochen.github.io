<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="baidu-site-verification" content="dil57BBbBc"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="YH32omENY7b_BdEuIWv46jSBK-0Vyw_dWbJTGNBblT0"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="函数式编程,"><meta name="description" content="读后感很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。《Functional-Light JavaScript》（中文翻译版《JavaScript 轻量级函数式编程》）自称是轻量级的，抛开了概"><meta name="keywords" content="函数式编程"><meta property="og:type" content="article"><meta property="og:title" content="读《JavaScript 轻量级函数式编程》"><meta property="og:url" content="http://www.yexiaochen.com/读《JavaScript-轻量级函数式编程》/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="读后感很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。《Functional-Light JavaScript》（中文翻译版《JavaScript 轻量级函数式编程》）自称是轻量级的，抛开了概"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://www.yexiaochen.com/images/FP.png"><meta property="og:image" content="http://www.yexiaochen.com/images/stack_heap.png"><meta property="og:image" content="http://www.yexiaochen.com/images/tailCall.png"><meta property="og:updated_time" content="2019-11-09T09:23:57.031Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="读《JavaScript 轻量级函数式编程》"><meta name="twitter:description" content="读后感很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。《Functional-Light JavaScript》（中文翻译版《JavaScript 轻量级函数式编程》）自称是轻量级的，抛开了概"><meta name="twitter:image" content="http://www.yexiaochen.com/images/FP.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.yexiaochen.com/读《JavaScript-轻量级函数式编程》/"><title>读《JavaScript 轻量级函数式编程》 | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ad8db08f31eca01d048b60d4299de095";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.yexiaochen.com/读《JavaScript-轻量级函数式编程》/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">读《JavaScript 轻量级函数式编程》</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-19T17:29:16+08:00">2019-10-19 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-11-09T17:23:57+08:00">2019-11-09 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5,161 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">21 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。<a href="https://github.com/getify/Functional-Light-JS" rel="external nofollow noopener noreferrer" target="_blank">《Functional-Light JavaScript》</a>（中文翻译版<a href="https://wizardforcel.gitbooks.io/functional-light-js/content/" rel="external nofollow noopener noreferrer" target="_blank">《JavaScript 轻量级函数式编程》</a>）自称是轻量级的，抛开了概念的讲解，从为什么用，怎么用，最终呈现什么等几个方面带我们重新认识了函数这个基础且重要的概念。</p><h2 id="为什么函数式编程"><a href="#为什么函数式编程" class="headerlink" title="为什么函数式编程"></a>为什么函数式编程</h2><p>当下有三种编程范式，结构化编程、面向对象编程和函数式编程。虽然函数式编程是近些年才采用的编程范式，但是它的发明却是最早的。函数式编程概念是基于 𝛌 演算的直接衍生物，𝛌 演算法的一个核心思想是不变性。故，理论上讲，在函数式编程语言中应该不存在赋值语句的。</p><p>函数式编程的原则可以使得我们写出的代码是可读、可信任的，但这并不代表它是容易理解的。声明式的风格可以让我们知道程序是干什么的，但是要写出这样的程序却不是很容易理解的，起码对于刚接触函数式编程的人来说。</p><p>在维护代码的过程中，大部分时间是用来阅读和理解代码。有时候我们需要小心翼翼地阅读每一行代码，生怕某一个不为人知的骚操作会引发了一些列的 bug；有时候也需要在不同函数调用中了解程序的意图。总之，函数式编程的一些原则可以让我们写出可读性高、可验证的代码。当然，即便掌握了函数式编程，也并不意味着你一定得用它。</p><blockquote><p>最好的代码是可读性高的代码，因为它在正确的（理想主义）和必然的（正确的）之间寻求到了恰到好处的平衡。</p></blockquote><center><br><br><img src="../images/FP.png" alt="FP"><br><br></center><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>在数学中，函数总是获取一些输入值，然后返回一个输出值，输入值和输出值存在某种关系的映射。在函数式编程中使用的就是数学意义上的函数，接受输入值，明确 <code>return</code> 值。</p><p>函数通常是这个模样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    &#125;</span><br><span class="line">foo.length  <span class="comment">// 3</span></span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><code>foo.length</code> 是函数期望的参数个数，通常就是形參个数。但是，并不要求实参和形參的个数相同，在函数内部可以通过 <code>arguments</code> 查看所有入參（箭头函数无此参数）。</p><p>使用 ES6 中的解构可以轻松给变量绑定入參的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[x, y, ...args]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> y = params[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> args = params.slice(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上对比，我们可以看出，声明式代码通常比命令式代码更干净。所以只要有可能，还是尽可能使用声明式和自解释的代码。</p><p>有时候函数会根据不同的输入值来重载不同的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> y == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种设计虽然暂时很方便，但是对以后的功能添加或修改会带来很大的麻烦。</p><p>在上面已经提到函数要有明确的 <code>return</code> 值，如果函数内部改变了外层作用域的变量或引用类型的入參，那么这个函数就有了副作用的，对该函数外的环境造成了污染。我们希望函数是个没有副作用的函数，即纯函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[i]) list[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        total = total + list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [ <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, , <span class="number">84</span> ];</span><br><span class="line"></span><br><span class="line">sum( nums );            <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><p>函数可以接受并返回任何类型的值，当这种类型的值恰好是函数时，它就叫高阶函数。而真正高阶的用法，就是闭包，它可以记录并且访问作用于外的变量，甚至该函数在不同作用域中被执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runningCounter</span>(<span class="params">start</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span>(<span class="params">increment = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">        val = val + increment;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score = runningCounter( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">score();                <span class="comment">// 1</span></span><br><span class="line">score();                <span class="comment">// 2</span></span><br><span class="line">score( <span class="number">13</span> );            <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>闭包中保存的变量并不会在函数执行后自动销毁，只要内部函数依然存在对变量的引用，变量就会一直保留。在函数式编程中，闭包是最重要的基础，所以，这个概念一定要理解。</p><p>还有的函数是没有名字的，这种函数称之为匿名函数，使用最多的是立即执行表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我是 IIFE!</span></span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>命名函数的好处有很多，可以在堆栈中方便调试，可以通过名字引用自身等。但并不是所有的函数都可以命名的，箭头函数可以说是十分简洁，可以使用最简单的符号来表示一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.map( <span class="function"><span class="params">person</span> =&gt;</span> person.nicknames[<span class="number">0</span>] || person.firstName );</span><br></pre></td></tr></table></figure><p>箭头函数除了写法简洁之外，还有一个可以称之为好处的便是 <code>this</code>。箭头函数中的 <code>this</code> 是基于作用域的，是可以预测的。而对于普通函数，<code>this</code> 是动态绑定的，是基于调用者的。不管是哪一种 <code>this</code>， 我们还是希望能够显式地表示上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.x + ctx.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> context = &#123;</span><br><span class="line">    x: <span class="number">1</span>,</span><br><span class="line">    y: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sum( context );</span><br></pre></td></tr></table></figure><h2 id="函数的输入"><a href="#函数的输入" class="headerlink" title="函数的输入"></a>函数的输入</h2><p>在程序中往往将不变的封装起来，变化的隔离开来。很多时候不变的包括一些预设的参数。</p><p>首先封装一个请求函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url,data,callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的请求，有不同的 url 或参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤二：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPerson</span>(<span class="params">data,cb</span>) </span>&#123;</span><br><span class="line">    ajax( <span class="string">"http://some.api/person"</span>, data, cb );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrder</span>(<span class="params">data,cb</span>) </span>&#123;</span><br><span class="line">    ajax( <span class="string">"http://some.api/order"</span>, data, cb );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>url 就是预设的参数，而剩余的参数在调用的时候传入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤三：</span></span><br><span class="line">getPerson( &#123; <span class="attr">user</span>: CURRENT_USER_ID &#125;, cb );</span><br></pre></td></tr></table></figure><p>仔细观察步骤二，代码似乎还可以提炼下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤二：</span></span><br><span class="line"><span class="keyword">var</span> partial = <span class="function">(<span class="params">fn, ...presetArgs</span>) =&gt;</span></span><br><span class="line">                (...laterArgs) =&gt; </span><br><span class="line">                    fn(...presetArgs, ...laterArgs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPerson = partial(ajax, <span class="string">"http://some.api/person"</span>);</span><br><span class="line"><span class="keyword">var</span> getOrder = partial(ajax, <span class="string">"http://some.api/order"</span>);</span><br></pre></td></tr></table></figure><p>步骤二的转换就是偏函数的应用，它是通过预设参数的方式来减少入參的数量。如果颠倒入參的顺序，就成了右偏函数。</p><p>同样是对函数输入管理的技术，即柯里化，该技术将一个接受多个实参的函数拆解成连续的链式函数，每个链式函数接受单一实参并返回接受下一个实参的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        sum += args[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curry =</span><br><span class="line">    (fn, arity = fn.length, nextCurried) =&gt;</span><br><span class="line">        (nextCurried = <span class="function"><span class="params">prevArgs</span> =&gt;</span></span><br><span class="line">            nextArg =&gt; &#123;</span><br><span class="line">                <span class="keyword">var</span> args = prevArgs.concat( [nextArg] );</span><br><span class="line">                <span class="keyword">if</span> (args.length &gt;= arity) &#123;</span><br><span class="line">                    <span class="keyword">return</span> fn( ...args );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextCurried( args );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )( [] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5 用来指定需要链式调用的次数)</span></span><br><span class="line"><span class="keyword">var</span> curriedSum = curry( sum, <span class="number">5</span> );</span><br><span class="line">curriedSum( <span class="number">1</span> )( <span class="number">2</span> )( <span class="number">3</span> )( <span class="number">4</span> )( <span class="number">5</span> );</span><br></pre></td></tr></table></figure><p>从以上的代码可以发现，无论是偏函数还是柯里化，都是收齐所有的实参后才执行原函数，也就是说没必要一次性传入所有的参数，而且柯里化这种只接受单一参数的特性在后面的组合函数中也起着很重要的作用。</p><p>函数式编程可以说在参数上下了很大的功夫，甚至还有种称之为无形參的风格，其目的就是移除非必要的形參到实参之间的映射。无形參风格是否提高了代码的可读性，有没有必要使用无形參风格，还需要你自己去定夺。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( <span class="function"><span class="keyword">function</span> <span class="title">mapper</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> double( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无形參风格；</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].map( double );</span><br></pre></td></tr></table></figure><h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><p>函数组合，就是把上一个函数的输出值作为下一个函数的输入值，并以此持续下去。</p><p>看个例子，将一句话拆分为单词数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转小写，过虑出单词；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">words</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>( str )</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .split( <span class="regexp">/\s|\b/</span> )</span><br><span class="line">        .filter( <span class="function"><span class="keyword">function</span> <span class="title">alpha</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\w]+$/</span>.test( v );</span><br><span class="line">        &#125; );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 去重；</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uniqList = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="comment">// value not yet in the new list?</span></span><br><span class="line">        <span class="keyword">if</span> (uniqList.indexOf( list[i] ) === <span class="number">-1</span> ) &#123;</span><br><span class="line">            uniqList.push( list[i] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uniqList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"To compose two functions together, pass the \</span></span><br><span class="line"><span class="string">output of the first function call as the input of the \</span></span><br><span class="line"><span class="string">second function call."</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueWords</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unique( words( str ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wordsUsed = uniqueWords(text);</span><br><span class="line"><span class="comment">// ["to","compose","two","functions","together","pass",</span></span><br><span class="line"><span class="comment">// "the","output","of","first","function","call","as",</span></span><br><span class="line"><span class="comment">// "input","second"]</span></span><br></pre></td></tr></table></figure><p>数据的流向：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordsUsed &lt;-- unique &lt;-- words &lt;-- text</span><br></pre></td></tr></table></figure><p>但是函数式编程喜欢声明式风格，关注点在是什么而不是怎么做，我们不需要知道具体的实现细节。我们希望是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shorterWords</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> skipLongWords( unique( words( text ) ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式</span></span><br><span class="line"><span class="keyword">var</span> shorterWords = compose( skipLongWords, unique, words );</span><br></pre></td></tr></table></figure><p>如何实现函数 <code>compose</code> ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt;</span><br><span class="line">        result =&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> list = fns.slice();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将最后一个函数从列表尾部拿出</span></span><br><span class="line">                <span class="comment">// 并执行它</span></span><br><span class="line">                result = list.pop()( result );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt;</span><br><span class="line">        fns.reverse().reduce( <span class="function">(<span class="params">fn1,fn2</span>) =&gt;</span></span><br><span class="line">            (...args) =&gt;</span><br><span class="line">                fn2( fn1( ...args ) )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：</span></span><br><span class="line"><span class="keyword">var</span> compose =</span><br><span class="line">    (...fns) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 拿出最后两个参数</span></span><br><span class="line">        <span class="keyword">var</span> [ fn1, fn2, ...rest ] = fns.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> composedFn =</span><br><span class="line">            (...args) =&gt;</span><br><span class="line">                fn2( fn1( ...args ) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rest.length == <span class="number">0</span>) <span class="keyword">return</span> composedFn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> compose( ...rest.reverse(), composedFn );</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="副作用和值的不可变性"><a href="#副作用和值的不可变性" class="headerlink" title="副作用和值的不可变性"></a>副作用和值的不可变性</h2><p><code>const</code> 是用来声明一个常量的，而常量就是不允许被重新赋值的变量。在排查问题的时，我们很少将注意力放在由 const 声明的变量上，毕竟它就是一个无关痛痒的常量。如果最终就是因为这个常量发生了变化，会不会很刺激？！虽然 const 声明的是常量，但是对于引用类型的值，程序还是允许它改变的。因为 const 的不靠谱，我们不得不重新关注由它声明的常量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = [ <span class="number">2</span> ];</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>数据的突变引发了一系列意想不到的 bug，究其原因，是变量被共享或有着不同的用处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br><span class="line"></span><br><span class="line">baz();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( x );</span><br></pre></td></tr></table></figure><p>当变量被共享时（在函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code> 中，任何一个函数都有可能改变变量 x），最终我们无法确认 x 到底是什么值，为了追踪变量 x 的变化，我们不得不仔细逐个阅读函数 <code>foo()</code>、<code>bar()</code>、<code>baz()</code>。显而易见，这给我们阅读理解代码带来了很大的麻烦。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list[i]) list[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        total = total + list[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [ <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">27</span>, , <span class="number">84</span> ];</span><br><span class="line"></span><br><span class="line">sum( nums );            <span class="comment">// 124</span></span><br><span class="line"></span><br><span class="line">sums;    <span class="comment">//[1, 3, 9, 27, 0, 84]</span></span><br></pre></td></tr></table></figure><p>而对于引用同一对象的不同变量，对象的改变也是同步的，这种改变往往是不易察觉的。所以，对于引用类型的特殊性，需要特别注意的。</p><p>归纳一下，什么样的变量被共享时需要额外上心的，外层作用域里的变量和引用类型的变量。</p><p>如何避免这种数据突变带来的状态紊乱的？可以想到的是将变量变成只读的或重新拷贝一份以作区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Object</span>.freeze( [ <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>] ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许改变：</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oops，仍然允许改变：</span></span><br><span class="line">x[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>Object.freeze</code> 等 API 将数据转为不可变，但是这种 API 的还是有局限性的，只能浅层限制不可变。要想使得一个深层嵌套的对象不可变，就需要深度遍历对每个属性使用 <code>Object.freeze</code> 等 API。</p><p>另一种思路就是拷贝一份数据，这样的话，再怎么折腾副本都不会影响到源数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addValue</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = [ ...arr, <span class="number">4</span> ];</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addValue( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );    <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure><p>在此，我们不由地想起函数式编程的核心 —— 不变性。我们看到了变化的数据给程序造成的可读性差、状态紊乱等坏处，自然我们就想到数据不变性会让程序更加友好。但值的不变性并不意味着值代表的状态不会发生改变，所以就有了值的拷贝。这种不变性是指，当需要改变程序中某个状态时，我们不能改变源数据，而是拷贝跟踪它的副本。拷贝也有深拷贝和浅拷贝，我们需要的是独立于源数据的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateLastLogin</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newUserRecord = <span class="built_in">Object</span>.assign( &#123;&#125;, user );</span><br><span class="line">    newUserRecord.lastLogin = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> newUserRecord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user = updateLastLogin( user );</span><br></pre></td></tr></table></figure><p>然而，拷贝也不是没有代价的。突然多出来的副本，多少会影响到性能。我们希望有种方式可以减少内存占用，提高性能。它使得不同变量指向同一个数据源同时有着不同版本的数据，不同版本的数据互不影响，这有点像 git 的版本控制，这样的话，值的不变性这个语义也得以保留。其实已经有一些库实现了类似的优化，如 Immutable.js 等。</p><p>如果用两个字总结以上的内容，无疑，就是「干扰」了，这种干扰来自于非预期的数据变化。</p><p>作为函数式编程的主角 —— 函数，我们自然也会希望函数内部不会造成数据的突变，一切结果是可预测的，更多的希望它能够符合函数式编程的核心 —— 不变性。也就是说，我们在编码的过程中要减少函数的副作用。</p><p>除了以上所说的数据共享，副作用还包括随机性 （<code>Math.random()</code>）、IO 操作、竞态问题等。副作用是多种多样，我们使用纯函数来减少这种副作用。换句话说，与纯函数相违背的，我们基本可以认为是副作用。</p><p>什么是纯函数？有说纯函数就是幂等函数，但并不是所有的纯函数都是数学概念上的幂等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hist = <span class="built_in">document</span>.getElementById( <span class="string">"orderHistory"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 幂等的：</span></span><br><span class="line">hist.innerHTML = order.historyText;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非幂等的：</span></span><br><span class="line"><span class="keyword">var</span> update = <span class="built_in">document</span>.createTextNode( order.latestUpdate );</span><br><span class="line">hist.appendChild( update );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非幂等的：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateAverage</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        sum += list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateAverage( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">22</span>] );            <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>另一种定义函数的方法是，给定相同的输入（一个或多个），它总是产生相同的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">circleArea</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种定义就是，即纯函数具有引用透明性。</p><blockquote><p>引用透明性是指一个函数调用可以被它的输出值所代替，并且整个程序的行为不会改变。换句话说，不可能从程序的执行中分辨出函数调用是被执行的，还是它的返回值是在函数调用的位置上内联的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateAverage</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        sum += list[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum / list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avg = calculateAverage( nums );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"The average is:"</span>, avg );        <span class="comment">// The average is: 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> avg = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"The average is:"</span>, avg );        <span class="comment">// The average is: 9</span></span><br></pre></td></tr></table></figure><p>代码的副作用降低了程序的质量，同时也加大了我们对代码的阅读难度。没有副作用的程序是不存在的，我们只是通过重构不纯的函数或封装副作用等方式来避免副作用的产生。</p><h2 id="闭包和对象"><a href="#闭包和对象" class="headerlink" title="闭包和对象"></a>闭包和对象</h2><p>首先用两段代码来描述同一个东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> happyBirthday()&#123;</span><br><span class="line">        age++;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">"Happy "</span> + age + <span class="string">"th Birthday, "</span> + name + <span class="string">"!"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> birthdayBoy = person( <span class="string">"Kyle"</span>, <span class="number">36</span> );</span><br><span class="line">birthdayBoy();            <span class="comment">// Happy 37th Birthday, Kyle!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方式</span></span><br><span class="line"><span class="keyword">var</span> birthdayBoy = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span>,</span><br><span class="line">    age: <span class="number">36</span>,</span><br><span class="line">    happyBirthday() &#123;</span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">"Happy "</span> + <span class="keyword">this</span>.age + <span class="string">"th Birthday, "</span> + <span class="keyword">this</span>.name + <span class="string">"!"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">birthdayBoy.happyBirthday();</span><br><span class="line"><span class="comment">// Happy 37th Birthday, Kyle!</span></span><br></pre></td></tr></table></figure><p>可以发现闭包和对象就是对同一事物的两种表达方式。</p><p>关于闭包和对象有着以下的论调：</p><ol><li>一个没有闭包的编程语言可以用对象来模拟闭包。</li><li>一个没有对象的编程语言可以用表报模拟对象。</li></ol><p>现在，我们在 JavaScript 中用对象模拟闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先要解决 <code>outer()</code> 执行后，<code>x</code> 变量没有被销毁。在创建函数 <code>outer</code> 时，有个对象会保存该作用域下的所有变量:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scopeOfOuter = &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建函数 <code>inner</code> 时，也会生成一个 <code>scopeOfInner</code> 的作用域对象，这个对象的原型指向 <code>scopeOfOuter</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scopeOfInner = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( scopeOfInner, scopeOfOuter );</span><br></pre></td></tr></table></figure><p>所以在访问 x 变量时，更像是在访问 scopeOfInner.x，然后沿原型链查找。</p><p>以上只是些假设，真实的情况肯定比这复杂。这里只是论证可以使用对象实现闭包，同样我们也可以使用闭包实现对象。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归可以说是很函数式，它的优点是更具有声明行，简洁易读，但最大的弊端还是内存占用方面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="string">"foo!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">"bar!"</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"baz!"</span>;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>每个函数调用都将开辟出一小块称为堆栈帧的内存。堆栈帧中包含了函数语句当前状态的某些重要信息，包括任意变量的值。之所以这样，是因为一个函数暂停去执行另外一个函数，而另外一个函数运行结束后，引擎需要返回到之前暂停时候的状态继续执行。</p><center><br><br><img src="../images/stack_heap.png" alt="stack_heap"><br><br></center><p>但是对于递归来说，可能会生成上万的堆栈，最终会导致爆栈。</p><p>我们希望内层函数在函数底部调用时，外部函数的堆栈直接弹出。</p><center><br><br><img src="../images/tailCall.png" alt="tailCall"><br><br></center><p>这种技术叫做尾调用优化。</p><p>减少内存的方法还包括后继传递风格（CPS）和 Trampoline 等。</p><blockquote><p>利用CPS变换，把任意递归函数改写成尾调用形式，以 continuation 链的形式，将递归占用的栈空间转移到堆上，避免爆栈的悲剧。（<a href="https://www.zhihu.com/question/28458981" rel="external nofollow noopener noreferrer" target="_blank">CPS变换可以用来将普通递归转变为尾递归？？</a>）</p></blockquote><blockquote><p>在缺乏尾调用优化的语言中，并不知晓函数不会返回，状态、参数压栈依旧会发生，因此需要手动强制弹出下一层调用的函数，禁止解释器的压栈行为，这就是所谓的Trampoline。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib( n - <span class="number">2</span> ) + fib( n - <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  CPS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n,cont = r =&gt; r</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> cont( n );</span><br><span class="line">    <span class="keyword">return</span> fib(</span><br><span class="line">        n - <span class="number">2</span>,</span><br><span class="line">        n2 =&gt; fib(</span><br><span class="line">            n - <span class="number">1</span>,</span><br><span class="line">            n1 =&gt; cont( n2 + n1 )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">trampolined</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = fn( ...args );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">typeof</span> result == <span class="string">"function"</span>) &#123;</span><br><span class="line">            result = result();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trampoline 化</span></span><br><span class="line">trampoline(fib(n,cont = <span class="function"><span class="params">r</span> =&gt;</span> r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> cont( n );</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> fib(</span><br><span class="line">        n - <span class="number">2</span>,</span><br><span class="line">        n2 =&gt; fib(</span><br><span class="line">            n - <span class="number">1</span>,</span><br><span class="line">            n1 =&gt; cont( n2 + n1 )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>书中还有其它章节，大部分属于实操，按下不表。对于 JavaScript 函数式编程入门，本书倒是一个不错的选择。不知道是外国人本来就说话啰嗦还是翻译的问题，<a href="https://wizardforcel.gitbooks.io/functional-light-js/content/" rel="external nofollow noopener noreferrer" target="_blank">中文版</a>有些地方读起来不是很顺畅。不过翻译向来是出力不讨好，请原谅我的吐槽，你们都是棒棒的！</p></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://www.yexiaochen.com/读《JavaScript-轻量级函数式编程》/" title="读《JavaScript 轻量级函数式编程》">http://www.yexiaochen.com/读《JavaScript-轻量级函数式编程》/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/函数式编程/" rel="tag"><i class="fa fa-tag"></i> 函数式编程</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/读《乌合之众》/" rel="next" title="读《乌合之众》"><i class="fa fa-chevron-left"></i> 读《乌合之众》</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/记开源项目的二次开发/" rel="prev" title="记开源项目的二次开发">记开源项目的二次开发 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#读后感"><span class="nav-number">1.</span> <span class="nav-text">读后感</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么函数式编程"><span class="nav-number">2.</span> <span class="nav-text">为什么函数式编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数基础"><span class="nav-number">3.</span> <span class="nav-text">函数基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的输入"><span class="nav-number">4.</span> <span class="nav-text">函数的输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合函数"><span class="nav-number">5.</span> <span class="nav-text">组合函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#副作用和值的不可变性"><span class="nav-number">6.</span> <span class="nav-text">副作用和值的不可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包和对象"><span class="nav-number">7.</span> <span class="nav-text">闭包和对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">8.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#吐槽"><span class="nav-number">9.</span> <span class="nav-text">吐槽</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>