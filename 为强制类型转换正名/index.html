<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="YH32omENY7b_BdEuIWv46jSBK-0Vyw_dWbJTGNBblT0"><meta name="baidu-site-verification" content="codeva-cs18pREvQ9"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="强制类型转换,数据类型,"><link rel="alternate" href="/atom.xml" title="贪空" type="application/atom+xml"><meta name="description" content="强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &amp;#39;hello&amp;#39;.charAt(0) (内置类型和内建函数"><meta name="keywords" content="强制类型转换,数据类型"><meta property="og:type" content="article"><meta property="og:title" content="为强制类型转换正名"><meta property="og:url" content="https://yexiaochen.github.io/为强制类型转换正名/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &amp;#39;hello&amp;#39;.charAt(0) (内置类型和内建函数"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-01-05T01:51:09.257Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="为强制类型转换正名"><meta name="twitter:description" content="强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &amp;#39;hello&amp;#39;.charAt(0) (内置类型和内建函数"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://yexiaochen.github.io/为强制类型转换正名/"><title>为强制类型转换正名 | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7503c6e413a2a7205320ec2396c811d0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yexiaochen.github.io/为强制类型转换正名/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">为强制类型转换正名</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-11T00:38:00+08:00">2018-12-11 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2019-01-05T09:51:09+08:00">2019-01-05 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/很难么/" itemprop="url" rel="index"><span itemprop="name">很难么</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">2,337 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">9 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.</p></blockquote><p>作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.</p><p><strong>猜猜看</strong>😏:</p><ol><li>作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: <code>&#39;hello&#39;.charAt(0)</code> (<a href="#内置类型和内建函数的关系">内置类型和内建函数的关系</a>)</li><li><code>a &amp;&amp; (b || c)</code> 这波操作我们知道, 那么 <code>if (a &amp;&amp; (b || c))</code>, 这里又做了哪些操作? (<a href="#条件判断">||和&amp;&amp;</a>)</li><li><code>if (a == 1 &amp;&amp; a== 2) { dosomething }</code>, <strong>dosomething</strong>竟然执行了, 什么鬼? (<a href="#ToPrimitive">ToPrimitive</a>)</li><li><code>[] == ![]</code> =&gt; true ?; <code>false == []</code> =&gt; true ?; <code>&quot;0&quot; == false</code> =&gt; true ?(<a href="#抽象相等">抽象相等</a>)</li><li><code>if (~indexOf(&#39;a&#39;))</code>, 这波操作熟悉不? (<a href="#隐式强制类型转换">+/-/!/~</a>)</li><li>在<strong>String</strong>, <strong>Number</strong>, <strong>Boolean</strong>类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (<a href="#抽象操作">抽象操作</a>)</li></ol><p>下面就要学会用实力碰运气.</p><hr><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JavaScript 有七种内置类型. <strong>空值</strong>: null, <strong>未定义</strong>: undefined, <strong>布尔值</strong>: boolean, <strong>数字</strong>: number, <strong>字符串</strong>: string, <strong>对象</strong>: object, <strong>符号</strong>: symbol. 除 <strong>对象</strong>:object, 为复杂数据类型, 其它均为基本数据类型.</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>常用的内建函数: <strong>String()</strong>, <strong>Number()</strong>, <strong>Boolean()</strong>, <strong>Array()</strong>, <strong>Object()</strong>, <strong>Function()</strong>, <strong>RegExp()</strong>, <strong>Date()</strong>, <strong>Error()</strong>, <strong>Symbol()</strong>.</p><h3 id="内置类型和内建函数的关系"><a href="#内置类型和内建函数的关系" class="headerlink" title="内置类型和内建函数的关系"></a>内置类型和内建函数的关系</h3><p>为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了<strong><em><code>问题 1</code></em></strong>.</p><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><strong><em>typeof</em></strong> =&gt; 基本类型的检测均有同名的与之对应. <strong>null</strong> 除外(不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为 0 会被判断为 Object 类型, null 的二进制表示为0, 前三位自然为0, 所以执行 typeof 时会返回 <code>&#39;object&#39;</code>.), null是假值, 也是唯一一个typeof检测会返回 <code>&#39;object&#39;</code> 的基本数据类型值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">'object'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>复杂数据类型typeof检测返回 <code>&#39;object&#39;</code>, function(函数)除外. 函数因内部属性 <code>[[Call]]</code> 使其可被调用, 其实属于可调用对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure><p><strong><em>Object.prototype.toString</em></strong> =&gt; 通过typeof检测返回<code>&#39;object&#39;</code>的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(…)来查看.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">const</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(num))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [object String]</span></span><br><span class="line"><span class="comment">// [object Number]</span></span><br><span class="line"><span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><hr><h2 id="抽象操作"><a href="#抽象操作" class="headerlink" title="抽象操作"></a>抽象操作</h2><p>在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.1" rel="external nofollow noopener noreferrer" target="_blank">ToPrimitive</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.8" rel="external nofollow noopener noreferrer" target="_blank">ToString</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3" rel="external nofollow noopener noreferrer" target="_blank">ToNumber</a></strong>, <strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.2" rel="external nofollow noopener noreferrer" target="_blank">ToBoolean</a></strong>. 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则(显式和隐式的命名叫法来自《你不知道的JavaScript》). 这里就解释了<strong><em><code>问题 5</code></em></strong>和<strong><em><code>问题 6</code></em></strong>.</p><h3 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="ToPrimitive"></a>ToPrimitive</h3><p>该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法<code>[[DefaultValue]]</code> 遵循一定规则返回非复杂数据类型, 规则详见<strong><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8" rel="external nofollow noopener noreferrer" target="_blank">DefaultValue</a></strong>. 故 <strong>ToString</strong>, <strong>ToNumber</strong>, <strong>ToBoolean</strong>在处理Object时, 会先经过<strong>ToPrimitive</strong>处理返回基本类型值.</p><p><strong><code>[[DefaultValue]](hint)</code>语法:</strong><br><code>[[DefaultValue]]</code>的规则会依赖于传入的参数<code>hint</code>, <strong>ToString</strong>传入的 <code>hint</code> 值为 <code>String</code>, <strong>ToNumber</strong>传入的 <code>hint</code> 值为 <code>Number</code>.</p><ol><li><code>[[DefaultValue]](String)</code> =&gt; 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]](Number)</code> =&gt; 该规则正好和上规则调用 <code>toString</code>, <code>valueOf</code> 的顺序相反. 若 <code>valueOf</code> 可调用, 且 <code>valueOf(Obj)</code> 为基本类型值, 则返回该基本类型值. 否则, 若 <code>toString</code> 可调用, 且 <code>toString(Obj)</code> 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 <code>TypeError</code>.</li><li><code>[[DefaultValue]]()</code> =&gt; 未传参时, 按照 <code>hint</code>值为 <code>Number</code> 处理. <code>Date</code> 对象除外, 按照<code>hint</code>值为 <code>String</code> 处理.</li></ol><p>现在我们就用以上的知识点来解释<strong><em><code>问题 3</code></em></strong>是什么鬼.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Number</span>.prototype.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i++</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"0"</span>); <span class="comment">// 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a_1:'</span>, a);</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a==1 &amp; a==2'</span>, <span class="string">'i:'</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a==1 &amp; a==2 i: 3</span></span><br></pre></td></tr></table></figure><p>我们改写了内建函数 <strong><em>Number</em></strong> 原型上的 <code>valueOf</code> 方法, 并使得一个字符串转换成 <strong><em>Number</em></strong> 对象, 第一次 <strong><em>Object</em></strong> 类型和 <strong><em>Number</em></strong> 类型做比较时, <strong><em>Object</em></strong> 类型将进行 <strong><em>ToPrimitive</em></strong> 处理(<a href="#抽象相等">抽象相等</a>), 内部调用了 <strong><em>valueOf</em></strong>, 返回 <strong><em>2</em></strong>. 第二次同样的处理方式, 返回 <strong><em>3</em></strong>.</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h3><p>该抽象操作负责处理非字符串到字符串的转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">“null”</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">“undefined”</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">true =&gt; “true”; false =&gt; “false”</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">number</td><td style="text-align:center"><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.8.1" rel="external nofollow noopener noreferrer" target="_blank">ToString Applied to the Number Type</a></td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">先经<a href="#ToPrimitive">ToPrimitive</a>返回基本类型值, 再遵循上述规则</td></tr></tbody></table><h3 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h3><p>该抽象操作负责处理非数字到数字的转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">+0</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">NaN</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">true =&gt; 1; false =&gt; 0</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center"><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.3.1" rel="external nofollow noopener noreferrer" target="_blank">ToNumber Applied to the String Type</a></td></tr><tr><td style="text-align:center">number</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">先经<a href="#ToPrimitive">ToPrimitive</a>返回基本类型值, 再遵循上述规则</td></tr></tbody></table><p><strong>常见的字符串转换数字:</strong></p><ol><li>字符串是空的 =&gt; 转换为0.</li><li>字符串只包含数字 =&gt; 转换为十进制数值.</li><li>字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.</li><li>字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.</li><li>字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.</li></ol><h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>该抽象操作负责处理非布尔值到布尔值转换.</p><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">null</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">undefined</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">不转换</td></tr><tr><td style="text-align:center">string</td><td style="text-align:center">“” =&gt; false; 其它 =&gt; true</td></tr><tr><td style="text-align:center">number</td><td style="text-align:center">+0, −0, NaN =&gt; false; 其它 =&gt; true</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">true</td></tr></tbody></table><p><strong>真值</strong> &amp; <strong>假值</strong><br>假值(强制类型转换<strong>false</strong>的值) =&gt; <code>undefined</code>, <code>null</code>, <code>false</code>, <code>+0</code>, <code>-0</code>, <code>NaN</code>, <code>&quot;&quot;</code>.<br>真值(强制类型转换<strong>true</strong>的值) =&gt; 除了假值, 都是真值.</p><p><strong><em>特殊的存在</em></strong><br>假值对象 =&gt; documen.all 等. eg: <code>Boolean(window.all)</code> // false</p><hr><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><h3><a href="#" class="headerlink" title="+/-/!/~"></a>+/-/!/~</h3><ol><li><strong><code>+/- 一元运算符</code></strong> =&gt; 运算符会将操作数进行ToNumber处理.</li><li><strong><code>!</code></strong> =&gt; 会将操作数进行ToBoolean处理.</li><li><strong><code>~</code></strong> =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (…)中作类型转换时, 只有<code>-1</code>时, 才为假值.</li><li><strong><code>+加号运算符</code></strong> =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.</li></ol><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ol><li><code>if (...)</code>, <code>for(;;;)</code>, <code>while(...)</code>, <code>do...while(...)</code>中的条件判断表达式.</li><li><code>? :</code> 中的条件判断表达式.</li><li><code>||</code> 和 <code>&amp;&amp;</code> 中的中的条件判断表达式.</li></ol><p>以上遵循ToBoolean规则.</p><h3 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="||和&amp;&amp;"></a>||和&amp;&amp;</h3><ol><li>返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.</li><li><strong><code>||</code></strong> =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;</li><li><strong><code>&amp;&amp;</code></strong> =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;</li></ol><p>结合条件判断, 解释下<strong><em><code>问题 2</code></em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">if</span> (a &amp;&amp; (b || c)) &#123;</span><br><span class="line">    dosomething()</span><br><span class="line">&#125;</span><br><span class="line">a &amp;&amp; (b || c) 返回 <span class="string">'hello'</span>, <span class="keyword">if</span>语句中经Toboolean处理强制类型转换为<span class="literal">true</span>.</span><br></pre></td></tr></table></figure><h3 id="抽象相等"><a href="#抽象相等" class="headerlink" title="抽象相等"></a>抽象相等</h3><p>这里的知识点是用来解释 <strong><em>问题 4</em></strong> 的, 也是考验人品的地方. 这下我们要靠实力拼运气.</p><ol><li><p>同类型的比较.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="number">0</span> == <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false, 唯一一个非自反的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>null</em></strong> 和 <strong><em>undefined</em></strong> 的比较.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>Number</em></strong> 类型和 <strong><em>String</em></strong> 类型的比较. =&gt; <strong><em>String</em></strong> 类型要强制类型转换为 <strong><em>Number</em></strong> 类型, 即 <strong><em>ToNumber(String)</em></strong>.(参见<a href="#ToNumber">ToNumber</a>)</p></li><li><strong><em>Boolean</em></strong> 类型和其它类型的比较. =&gt; <strong><em>Boolean</em></strong> 类型要强制类型转换为 <strong><em>Number</em></strong> 类型, 即 <strong><em>ToNumber(Boolean)</em></strong>.(参见<a href="#ToNumber">ToNumber</a>)</li><li><strong><em>Object</em></strong> 类型和 <strong><em>String</em></strong> 类型或 <strong><em>Number</em></strong> 类型. =&gt; <strong><em>Object</em></strong> 类型要强制转换为基本类型值, 即 <strong><em>ToPrimitive(Object)</em></strong>.(参见<a href="#ToPrimitive">ToPrimitive</a>)</li><li>其它情况, <strong><em>false</em></strong>.</li></ol><p>回头看看<strong><em>问题 4</em></strong>中的等式. <code>[] == ![]</code>, <code>false == []</code>, <code>&quot;0&quot; == false</code>.<br><code>[] == ![]</code> =&gt; <code>!</code> 操作符会对操作数进行<strong><em>ToBoolean</em></strong>处理, <code>[]</code> 是真值, <code>!true</code> 则为 <strong><em>false</em></strong>. 再遵循第 <strong><em>4</em></strong> 点, <strong><em>Boolean</em></strong> 类型经过 <strong><em>ToNumber</em></strong> 转换为 <strong><em>Number</em></strong>类型, 则为数值 <code>0</code>. 再遵循第 <strong><em>5</em></strong> 点, 对 <code>[]</code> 进行 <strong><em>ToPrimitive</em></strong> 操作, 先后调用 <code>valueOf()</code>, <code>toString()</code>直到返回基本类型, 直到返回 <code>&quot;&quot;</code>. <em>(先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; “”, 基本类型值, 返回该基本类型值.)</em>. 再遵循第 <strong><em>3</em></strong> 点, 对 <code>&quot;&quot;</code> 进行 <strong><em>ToNumber</em></strong>处理, 则为数值 <code>0</code>. 到此, <code>0 == 0</code>, 再遵循第 <strong><em>1</em></strong> 点(其实没写全😌, 详见<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3" rel="external nofollow noopener noreferrer" target="_blank">The Abstract Equality Comparison Algorithm</a>), return true, 完美!😏.<br><code>false == []</code> =&gt; 同理 <code>[] == ![]</code>.<br><code>&quot;0&quot; == false</code> =&gt; 同理 <code>[] == ![]</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[] == ![]   <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// true</span></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><p>运气是留给有准备的人, 所以呢, 我要准备买彩票了.😏</p></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://yexiaochen.github.io/为强制类型转换正名/" title="为强制类型转换正名">https://yexiaochen.github.io/为强制类型转换正名/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/强制类型转换/" rel="tag"><i class="fa fa-tag"></i> 强制类型转换</a> <a href="/tags/数据类型/" rel="tag"><i class="fa fa-tag"></i> 数据类型</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/String原型方法/" rel="next" title="String原型方法"><i class="fa fa-chevron-left"></i> String原型方法</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/从Function入手原型链/" rel="prev" title="从Function入手原型链">从Function入手原型链 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#强制类型转换"><span class="nav-number">1.</span> <span class="nav-text">强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引子"><span class="nav-number">1.1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型"><span class="nav-number">1.2.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型"><span class="nav-number">1.2.1.</span> <span class="nav-text">内置类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内建函数"><span class="nav-number">1.2.2.</span> <span class="nav-text">内建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内置类型和内建函数的关系"><span class="nav-number">1.2.3.</span> <span class="nav-text">内置类型和内建函数的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型检测"><span class="nav-number">1.2.4.</span> <span class="nav-text">类型检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象操作"><span class="nav-number">1.3.</span> <span class="nav-text">抽象操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ToPrimitive"><span class="nav-number">1.3.1.</span> <span class="nav-text">ToPrimitive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ToString"><span class="nav-number">1.3.2.</span> <span class="nav-text">ToString</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ToNumber"><span class="nav-number">1.3.3.</span> <span class="nav-text">ToNumber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ToBoolean"><span class="nav-number">1.3.4.</span> <span class="nav-text">ToBoolean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式强制类型转换"><span class="nav-number">1.4.</span> <span class="nav-text">隐式强制类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null"><span class="nav-number">1.4.1.</span> <span class="nav-text">+/-/!/~</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件判断"><span class="nav-number">1.4.2.</span> <span class="nav-text">条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和-amp-amp"><span class="nav-number">1.4.3.</span> <span class="nav-text">||和&amp;&amp;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象相等"><span class="nav-number">1.4.4.</span> <span class="nav-text">抽象相等</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>