<!DOCTYPE html><html class="theme-next mist" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="YH32omENY7b_BdEuIWv46jSBK-0Vyw_dWbJTGNBblT0"><meta name="baidu-site-verification" content="codeva-cs18pREvQ9"><link href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.206/distr/fira_code.css" rel="stylesheet" type="text/css"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><meta name="keywords" content="贪空, 前端"><meta name="description" content="一刷看热闹，二刷看门道。看不懂的东西，看着看着就懂了；看懂的东西，看着看着就通了。编程范式概述在说 SOLID 原则前，还是有必要先了解下程序的编写模式，即，编程范式。如果说设计原则是为了更好得组织代码，那么，编程范式就是为了让我们有选择得使用不同的代码结构。到目前为止，编程范式有：结构化编程，面向对象编程和函数式编程。编程范式的每次变革都对后世产生了深远的影响。在「程序员」出现之前，编程是不受待"><meta name="keywords" content="前端 js JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="SOLID设计原则JavaScript描述"><meta property="og:url" content="https://yexiaochen.github.io/SOLID设计原则JavaScript描述/index.html"><meta property="og:site_name" content="贪空"><meta property="og:description" content="一刷看热闹，二刷看门道。看不懂的东西，看着看着就懂了；看懂的东西，看着看着就通了。编程范式概述在说 SOLID 原则前，还是有必要先了解下程序的编写模式，即，编程范式。如果说设计原则是为了更好得组织代码，那么，编程范式就是为了让我们有选择得使用不同的代码结构。到目前为止，编程范式有：结构化编程，面向对象编程和函数式编程。编程范式的每次变革都对后世产生了深远的影响。在「程序员」出现之前，编程是不受待"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2023-02-06T15:15:17.311Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="SOLID设计原则JavaScript描述"><meta name="twitter:description" content="一刷看热闹，二刷看门道。看不懂的东西，看着看着就懂了；看懂的东西，看着看着就通了。编程范式概述在说 SOLID 原则前，还是有必要先了解下程序的编写模式，即，编程范式。如果说设计原则是为了更好得组织代码，那么，编程范式就是为了让我们有选择得使用不同的代码结构。到目前为止，编程范式有：结构化编程，面向对象编程和函数式编程。编程范式的每次变革都对后世产生了深远的影响。在「程序员」出现之前，编程是不受待"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"5.1.4",sidebar:{position:"left",display:"hide",offset:12,b2t:!1,scrollpercent:!1,onmobile:!0},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://yexiaochen.github.io/SOLID设计原则JavaScript描述/"><title>SOLID设计原则JavaScript描述 | 贪空</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7503c6e413a2a7205320ec2396c811d0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">贪空</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">贪空 Blog</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://yexiaochen.github.io/SOLID设计原则JavaScript描述/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="贪空"><meta itemprop="description" content><meta itemprop="image" content="/images/avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="贪空"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">SOLID设计原则JavaScript描述</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-01T09:42:38+08:00">2020-03-01 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于&#58;</span> <time title="更新于" itemprop="dateModified" datetime="2023-02-06T23:15:17+08:00">2023-02-06</time></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">4,350 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">16 分钟</span></div></div></header><div class="post-body han-init-context" itemprop="articleBody"><blockquote><p>一刷看热闹，二刷看门道。看不懂的东西，看着看着就懂了；看懂的东西，看着看着就通了。</p></blockquote><h2 id="编程范式概述"><a href="#编程范式概述" class="headerlink" title="编程范式概述"></a>编程范式概述</h2><p>在说 SOLID 原则前，还是有必要先了解下程序的编写模式，即，编程范式。如果说设计原则是为了更好得组织代码，那么，编程范式就是为了让我们有选择得使用不同的代码结构。</p><p>到目前为止，编程范式有：结构化编程，面向对象编程和函数式编程。编程范式的每次变革都对后世产生了深远的影响。</p><p>在「程序员」出现之前，编程是不受待见的。一个证明不了自身的玩意，如何让别人信服。Dijkstra 希望通过数学推导的方法来证明程序的正确性。</p><p>不过在此之前，Bohm 和 Jocopini 证明了顺序结构、分支结构和循环结构组合在一起可以构造出任何程序。</p><blockquote><p>这也证明了构建可推导模块所需要的控制结构集与构建所有程序所需要的控制结构集的最小集是等同的。</p></blockquote><p>在这里结构化编程算是诞生了，接下来 Dijkstra 只要证明这些结构的正确性及串联起这些结构所用代码的正确性，就可以推导出整个程序的正确性。最终，在结构化编程范式下，通过数学证明和科学证伪推导出了当下程序的正确性。</p><blockquote><p>结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。</p></blockquote><p>再说说面向对象编程，什么是面向对象编程，耳熟能详的就是面向对象编程的三大特性：封装、继承和多态。这些特性并非面向对象编程语言所独有，有的特性甚至不是面向编程语言的强项，唯一值得说的特性也就只有多态了。在面向编程语言里，多态的使用变得更加安全、更加方便了。</p><p>对于面向编程的解释，有说是「面向对象编程是一种对真实世界进行建模的方式」，我觉得更贴切的说法是，「面向对象是一种对人类生活的世界进行建模的方式」。在结构化编程范式中，验证大型系统的正确性，可以通过将大型系统拆分成模块和组件，进而拆分成更小、可证明的函数并对其进行测试。现在，我们再把这个过程反过来看，这些小函数或模块、组件，又是如何高效组合成一个大型的系统呢？在这一点上，人类很擅长。</p><p>我们都知道，国外有很多唐人街，而且有些唐人街存在很久了，即使住在唐人街的华人从未来过中国，但并不妨碍与土生土长的中国人进行交流。不管相隔的多远，繁衍了多少代，只要大家还有对中华文明的认同，就不会出现无法沟通的情况。这种认同感不仅可以跨越时间和空间，更是在需要的时候凝聚力量，由此次疫情（新冠肺炎）可见一斑。</p><p>面向对象中的多态，更像是不同组件对于某种契约的认同。而基于这种认同，我们可以实现依赖反转，摆脱控制流决定源代码依赖关系的现象。</p><blockquote><p>面向对象编程就是以多态为手段来对源代码的依赖关系进行控制的能力，这种能力让软件架构师可以构造出某种插件式架构，让高层策略性组件与底层实现性组件分离，底层组件可以被编译成插件，实现独立与高层组件的开发和部署。</p></blockquote><p>至于函数式编程，它所遵循的原理倒是很简单：函数式编程语言中的变量是不可变的。</p><p>仅从<a href="https://yexiaochen.github.io/%E8%AF%BB%E3%80%8AJavaScript-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B/">读《JavaScript 轻量级函数式编程》</a>中，我们就可以看到变量的可变性带来的一些危害。鉴于此，把应用程序可分为可变和不可变的部分，将逻辑重点放在不可变组件中，并用合适的机制保护可变量。</p><p>事件溯源就很好体现出了面向函数编程的思维。</p><p>最后再用文中的话总结下三大编程范式：</p><blockquote><p>多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各种模块的算法实现基础。</p><p>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</p></blockquote><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>通过上文，我们已经知道大型的系统可以拆分为更小的函数。现在我们需要做的是，将函数和数据结构组合成模块，模块聚合成组件，组件耦合成系统。不论是模块，还是组件，抑或是其它的数据与函数的结合体，它们在某一层面上都是最小的单元。</p><p>如何高效的组装它们，就需要一个设计原则来指导它们达成最佳实践。这种思想，没有具体的模式却有明确的目标：</p><blockquote><ul><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。</li></ul></blockquote><p>在上文中，我们把编程世界类比成了人类世界。人作为社会中的人，不仅要演好自己本职角色，同时也要扮演好社会赋予的角色。所以，我们经常会听到「人在江湖，身不由己」这样的感概。而在系统中，作为不同意义上的单元，也要处理好单元内部和单元之间的问题，在这里，更多的是指处理好单元间的依赖关系。用人话说，这种「依赖」多少有点「牵连」的意思。</p><p>设计原则是什么先不说，我们先谈谈依赖关系的重要性。（以下论述从组件的角度，依赖关系大同小异）</p><p>关于组件的依赖关系并不是从一开始就需要关注的，组件依赖关系更注重的是应用程序的构建性和维护性。如果一个软件系统自搭建以来从未发生过变化，以后也不会发生变化，我们也没必要理会所谓的设计原则，即使你用了这些最佳实践，意义又何在呢。</p><blockquote><ul><li>无依赖环原则：组件依赖关系图中不应该出现环。</li><li>稳定依赖原则：依赖关系必须要指向更稳定的方向。</li><li>稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。</li></ul></blockquote><p><strong>无依赖环原则</strong>：当组件耦合在一起时，是不应该出现循环依赖关系的，这个循环中的组件会构成一个更大的组件，对于构建发布是不利的。</p><p><strong>稳定依赖原则</strong>：一个可维护的系统应该包含可变的和稳定的两部分，而且可变的应该依赖于稳定的。这种依赖是一种约束也是一种信任，反过来想想，如果不稳定的组件被稳定的组件所依赖，就意味着不稳定元素必须趋于稳定才能保证稳定组件的稳定，这种可变也将会变得难以修改。换句话说，一个组件被越多的组件所依赖，就越需要保证该组件稳定性。</p><p><strong>稳定抽象原则</strong>：这就要求稳定的组件也应该是抽象的，可变的组件也应该是具体的。再结合上一条原则，就可以概括为，依赖关系应该指向更抽象的方向。</p><p>以上内容是从组件耦合的角度对组件提出的要求，接下来回到主题。</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>任何一个软件模块都应该只对一类行为者负责。</p></blockquote><p>对于我们来说，最熟悉的就是单一职责原则了，一个函数只完成一个功能，这是单一职责在实现细节上的体现，但是这并不代表单一职责的全部。</p><p>我们先把软件模块当成数据与函数的结合体，刚开始时，当一个软件模块对多类行为者负责时，说明该软件模块能够兼容多类行为者的功能。当多类行为者的差异愈加明显时，该软件模块也会愈加频繁的调整。从稳定依赖原则中，我们已经知道，「一个组件被越多的组件所依赖，就越需要保证该组件稳定性。」</p><p>同时，这个原则也指导我们要不要去复用一个软件模块。这个软件模块对哪类行为负责？将要依赖该模块的软件模块是否属于该类行为？现在流行的微服务架构，根据不同领域的划分，即使有共同的模块，也不见得会复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  COOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CFO</span></span><br><span class="line">Employee.CFOHours();</span><br><span class="line"></span><br><span class="line"><span class="comment">// COO</span></span><br><span class="line">Employee.COOHours();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：6.6000000000000005</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">这个模块中有 `CFOHours` 和 `COOHours`，而且这两个行为共享 `regularHours`,</span></span><br><span class="line"><span class="comment">如果 CFO 的人在 COO 不知情的情况下改了 `regularHours`，定会影响到 COO。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要想避免这种情况，就应该将不同类的行为分开。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CFO = <span class="built_in">Object</span>.create(Employee);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;;</span><br><span class="line">CFO.CFOHours = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;;</span><br><span class="line">CFO.CFOHours();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> COO = <span class="built_in">Object</span>.create(Employee);</span><br><span class="line">COO.COOHours = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">` 我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">COO.COOHours();</span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote><p>接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。</p></blockquote><p>从字面意思上看，单一职责是从软件模块开发者的角度出发，接口隔离则是从软件模块使用者的角度去考虑。如果说单一职责是对某一类行为的划分，而这行为的划分粒度就要取决于模块的使用者。</p><p>作为前端开发者，违背接口隔离原则的反例也不少见。在项目开发中，经常会使用第三方库，有时候即使只是使用了该库的极少数方法，也需要安装该库的全部依赖，而在安装第三方库时，经常会遇到该库依赖包版本不兼容的问题导致整个项目启动崩溃，这个不兼容的依赖包所提供的方法可能压根不会用到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">`CFOHours` 和 `COOHours` 都是对各自行为者负责，但是对于公司来说，这些又都是公司自己内部的行为。</span></span><br><span class="line"><span class="comment">本来不同类的行为也会因为使用者的不同而耦合在一起，即使如此，上面的危害依然存在，此时就需要隔离了。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ICFO = &#123;</span><br><span class="line">  regularHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICFO接口：regularHours'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICFO接口：CFOHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ICOO = &#123;</span><br><span class="line">  COOHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ICOO接口：COOHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  CFOHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == ICFO) &#123;</span><br><span class="line">      obj.CFOHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  COOHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == ICOO) &#123;</span><br><span class="line">      obj.COOHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CFO = <span class="built_in">Object</span>.create(ICFO);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;</span><br><span class="line">CFO.CFOHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.CFOHours(CFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> COO = <span class="built_in">Object</span>.create(ICOO);</span><br><span class="line">COO.COOHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;self.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.COOHours(COO)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。<br>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p></blockquote><p>这表示一个良好的系统应该是稳定的、灵活的。所谓稳定，不会因为需求小小的变动而导致系统大幅度修改。与其说抗拒修改，倒不说系统对修改的容忍程度比较高，这从组件耦合原则中可看出一二。而灵活则要求一个良好的软件系统应该在不需要修改的前提下可以轻易扩展。</p><p>开闭原则在理念上可以划分为两个派别，梅耶开闭原则和多态开闭原则。（本次只谈谈对多态开闭原则的理解）</p><blockquote><p>梅耶开闭原则：梅耶的定义提倡实现继承。具体实现可以通过继承方式来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有的接口。<br>多态开闭原则：多态开闭原则的定义倡导对抽象基类的继承。接口规约可以通过继承来重用，但是实现不必重用。已存在的接口对于修改是封闭的，并且新的实现必须，至少，实现那个接口。</p></blockquote><p>系统中包含着变化的和不变的两部分，把不变的封装起来，把变化的隔离起来。而对于变化的部分也可以求同存异，把变化中的相同部分与封装起来的不变部分约定一下，就成了实现多态的必备因素 —— 契约。实际上，这个契约应该由高级组件来定义，低级组件去遵守的，在依赖反转中有更详细的要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IHours = &#123;</span><br><span class="line">  logHours() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'IHours接口：IHours'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Employee = &#123;</span><br><span class="line">  regularHours(hour) &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeHour = hour * <span class="number">1.1</span>;</span><br><span class="line">    <span class="keyword">return</span> fakeHour;</span><br><span class="line">  &#125;,</span><br><span class="line">  logHours(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.getPrototypeOf(obj) == IHours) &#123;</span><br><span class="line">      obj.logHours(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CFO = <span class="built_in">Object</span>.create(IHours);</span><br><span class="line">CFO.regularHours = <span class="function"><span class="keyword">function</span> (<span class="params">hour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fakeHour = hour * <span class="number">1.2</span>;</span><br><span class="line">  <span class="keyword">return</span> fakeHour;</span><br><span class="line">&#125;</span><br><span class="line">CFO.logHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 CFO 的人，不服来战！工作时长为：<span class="subst">$&#123;<span class="keyword">this</span>.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.logHours(CFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> COO = <span class="built_in">Object</span>.create(IHours);</span><br><span class="line">COO.logHours = <span class="function"><span class="keyword">function</span> (<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是 COO 的人，谁敢不服！工作时长为：<span class="subst">$&#123;self.regularHours(<span class="number">6</span>)&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">Employee.logHours(COO)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我是 CFO 的人，不服来战！工作时长为：7.199999999999999</span></span><br><span class="line"><span class="comment">// 我是 COO 的人，谁敢不服！工作时长为：6.6000000000000005</span></span><br></pre></td></tr></table></figure><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p>“派生类（子类）对象可以在程序中代替其基类（超类）对象。”，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件你可以相互替换。</p></blockquote><p>如果这条原则重点是在强调可替换，那就和上一条原则差不多了，这个暂时放一放。如果是说关于继承的，个人的理解是，如果子类需要覆写父类，也就没有必要从该父类去继承。</p><h3 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h3><blockquote><p>依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p></blockquote><p>关于这条原则，之前的博文有专门的写过，这里也不提了。见<a href="https://yexiaochen.com/DIP%E3%80%81IoC%E3%80%81DI%E3%80%81JS/" rel="external nofollow noopener noreferrer" target="_blank">DIP、IoC、DI、JS</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上即全部内容，关于代码实现没有使用类而是基于行为委托，就是因为简单省事。设计原则就是一种思想，思想应该是灵活的，而不应该拘泥于任何一种表现形式。</p><p>参考：</p><ul><li>《架构整洁之道》</li><li>《JavaScript 设计模式与开发实践》</li><li>《你不知道的 JavaScript》</li><li><a href="https://www.cnblogs.com/nankezhishi/archive/2012/05/26/dip.html" rel="external nofollow noopener noreferrer" target="_blank">小例子背后的大道理——从DIP中“倒置”的含义说接口的正确使用</a></li></ul></div><div><div><div style="text-align:center;color:#555;font-size:18px">------------- The End -------------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> 贪空</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://yexiaochen.github.io/SOLID设计原则JavaScript描述/" title="SOLID设计原则JavaScript描述">https://yexiaochen.github.io/SOLID设计原则JavaScript描述/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/读《娱乐至死》/" rel="next" title="读《娱乐至死》"><i class="fa fa-chevron-left"></i> 读《娱乐至死》</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2020年阶段性总结/" rel="prev" title="2020年阶段性总结">2020年阶段性总结 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="贪空"><p class="site-author-name" itemprop="name">贪空</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:2277438436@qq.com" target="_blank" title="E-Mail" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#编程范式概述"><span class="nav-number">1.</span> <span class="nav-text">编程范式概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原则"><span class="nav-number">2.</span> <span class="nav-text">设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一职责原则"><span class="nav-number">2.1.</span> <span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口隔离原则"><span class="nav-number">2.2.</span> <span class="nav-text">接口隔离原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开闭原则"><span class="nav-number">2.3.</span> <span class="nav-text">开闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#里氏替换原则"><span class="nav-number">2.4.</span> <span class="nav-text">里氏替换原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖反转原则"><span class="nav-number">2.5.</span> <span class="nav-text">依赖反转原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">3.</span> <span class="nav-text">结语</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">贪空</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){new Gitalk({id:window.decodeURIComponent(window.location.pathname),owner:"yexiaochen",repo:"blogComments",distractionFreeMode:!1,admin:["yexiaochen"],clientSecret:"5df7f4f6edb8a65fef2d0cf7cb6fa40b04a44525",clientID:"fad749b2b67be41f767a"}).render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>